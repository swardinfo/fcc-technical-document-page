<!DOCTYPE html>
<html lang="en">
    <head>
        <!--meta-->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <!--title-->
        <title>C# Documentation</title>

        <!--css-->
        <link rel="stylesheet" href="css/style.css">

    </head>

    <body>
        <!-- SECTION Main menu -->
        <!-- project requirement - nav element with a corresponding id="navbar" -->
        <nav id="navbar">
            <!-- project requirement - navbar should contain one header element with text describing topic of technical documentation -->
            <!-- project requirement - header element in navbar must come before any link elements -->
            <header><h1>C# Guide</h1></header>
            <ul>
                <!-- project requirement - navbar contains link elements with class of nav-link, one for every element with class main-section -->
                <!-- project requirement - each nav-link element should contain text corresponding header text in each section -->
                <!-- project requirement - clicking nav-link element navigates page to the corresponding main-doc section -->
                <li><a class="nav-link" href="#Introduction">Introduction</a></li>
                <li><a class="nav-link" href="#C_Sharp_and_Dot_NET">C Sharp and Dot NET</a></li>
                <li><a class="nav-link" href="#Integrated_Development_Environment">Integrated Development Environment</a></li>
                <li><a class="nav-link" href="#Create_a_Hello_World_Project">Create a Hello World Project</a></li>
                <li><a class="nav-link" href="#Code_Syntax">Code Syntax</a></li>
                <li><a class="nav-link" href="#Comments_and_Task_Lists">Comments and Task Lists</a></li>
                <li><a class="nav-link" href="#Variables,_Constants,_Types_and_Literals">Variables, Constants, Types and Literals</a></li>
                <li><a class="nav-link" href="#Characters_and_Strings">Characters and Strings</a></li>
                <li><a class="nav-link" href="#Expressions_and_Operators">Expressions and Operators</a></li>
                <li><a class="nav-link" href="#Decision_Making_Statements">Decision Making Statements</a></li>
                <li><a class="nav-link" href="#Iteration_Statements">Iteration Statements</a></li>
                <li><a class="nav-link" href="#Arrays_and_Data_Structures">Arrays and Data Structures</a></li>
                <li><a class="nav-link" href="#Enumerators">Enumerators</a></li>
                <li><a class="nav-link" href="#Classes,_Structs,_Interfaces_and_Inheritance">Classes, Structs, Interfaces and Inheritance</a></li>
                <li><a class="nav-link" href="#Anonymous_function_expressions">Anonymous function expressions</a></li>
                <li><a class="nav-link" href="#References_and_Namespaces">References and Namespaces</a></li>
                <li><a class="nav-link" href="#Scope_and_Access_Modifiers">Scope and Access Modifiers</a></li>
                <li><a class="nav-link" href="#Object-oriented_Programming">Object-oriented Programming</a></li>
                <li><a class="nav-link" href="#Keywords_and_Specifications">Keywords and Specifications</a></li>
                <li><a class="nav-link" href="#References">References</a></li>
                <li><a class="nav-link" href="#Disclaimer">Disclaimer</a></li>
            </ul>
        </nav>
        <!-- !SECTION -->

        <!-- project requirement - main element with id="main-doc" -->
        <main id="main-doc">
            <!-- project requirement - several section elements, each with a class of main-section. There should be a minimum of 5 -->
            <!-- project requirement - section with class of main-section, id corresponds to header text, spaces replaced with underscores -->

            <!-- SECTION Introduction -->
            <section class="main-section" id="Introduction">
                <header><h2>Introduction</h2></header>
                <!-- project requirement -  first element in each .main-section is a header element which contains text that describes the topic -->
                    <article>
                        <!-- project requirement - .main-section elements should contain at least 10 p elements total, not each -->
                        <p>The purpose of this guide is to give you an idea of what C# is about and the tools it provides for writing an application. What this is not is
                            a step by step guide into computer programming. Whilst someone with no programming skills may get some benefit, this guide it is aimed at
                            those who have experience with other languages and want to see what C# has to offer.</p>

                        <p>So what do you need to know. Firstly, developing an application in almost any programming language will require
                            some basic maths skills, such as, logical thinking, basic algebra, knowing the difference between integers and floating
                            point numbers, etc. You should also know how to install and upgrade software and operating systems on a computer and
                            have an internet connection. It would also be useful to know some of the basics of how a computer works such as CPU's, memory,
                            etc.</p>

                        <p>Lastly and perhaps most importantly you should have skills in theory of mind and empathy i.e. what the user maybe thinking and how they
                            feel. These should be a constant consideration as you create your application. For example, entering a letter in a
                            program when a number is required may be invalid. Having a popup error message with each wrong keystroke that then needs to be cancelled will
                            quickly lead to frustration and your program ending up in the trash.
                        </p>
                    </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION C# Language -->
            <section class="main-section" id="C_Sharp_and_Dot_NET">
                <header><h2>C Sharp and Dot NET</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p><i>Note: The correct title for this section is <b>C# and .NET</b> but has been changed due to technical limitations</i></p>

                    <h3>The C# language</h3>

                    <p>C# is a high level computer language created and maintained by Microsoft for the purpose of developing computer programs.
                        A computer uses binary, the language of ones and zeros. To put it at its simplest all a computer can do is like a light switch
                        turn things on or off, albeit at billions of times a second. For any person trying to write in ones and zeros, this soon becomes
                        an impossible task. A high level programming language is a type of shorthand that is human readable making it easier for a developer to
                        read and write code.</p>

                    <h3>.NET</h3>

                    <p>.NET is an open-source, cross platform framework created and maintained by Microsoft. It provides the <b>Common Language Runtime</b>(CLR) which
                        will run our code and other services such as memory management, debugging, garbage collection, etc, making our job of writing code easier.
                        The phrase <b>'during runtime'</b>, is often used to refer to the time in which the code is running.</p>

                    <p>.NET also provides a large quantity of pre written code we can use that provides many of the basic functions such as file I/O, network
                        access, collections, user interfaces, etc, so we don't have to write our own. Whenever a console, WinForms or WPF application is created
                        the .NET framework is added by default and can be accessed through the System namespace. At the time of this writing the current version
                        is .Net 5.0.</p>

                    <p>The reference documentation for C# and .NET can be found at <a href="https://docs.microsoft.com/en-us/dotnet/csharp">Microsoft&nbsp;Docs</a>.</p>

                </article>
            </section>
            <!-- !SECTION -->

<!-- TODO create C# program to format code sections-->
            <!-- SECTION Integrated Development Environment -->
            <section class="main-section" id="Integrated_Development_Environment">
                <header><h2>Integrated Development Environment</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>An Integrated Development Environment or <b>IDE</b> is an application that contains various tools that assist the developer to write, run and
                        test a program. The IDE used in this guide is
                        <a href="https://visualstudio.microsoft.com/" rel="external nofollow noopener noreferrer" target="_blank">
                        Microsoft's Visual Studio 2019</a>. While Visual Studio has many tools, the three most important are the:</p>
                    <ul>
                        <!-- project requirement -.main-section elements should contain at least 5 li items total, not each -->
                        <li>Code editor</li>
                        <li>Compiler</li>
                        <li>Debugger</li>
                    </ul>
                    <p>The code editor, like a word processor, provides many tools that help in writing code. These include indication of
                        syntax errors shown with a <u class="syntax">red wavy underline</u> that may prevent the program from running,
                        code auto completion, called IntelliSense in Visual Studio, that provides suggestions with documentation and formatting tools
                        that help keep the code consistent with coding conventions.</p>

                    <p>The compiler is used by C# to convert the code the developer writes into the language the computer requires and using
                        it is known as building the program. On completion, the compiler will report if the result was successful or
                        produce a list of errors that must be corrected before the code can be run.</p>

                    <p>The debugger aids the developer in finding errors in the code. Not every program will be written perfectly first time
                        and the errors that prevent it from functioning correctly are known as bugs. If we were just to write, compile and
                        run the program, then we would not have much to go on as to where a bug may exist. The debugger allows us to step
                        through the code one line at a time to find the problem. This is known as running the program with the debugger
                        attached.</p>

                    <p>At the time of this writing the there are three versions of Visual Studio 2019.</p>
                    <ul>
                        <li>Community</li>
                        <li>Professional</li>
                        <li>Enterprise</li>
                    </ul>
                    <p>All examples in this document can be created and run on the community version which can be downloaded and installed
                        free from the <a href="https://visualstudio.microsoft.com/" rel="external nofollow noopener noreferrer" target="_blank">
                        Visual Studio</a> web page. For the remainder of this document Visual Studio will be referred to as the IDE.</p>

                        <!-- TODO: To be removed -->
                    <p><em>Note:</em> Whilst the code editor in Visual Studio provides color coding for different elements of the code only
                        the red wavy line used to indicate syntax errors will be shown in this guide.</p>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Create a Hello World Project -->
            <section class="main-section" id="Create_a_Hello_World_Project">
                <header><h2>Create a Hello World Project</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>This guide assumes that the IDE has already been installed, updated and is set to its default settings xxx.</p>
                    <ol>
                        <li>Start the IDE then click <b>Create a new project</b>.</li>
                        <li> On the <span class="nowrap"><b>Create a new project</b></span> page in the search box at the top type
                            <span class="nowrap"><b>'console core'</b></span>.</li>
                        <li>
                            A project template titled <span class="nowrap"><b>Console Application</b></span> should appear at the top of the list. It
                            has an icon that looks like a document with C# in the top right corner. Select <span class="nowrap"><b>Console Application</b></span> then
                            choose <b>Next</b>. (Hint: if <span class="nowrap"><b>Console Application</b></span> is not at the top, click <b>Clear all</b> and search
                            again)
                        </li>
                        <li>On the <span class="nowrap"><b>Configure your new project</b></span> page type <b>'HelloWorld'</b>
                            in the <span class="nowrap"><b>Project name</b></span> box. Leave the <b>Location</b> and <span class="nowrap"><b>Solution name</b></span> as
                            filled in by the IDE and choose <b>Next</b>.</li>
                        <li>In the <span class="nowrap"><b>Additional information</b></span> page make sure <b>.NET5.0(Current)</b> is selected in the dropdown selector
                            then choose <b>Create</b></li>
                    </ol>

                    <p>The main window of the IDE opens with <i>Solution Explorer</i> open on the right and the code editor on the left.
                        The <i>Program.cs</i> code file should be open in the code editor with the code as in <b>Listing 1.1</b>. Not
                        shown here are the line numbers in the left column visible in the code editor. These are not part of the program and
                        are purely for reference.</p>

                    <p id="Listing_4_1" class="listing">Listing 4.1 &nbsp; Hello World</p>
<!-- Warning, pre and code tags require html to be formatted here which makes it look like crap in the code editor! -->
<pre><code><span class="keyword">using</span> System;

<span class="keyword">namespace</span> HelloWorld
{
    <span class="keyword">class</span> <span class="type">Program</span>
    {
        <span class="keyword">static void</span> <span class="method">Main</span>(<span class="keyword">string</span>[] <span class="args">args</span>)
        {
            <span class="type">Console</span>.<span class="method">WriteLine</span>(<span class="string">"Hello World!"</span>);
        }
    }
}
</code></pre>

                    Press <kbd>F5</kbd>.


                    <p>The console, a <i>command window</i> in Windows, opens displaying the words <b>'Hello World!'</b>. Congratulations,
                        you have now created and run your first C# program. The remainder of the text tells us our program finished but the
                        IDE has kept the console open so that we can see the result. Press any key to close the console.</p>

                    <p>By pressing <kbd>F5</kbd> the compiler built then ran the program with the debugger attached. The program starts with the
                        method called <code>static void Main(string[] args)</code>. This is known as the <b>entry point</b> and there are
                        several <a href="Code_Syntax">Code&nbsp;Syntax</a> rules it must follow.</p>

                    <p>Following <code>static void Main(string[] args)</code> is a pair of curly brackets <code>{ }</code>. The program
                        executes all the statements it finds within these. Here there is only one,
                        <code>Console.WriteLine("Hello World!");</code>. This tells the computer to write a line followed by a carriage
                        return to the <i>command window</i> and that the text to be written is located within the round brackets
                        <code>( )</code>, which in this case is <span class="nowrap"><b>'Hello World!'</b></span>. As there are no further
                        lines in our code before the closing bracket <code>}</code>, the program exits. At this point the window of a program
                        would normally close but the IDE has an option to keep console application windows open so that you can see the results.
                        This option is turned on by default.</p>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Code Syntax -->
            <section class="main-section" id="Code_Syntax">
                <header><h2>Code Syntax</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Some of the terms that will be mentioned in this section have not yet been covered and links are provided to their
                        details, so consider this as a reference to come back to as you become more familiar with them.</p>

                    <p>C# consists of text and symbols each of which tells the compiler how to convert our code into a program. The
                        <b>syntax</b> is the set of rules that governs how our code must be put together, i.e. which word or symbol goes
                        where. Together these words and symbols are combined to form statements, declarations and directives that are the
                        instructions used to create a C# program. For someone with no experience in C#, reading a list of rules and
                        specifications is likely to lead to more confusion than understanding, so the best way forward is to dive into some
                        examples and see what's going on.</p>

                    <p>The following illustrates examples both valid and invalid syntax</p>

<pre><code><span class="comment">// This is a comment</span>

<span class="comment">// using directive</span>
using System;

<span class="comment">// namespace declaration</span>
    namespace MyProgram
    {
        <span class="comment">// class declaration</span>
        public class MyClass
        {
            <span class="comment">// Constructor declaration with empty code block</span>
            MyClass() {  }

            <span class="comment">// Method declaration</span>
            static void Main(string[] args)
            {
                <span class="comment">// Single statement</span>
                Console.WriteLine("Hello World!");

                <span class="comment">// Single statements, declaring and assigning variables</span>
                int k;
                k = 0;
                int j = 0;

                <span class="comment">// while statement with code block</span>
                while (true)
                {
                    k = 1;
                    break;
                    <span class="comment">// Unreachable code</span>
                    j = 2;
                }

                <span class="comment">// These two 'if' statements are equivalent</span>
                if (a)
                {
                    x = 1;
                }

                if (a)
                    x = 1; <span class="comment"></span>// Embedded statement

                if (a)
                    <u class="syntax">var y = 1;</u> <span class="comment">// Invalid, embedded statement cannot be a declaration</span>

                <span class="comment">// The  Console.WriteLine("Hello World!"); from above rearranged</span>
                Console
                    .
                        WriteLine

                    ("Hello World")
                                    ;  <span class="comment">// The semicolon here determines the end of the statement</span>

                <span class="comment">// Invalid statement, can't put space in keyword</span>
                <u class="syntax">Con</u> <u class="syntax">sole</u>.WriteLine ("Hello World") ;

                <span class="comment">// Invalid statement, can't put line break in keyword</span>
                <u class="syntax">Con</u>
                    <u class="syntax">sole</u>.WriteLine ("Hello World") ;

                <span class="comment">// Invalid string statement, can't put line break in regular string</span>
                Console.WriteLine("<u class="syntax">Hello</u>
                                    <u class="syntax">World!</u>");

                <span class="comment">// OK string statement, can put line break in verbatim string</span>
                Console.WriteLine(@"Hello
    World!");
                <span class="comment">// This produces</span>
                <span class="comment">// Hello</span>
                <span class="comment">// World</span>
            }
        }
    }

</code></pre>
                    <p>First a quick look at the structure of the code which we'll go to into detail throughout this guide. In general
                        a program takes the form of a list of instructions with one per line, though C# allows for an instruction to
                        span multiple lines if required. C# also allows for multiple instructions to be enclosed within a pair of curly
                        brackets (<i>also known as braces</i>) called a <b>code block</b>. A code block can be empty or it can contain
                        any combination of statements, declarations, directives, comments and other code blocks. Each instruction,
                        depending on its type, must be followed by either a code block, a semicolon <code>;</code> or a carriage
                        return. The compiler ignores comments and whitespace other than as separators for words and symbols.</p>

                    <p>There are varying conventions on how to format code. The one used throughout this guide is to place code blocks
                        directly under the beginning of the instruction they belong to and indent everything within them. The IDE has
                        tools to aid with code formatting styles such as this.</p>

                    <p>A statement is the part of the code that becomes the instructions in the program that tells the computer what to
                        do. A declaration tells the compiler that a new object is to exist and become part of the program. In some cases
                        a declaration can also be a statement. A directive is an instruction for the compiler that while not directly
                        part of our program will effect how our program will be built and run.</p>

                    <p>In the example above, the first line is a <b>comment</b>. The two forward slashes <code>//</code> at the beginning
                        indicates that this is a single line comment. Details on comment syntax and its use is in
                    (<a href="#Comments_and_Task_Lists">Comments and Task Lists</a>).</p>

                    <p>The line <code>using System;</code> is a using directive and must always end with a semicolon <code>;</code>. The
                        first word <code>using</code> is a reserved word called a <i>keyword</i> in C#. Keywords are directly used by the
                        compiler as instructions. A list of all keywords can be found in
                        (<a href="#Keywords">Keywords</a>). The next word <code>System</code> is an <i>identifier</i>.
                        Identifiers are used to name types (class, interface, struct, delegate, record or enum) members, variables, or
                        namespaces.
                    </p>

                    <p>The rules for identifiers are</p>
                    <ul>
                        <li>Identifiers must begin with a letter or the <code>_</code> character</li>
                        <li>Identifiers can only contain letters, numbers or the <code>_</code> character</li>
                        <li>Identifiers shouldn't contain two or more consecutive <code>_</code> characters as these are reserved for
                            compiler generated identifiers</li>
                        <li>Identifiers are case sensitive</li>
                        <li>Identifiers can only be declared once within the same scope</li>
                        <li>A keyword can't be used as an identifier</li>
                    </ul>
                    <p>By being case sensitive it is valid for two identifiers to differ by case only, e.g.
                        <code><b>n</b>ame</code> and <code><b>N</b>ame</code> are two different identifiers.</p>

                    <p>More recently C# has introduced the discard variable which is used when the output of an expression is not required. This
                        is an advanced subject that won't be discussed in this guide but is mentioned here for completeness. The identifier for
                        the discard variable is the <code>_</code> character by itself. Unlike other variables, multiple discard variable identifiers
                        can be declared within the same scope.
                    </p>

                    <p><code>namespace MyProgram</code> is a namespace declaration. Namespaces are used to organize objects into logical
                        groups. Details of the <code>using</code> directive and namespaces are in
                        (<a href="#Namespaces_and_References">Namespaces and References</a>).</p>

                    <p>Following the namespace declaration is an opening curly bracket <code>{</code> which is the beginning of a code block
                        and its closing bracket <code>}</code> is the last line in the example. All code blocks must have an opening and
                        closing bracket. Nested within this code block is a class as declared by <code>public class MyClass</code> and its
                        associated code block. Nested within this is a constructor declaration <code>MyClass() { }</code> , a method
                        declaration <code>static void Main(string[] args)</code> and their code blocks. Details on <b>constructors</b> and
                        <b>methods</b> are in (<a href="#Classes_and_Objects">Classes and Objects</a>).</p>

                    <p>There are two main ways in which a program can be compiled for use. The first is as a class library to be used by
                        other applications and the second as an application that can be started directly. For the latter the program must
                        have an entry point method and as mentioned in
                        (<a href="Create_a_Hello_World_Project">Create a Hello World Project</a>), for C# it is the method
                        <code>static void Main(string[] args)</code> . There are several rules that it must follow but the main ones that
                        concern us are</p>
                        <ul>
                            <li>There can only be one <code>static void Main(string[] args)</code> method within the program</li>
                            <li>It must have the <code> static </code> keyword </li>
                        </ul>
                    <p><code>Console.WriteLine("Hello World!");</code> , a single line statement, is the first in the
                        <code>public void MyMethod()</code> code block. In this context, the dot <code>.</code> between <code>Console</code> and
                        <code>WriteLine ("Hello World")</code> is called the Member access operator. It allows access to a member, here a
                        method called <code>WriteLine</code> in a class called <code>Console</code>. The round brackets <code>( )</code>
                        allow parameters to be passed into the method, here the string literal <code>"Hello World!"</code>. All single line
                        statements must end with a semicolon <code>;</code> . Following are three further examples of single line
                        statements showing how variables can be declared and assigned, details of which are in
                        (<a href="#Variables,_Constants,_Types_and_Literals">Variables, Constants, Types and Literals</a>)
                     </p>

                    <p> The <code>while (true)</code> statement also called a while loop, together with the curly brackets and enclosed code
                        form a code block. No semicolon is required after the closing curly bracket. Within the code block is an assignment
                        statement, a <code>break</code> statement which causes the program to leave the while loop and another assignment
                        statement. As the the second assignment statement follows the <code>break</code> statement, it can't be executed and
                        is known as unreachable code. This won't prevent the program from being built or run but will cause a warning in the
                        IDE and should be rectified. Details on while loops can be found in
                        (<a href="#Iteration_Statements">Iteration Statements</a>).
                    </p>

                    <p>Next are two <code>if</code> statements. Details on if statements can be found in
                        (<a href="#Decision_Making_Statements">Decision Making Statements </a>). Some statements allow for
                        a single statement known as an embedded statement, such as <code>x = 1;</code> in the example, to be placed directly
                        after it without the need for curly brackets. Together they form a compound statement. In the example the two
                        <code>if</code> statements are equivalent. An embedded statement cannot be a declaration or labelled statement so
                        the following example is invalid.</p>

                    <p>As mentioned above, but for a few exceptions, the compiler ignores line breaks, tabs and whitespace, so a
                        statement does not need to be on a single line. <code>Console.WriteLine ("Hello World");</code> can be rearranged to
                        produce the following valid code example. It's the semicolon here that instructs the compiler where the end of the statement
                        is. Keywords and identifiers can't contain whitespace or line breaks so the following two examples are invalid.
                        For the remainder of this guide, <b>statement</b> will refer to a statement that ends with a semicolon, even
                        if that statement spans multiple lines.</p>


                    <p>Regular string literals such as "Hello World!" can't contain line breaks so the first string statement example is
                        invalid. Verbatim string literals, prefixed with an <code>@</code> symbol, as in the second example can contain line
                        breaks and produces the result as shown. Details on strings can be found in
                        (<a href="#Characters_and_Strings">Characters and Strings</a>)</p>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Comments and Task Lists - Section -->
            <!-- NOTE Ignore todos in this section -->
            <section class="main-section" id="Comments_and_Task_Lists">
                <header><h2>Comments and Task Lists</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Comments have several purposes, they provide information to developers as to what the code does and can also aid in
                        debugging. Comments are ignored by the compiler when building the application.</p>

                    <p>Following are some examples of comments.</p>


<pre><code>using System;

namespace CommentExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // This is a single line comment
            int i = 1; // This starts after the statement

            /*
                this is
                    a multi-line comment
                */
            // this is a better way
            // to do a multi-line comment

            // Program execution can be temporarily changed in
            // order to debug and determine where a fault may lie.
            // The following statement will be ignored when the program runs
            // suspectedError++;

            // See the description in the main text on how to comment out
            // multiple lines of code such as the following 3 lines
            Console.WriteLine("Hello World!");
            Console.WriteLine("Hello World!");
            Console.WriteLine("Hello World!");

            // TODO: This comment will be added to the tasks list
        }
    }
}
</code></pre>
                    <p>Comments can be in two forms. Single line comments start with <code>//</code> and extend to the end of the line.
                        Delimited comments start with <code>*/</code> end with <code>*/</code> and can span multiple lines. For technical
                        reasons that won't be detailed here it is preferred to use multiple single line rather than delimited comments and
                        the IDE has tools that assist with this. To comment out multiple lines, first select all the lines by placing the
                        cursor in front of the first statement, then while pressing the <kbd>Ctrl</kbd> key, drag the mouse diagonally down
                        to the end of the last statement. Then while still pressing <kbd>Ctrl</kbd> press and release <kbd>K</kbd> then
                        press <kbd>C</kbd> to comment out the selected lines. To uncomment, again with all lines selected, press
                        <kbd>Ctrl</kbd> + <kbd>K</kbd> then while still pressing <kbd>Ctrl</kbd> release <kbd>K</kbd> then
                        press <kbd>U</kbd>.</p>

                    <p>The last comment in the example <code>// TODO: A task list comment</code> is interpreted by the IDE as a task to be
                        added to the Task List. There are four predefined task tokens, <code>HACK</code>, <code>TODO</code>,
                        <code>UNDONE</code> and <code>UnresolvedMergeConflict</code>. As well custom tokens can also be added. Task tokens
                        are not case sensitive. To see the task list,  in the menu click View-&gt;Task List.</p>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Variables, Constants, Types and Literals -->
<!-- TODO rewrite variables -->
            <section class="main-section" id="Variables,_Constants,_Types_and_Literals">
                <header><h2>Variables, Constants, Types and Literals</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
<!-- TODO include this paragraph somewhere -->
                    <p>
                        Local variables
                        can be explicitly declared <code>int x = 1;</code> or implicitly declared using the <code>var</code> keyword <code>var x = 1;</code>
                        A local variables accessibility cannot be changed with an access modifier.
                    </p>

                    <p>Variables are used to represent data in memory using a symbolic name. Every variable has a <b>type</b> that
                        determines what type of data can be stored and a <b>value</b> which is the actual data. C# is a strongly typed
                        language which means the variable's type must be declared before it can be used and cannot be changed later. The
                        compiler then checks if the value stored in the variable is of the correct type and will tell us if it is wrong.
                        A <b>constant</b> is similar to a variable, except it must be assigned a value when declared and that value cannot be
                        changed. A <i>literal</i> is the representation in the code we write for the data we assign to a variable.</p>

                    <p>C# has two basic categories of variables, the <b>value type</b> and the <b>reference type</b>, into which all variables
                        are grouped. A <b>value type</b> stores its own data where as a <b>reference type</b> stores the address to where its data
                        is located. You can think of these as a house and a contact in an address book. The <b>value type</b> is like the house
                        which has an address and physically stores its own contents where as the <b>reference type</b> is like the contact that
                        only stores the address to where the house is located. A variable can only be declared once within the same scope, details
                        of which are in (<a href="#Scope">Scope</a>). C# has a number of built-in types of which each has
                        a dedicated keyword.</p>

                    <p>C# allocates memory based on the smallest size unit of an 8 bit byte. For efficiency reasons, each <b>value type</b> uses a
                        fixed number of bytes. In the case of an <b>int</b> that size is 4 bytes or 32 bits. When we use the
                        statement<code>int i = 1;</code> we are telling the compiler to reserve a 4 byte section of memory, that its address will be
                        referred to by the variable with the identifier <b>i</b> and to store the value 1 in it. But for a few exceptions, operations
                        on one value type variable cannot affect the data of another. A <b>value type</b> variable cannot be changed to refer to data
                        in another memory location.</p>

                        <p></p>

                    <p>Following is a list of the built-in <b>value types</b> in C# with the keywords shown in bold.</p>
                    <ul>
                        <li>Boolean: <b>bool</b></li>
                        <li>Signed integer: <b>sbyte, short, int, long</b></li>
                        <li>Unsigned integer: <b>byte, ushort, uint, ulong</b></li>
                        <li>Binary floating-point: <b>float, double</b></li>
                        <li>Decimal floating-point: <b>decimal</b></li>
                        <li>Unicode characters: <b>char</b></li>
                        <li>User-defined type of form enum E {...}</li>
                        <li>User-defined type of form struct S {...}</li>
                        <li>Nullable value type: Extension of all other value types with a null value</li>
                    </ul>
                    <p>A <b>reference type</b> variable can be changed to refer to a different location in memory providing it is of the same
                        type. Also, the size of a <b>reference type</b> can change. A <b>reference type</b> variable can only refer to one location at a
                        time but 2 <b>reference type</b> variables can refer to the same location. The result is that changing the contents of one will
                        affect the contents of the other.</p>

                    <p>Following is a list of the built-in <b>reference types</b> in C#.</p>
                    <ul>
                        <li><b>object</b></li>
                        <li><b>string</b></li>
                        <li><b>dynamic</b></li>
                    </ul>
                    <p>Additionally, you can declare your own <b>reference type</b> with one of the following keywords.</p>
                    <ul>
                        <li><b>class</b></li>
                        <li><b>interface</b></li>
                        <li><b>delegate</b></li>
                        <li><b>record</b></li>
                    </ul>
                    <p>Lets now expand on our Hello World project</p>

                    <p id="Listing_7_1" class="listing">Listing 7.1 &nbsp; Declaration and assignment</p>
<pre><code>using System;

    namespace VariablesExample
    {
        class Program
        {
            static void Main(string[] args)
            {
                // First declare an integer i then assign the value 1 to it
                int i;
                i = 1;

                // Both declare and assign 2.4 to double variable j
                double j = 2.4;

                // Evaluate the expression i + 3 right and assign it to k
                int k = i + 3;

                // Declare a double type constant pi
                // and assigns it the value 3.1415
                const double pi = 3.1415;

                // In the following the 'var' keyword tells the compiler to
                // select the type dependent on the operand being assigned

                // 3 is interpreted as an integer and assigned to integer variable n
                var n = 3;

                // 3.0 is interpreted as a double and assigned to double variable d
                var d = 3.0;

                // The sum of the two integers i and n is evaluated
                // and the resultant integer 4 is assigned to x
                var x = i + n;

                // The sum of the integer i and the double d is evaluated
                // and the resultant double 4.0 is assigned to y
                var y = i + d;

                // Writes the value of variables i, j and k to the console
                Console.WriteLine(i);
                Console.WriteLine(j);
                Console.WriteLine(k);

                // Writes the value of const double pi to the console
                Console.WriteLine(pi);

                // Writes the value of variables n, d, x and y to the console
                // Note - d and y will be written as 3 and 4 respectively as
                // Console.WriteLine does not include the fractional part
                // if it is zero
                Console.WriteLine(n);
                Console.WriteLine(d);
                Console.WriteLine(x);
                Console.WriteLine(y);

                // Determines the type of variables n, d, x and y
                // and writes it to the console
                Console.WriteLine(n.GetType());
                Console.WriteLine(d.GetType());
                Console.WriteLine(x.GetType());
                Console.WriteLine(y.GetType());

                // This prints the following result to the console window

                // 1
                // 2.4
                // 4
                // 3.1415
                // 3
                // 3
                // 4
                // 4
                // System.Int32
                // System.Double
                // System.Int32
                // System.Double
            }
        }
</code></pre>
                    <p>In <b>Listing 4.1</b> the first statement <code>int i;</code> declares the variable <code>i</code> to be a type of
                        integer and then in <code>i = 1;</code> the <code>=</code> operator assigns the literal value 1 to it. In
                        <code>double j = 2.4</code> both the floating point type double <code>j</code> is declared and the value 2.4 is assigned to it.
                        In <code>int k = i + 3;</code> first the operand <code>i + 3</code> is evaluated then the
                        resultant value 4 is assigned to k. In <code>const double pi = 3.1415;</code> the constant pi is declared as a type
                        double and is assigned the value 3.1415.</p>

                    <p>All the previous statements are examples of explicit declarations where we tell the editor what the variable's type
                        is before it is used. In addition, C# also allows the the variables to be implicitly declared through the use of the
                        <b>var</b> keyword which tells the compiler to determine the type of the variable to store based on the operand on the
                        right side of the <code>=</code> operator. In the statement <code>var n = 3;</code> the compiler interprets the 3 as
                        an integer and based on its size assigns <code>n</code> a type of <code>int</code> and the value 3.  In
                        <code>var d = 3.0</code> 3.0 is interpreted as a floating point number and <code>d</code> is assigned a type of
                        <code>double</code> with a value <code>3.0</code> . With <code>var x = i + n;</code> summing an int with an int results in an int
                        so x will be an int. In <code>var y = i + d;</code>summing an int with a double will result in a double so y is a double. As can be
                        seen care must be taken when using <code>var</code> for as it is easy to end up with a type that was not expected.  It should also
                        be mentioned that there is much debate as to the use of the <code>var</code> keyword which will be left for the reader to research.</p>

                    <p>The next eight <code>Console.WriteLine</code> statements write the values of i, j, k, pi, n, d, x and y to the console. Note that
                        <code>Console.WriteLine</code> truncates a number if the fractional part is zero so d and y are written as 3 and 4 respectively.
                        The four statements that
                        follow introduce the <code>GetType()</code> method. As the name suggests this method gets the type of the variable
                        supplied. <code>Console.WriteLine</code> then writes these to the console. When run, the program will write the result as shown
                        in the example to the console. For <b>n</b> and <b>x</b> this will be <code>System.Int32</code> and for <b>d</b> and <b>y</b>
                        <code>System.Double</code> where <code>System</code> is a <a href="#Namespaces_and_References">namespace</a>.
                        C# has a number of keywords for commonly used types,  in this case <b>int</b> and <b>double</b> being the keywords for System.Int32 and
                        System.Double (note the capital 'D') respectively . Both can be used in code but in general the keyword is favoured by most.
                        (See above for a list of all builtin type keywords)
                    </p>

                    <p id="Listing_7_2" class="listing">Listing 7.2 &nbsp; Declaration and assignment syntax errors</p>
<pre><code>using System;

    namespace VariablesExamples
    {
        class Program
        {
            static void Main(string[] args)
            {
                // A red wavy line under parts of the following statements
                // indicate that a syntax error is present. When the mouse
                // is placed over the line a message will pop up with
                // details of the error. The message has been included
                // as a comment above each example

                // The name 'p' does not exist in the current context
                <u class="syntax">p</u> = 1;

                int i = 1;

                // A local variable or function 'i' is already defined in this scope
                int <u class="syntax">i</u> = 2;

                // Cannot use variable 'b' before it is declared
                <u class="syntax">b</u> = 1;
                int b;

                int j;
                int k;

                // Use of unassigned local variable 'k'
                j = i + <u class="syntax">k</u>;

                // The next four statements would creates an implicit conversion
                // that would result in the fractional part of the double
                // being lost which is not allowed and so produce a syntax error

                double d = 0;

                // Cannot implicitly convert type 'double' to 'int'.
                // An explicit conversion exists (Are you missing a cast?)
                i = <u class="syntax">d</u>;

                // Cannot implicitly convert type 'double' to 'int'.
                // An explicit conversion exists (Are you missing a cast?)
                i = <u class="syntax">3.0</u>;

                d = i + 3;

                // Cannot implicitly convert type 'double' to 'int'.
                // An explicit conversion exists (Are you missing a cast?)
                b = <u class="syntax">i + d</u>;

                var x = i + d;

                // Cannot implicitly convert type 'double' to 'int'.
                // An explicit conversion exists (Are you missing a cast?)
                b = <u class="syntax">i + x</u>;

                // This is allowed as there is no loss of information
                d = i;

                const double pi = 3.1415;

                // The left-hand side of an assignment must be a variable, property or indexer
                <u class="syntax">pi</u> = 4;

                // The expression assigned to 'area' must be constant
                const double area = <u class="syntax">i * 3 * 3</u>;

                bool t = true;

                // Operator '+' cannot be applied to operands of type 'int' and 'bool'
                b = <u class="syntax">i + t</u>;
            }
        }
</code></pre>
                    <p><b>Listing 4.2</b> shows examples of the syntax errors that can occur when declaring and assigning variables and that will prevent the application
                        from being compiled. The editor identifies these errors and notifies us by placing a <u class="syntax">red wavy underline</u> under the part of the
                        statement that is causing them. By moving the the mouse over the line a message will popup detailing the error. Some errors can be quite cryptic so
                        following are a few examples and an explanation of what they mean.
                    </p>

                    <p><b>The name 'p' does not exist in the current context</b> - Before a variable can be used it must first be declared either explicitly with
                        the use of a type followed by an identifier <code>int p;</code> or implicitly by use of the <b>var</b> keyword <code>var p = 0;</code></p>

                    <p><b>A local variable or function 'i' is already defined in this scope</b> - Only one unique instance of a variable can exist within a
                        <a href="#Scope">scope</a>. As <code>int i = 1;</code> has already declared variable <b>i</b> the next statement
                        <code>int <u class="syntax">i</u> = 2;</code> is evaluated by the editor as an attempt to declare a second variable <b>i</b> resulting in the error.</p>

                    <p><b>Cannot use variable 'b' before it is declared</b> - C# executes statements in the order they appear in the code from top down. In this case
                        <code><u class="syntax">b</u> = 1;</code> has been written above <code>int b;</code>. Reversing the order of these two statements will resolve this error.
                    </p>

                    <p><b>Use of unassigned local variable 'k'</b> - C# requires variables declared within a local <a href="#Scope">scope</a>
                        to be assigned a value before they can be used. Here <code>int k;</code> declares that a variable <b>k</b> of type <b>int</b> but does not
                        assign it a value. When declaring a variable, a value can simultaneously be assigned to it through the used
                        of the <b>=</b> operator as in <code>int k = 1;</code>. Alternatively a variable can be assigned a value after being declared and before
                        being used such as adding <code>k = 1;</code> after <code>int k;</code> and before <code>j = i + <u class="syntax">k</u>;</code> C# also has has the
                        <b>default</b> keyword which allows any variable to be assigned its default value such as <code>int k = default;</code>. In this case <b>k</b>
                        would have a value of 0. Note that it is only variables on the right side of the <b>=</b> operator that need to have a value assigned so the
                        use of the <b>j</b> which is declared but not assigned a value on the left side is valid.</p>

                    <!-- TODO fix this   VVVVV -->


                        <p><b>Cannot implicitly convert type 'double' to 'int'. An explicit conversion exists (Are you missing a cast?)</b> - In all these cases an attempt
                        is being made to assign a variable of type <b>int</b> a value of type <b>double</b>. C# does not allow the assignment of a value to a variable
                        that could unwittingly result in a conversion that produces a loss of information. By assigning a floating point <b>double</b> to an <b>int</b>,
                        the fractional part after the decimal point could be lost. As can be seen from the examples it may not be obvious at first that a conversion is
                        occurring. With <code>i = <u class="syntax">d</u>;</code> an attempt is being made to assign the value in d which was declared a double to i which
                        was declared an int. With <code>i = <u class="syntax">3.0</u>;</code> the variable i which was declared as an int is being assigned the literal 3.0
                        which is interpreted as a double by the editor. With <code>b = <u class="syntax">i + d</u>;</code> as i is an int and d a double the result of
                        i + d is first evaluated by the editor to be a double so assigning this to b produces the error. With <code>b = <u class="syntax">i + x</u>;</code>
                        in the previous statement <code>var x = i + d;</code> again evaluated by the editor to be a double and is allowed to be assigned to x through the
                        use of the <b>var keyword</b>. This results in i + x also being interpreted as a double so assigning it to the int b produces the error. With
                        <code>d = i;</code> there is no possibility of information loss from an int to a double so this is allowed.</p>






                        <p>This is significant as declarations and assignments are most likely made in another part of the code or even someone else's code. With
                        <code>i = <u class="syntax">3.0</u>;</code> the double literal 3.0 is being assigned to the int i. When an int and a double are summed the result
                        will always be a double even if the double value contains With <code>k = <u class="syntax">i + j</u>;</code> the result of int i + double j.
                        Assigning an <b>int</b> value to a <b>double</b> also results in a conversion but is allowed as there is no fractional information to lose. C# has
                        a number of explicit methods that allow for a conversion that results in information loss as will be discussed shortly.</p>

                    <p><b>The left-hand side of an assignment must be a variable, property or indexer</b> - Here <b>pi</b> is a <b>constant</b> and as its value can't be
                        changed this error is the result.</p>

                    <p><b>The expression assigned to 'area' must be constant</b> - As <b>area</b> has been declared a <b>const</b> the use of the variable <b>i</b> in
                        <code>i * 3 * 3</code> produces this error.</p>

                    <p><b>Operator '+' cannot be applied to operands of type 'int' and 'bool'</b> - </p>



                    <!-- TODO fix this ^^^^^ -->










                    <p>For built in types C# has a number of different ways conversions can be achieved. A value can be cast by placing the desired
                        type in brackets followed by the variable or literal to be converted. From the examples <code>i = (int)3.9</code> converts the floating point
                        literal <b>3.9</b> is converted to an <b>int</b> with the value being truncated to 3 and assigned to <b>int i</b>.</p>





                        <p>When the program is run the values 1, 2 and 4 written to the console.</p>

                        <p id="Listing_7_3" class="listing">Listing 7.3 &nbsp; Casting and conversions</p>
<pre><code>using System;

    namespace CastingAndConversionExample
    {
        class Program
        {
            static void Main(string[] args)
            {
                // This casts the double type 3.9 to an int with a value of 3
                // A cast to an int truncates the value so 3.9 becomes 3

                int i;
                double d = 3.9;

                // This casts the double d with a value of 3.9 to int i
                // The cast truncates the value so 3.9 becomes 3
                // The value in d remains unaffected
                i = (int)d;

                Console.WriteLine(i);
                Console.WriteLine(d);

                // This converts the double d with a value of 3.9 to int i
                // Here the value in i is rounded up to 4
                i = Convert.ToInt32(d);
                Console.WriteLine(i);

                // When the value is half way between to integers the
                // value is rounded to the nearest even integer so
                // 3.5 is rounded up to 4 and 4.5 down to 4
                // Here the value in i is rounded up to 4

                i = Convert.ToInt32(3.5);
                Console.WriteLine(i);

                i = Convert.ToInt32(4.5);
                Console.WriteLine(i);

                // The math class provides a number of math functions
                // one of which is Math.Round. The default rounding here
                // is the same as for Convert.ToInt32. The result is
                // a double so a cast to an int is also required

                i = (int)Math.Round(3.5);
                Console.WriteLine(i);

                i = (int)Math.Round(4.5);
                Console.WriteLine(i);

                // Math.Round with option to always round down
                // this time 3.5 becomes 3

                i = (int)Math.Round(3.5, MidpointRounding.ToZero);
                Console.WriteLine(i);
            }
        }
    }

    // The example writes the following to the console
    // 3
    // 3.9
    // 4
    // 4
    // 4
    // 4
    // 4
    // 3
</code></pre>



                    <p>To perform an explicit conversion from between types, use the cast expression <code>(T)E</code>. If no conversion
                        exists from <b>E</b> to <b>T</b> a compile error will occur. At runtime a conversion may also not occur and
                        throw an exception.</p>
<pre><code>using System;

namespace CastingAndConversionExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // conversion from double to int results in truncation
            int number = (int)7 / 2; // number has value of 3

            // Uncommenting the following results in the error
            // cannot convert type 'int' to 'string'
            // string s = (string)number;
        }
    }
}
</code></pre>

                    <p>To summarize</p>
                    <ul>
                        <li>A variable must be declared with a type before it can be used</li>
                        <li>A local variable can only be declared once within the same scope</li>
                        <li>A local variable must be assigned a value before it can be used</li>
                        <li>A variable's type cannot be changed</li>
                        <li>A constant must be assigned a value when declared</li>
                        <li>A constant's type and value cannot be changed</li>
                    </ul>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- Completed -->
            <!-- SECTION Characters and Strings -->
            <section class="main-section" id="Characters_and_Strings">
                <header><h2>Characters and Strings</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Character literals consists of a single character in a pair of single quotes, <code>'a'</code>.</p>

                    <p>A character consists of one of:</p>
                    <ul>
                        <li>Single character</li>
                        <li>Simple escape sequence</li>
                        <li>Unicode escape sequence</li>
                        <li>Hexadecimal escape sequence</li>
                    </ul>

                    <p>String literals can be regular or verbatim and/or interpolated. Each can contain zero or more characters enclosed in a
                        pair of double quotes.</p>

                    <p>Regular string literals can contain escaped characters as per above and will be interpreted as such. They can't span
                        multiple lines so to split a statement with a long string literal across two or more lines, each part of the string on each
                        line must first be enclosed in a pair of double quotes. The <code>+</code> concatenation operator is then placed between each string to join
                        them together.</p>

                    <p>Verbatim string literals are prefixed with the verbatim identifier <code>@</code>. Any escaped character will be interpreted
                        verbatim except <code>'\"'</code> which will be interpreted as one double quote. Verbatim string literals can
                        span multiple lines. There must be no white space between the <code>@</code> character and the string.</p>

                    <p>Interpolated strings are prefixed with the interpolation identifier <code>$</code> which indicates that they may contain <i>interpolation
                        expressions</i>. These can contain variables and other special characters that instruct the compiler how to format the string at
                        <span class="nowrap">run-time</span>. Interpolation expressions are wrapped in a pair of curly braces. There must be no white space between the
                        <code>$</code> identifier and the string. To use a curly brace as a character in an interpolated string two braces <code>{{</code> or
                        <code>}}</code> must be used. Interpolation expressions cover a vast range of options information of which can be found in the
<!-- TODO add link below -->
                        Microsoft Reference Documentation</p>

                    <p>The interpolation identifier can be used in conjunction with the verbatim identifier and the order of the identifiers doesn't matter.</p>

                    <p>Following are examples of string usage.</p>

<pre><code>using System;

namespace StringExample
{
    class Program
    {
        static void Main(string[] args)
        {
            var now = DateTime.Now;
            Console.WriteLine("Regular string");
            Console.WriteLine(@"Verbatim string");
            Console.WriteLine("Regular string with an escaped \t tab");
            Console.WriteLine(@"Verbatim string with an escaped \t tab");
            Console.WriteLine("Sally said to say \"Hi\" to you");
            Console.WriteLine(@"Sally said to say ""Hi"" to you");
            Console.WriteLine("\\\\server\\folder\\file.exe");
            Console.WriteLine(@"\\server\folder\file.exe");
            // The following three lines are concatenated
            // through use of the + operator
            Console.WriteLine("Regular string " +
                "Hello " +
                        "world");
            Console.WriteLine(@"The verbatim string
        will appear as it is
                    written in code");
            int number = 123;
            Console.WriteLine($"The number is {number}");
            Console.WriteLine($"Opening brace {{ closing brace }}");
            Console.WriteLine(@$"Today is {now.DayOfWeek}
its now {now:HH:mm}");

            //// Compile error: Can't split regular string across two lines
            //var k = "Hello
            //            world";

            // Create a variable that is set to Environment.NewLine
            // and use it in an interpolated string to write a
            // blank line before the next line of text
            var nl = Environment.NewLine;
            Console.WriteLine($"{nl}This sentence is written after a blank line");
        }
    }
}

// The example writes the following to the console
// Regular string
// Verbatim string
// Regular string with an escaped   tab
// Verbatim string with an escaped \t tab
// Sally said to say "Hi" to you
// Sally said to say "Hi" to you
// \\server\folder\file.exe
// \\server\folder\file.exe
// Regular string Hello world
// The verbatim string
//         will appear as it is
//                     written in code
// The number is 123
// Opening brace { closing brace }
// Today is Saturday
// its now 19:32

// This sentence is written after a blank line
</code></pre>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Expressions and Operators -->
<!-- TODO rewrite => operator -->
            <section class="main-section" id="Expressions_and_Operators">
                <header><h2>Expressions and Operators</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>An expression is a collection of operands and operators that together can be evaluated and assigned to
                        a variable. If the evaluation is invalid the result won't be assigned and the variable's value will remain
                        unchanged. This may also result in an exception that can end the program. Following are examples of expressions.</p>
                    <h3>Expression example</h3>
                    <p>Here <b>1</b> and <b>2</b> are operands and <b>+</b> is the operator</p>
<pre><code>int i = 1 + 2;
</code></pre>
                    <p>Following is a list of expressions that demonstrates the result of the operators. The examples are shown
                        in order of arithmetic precedence. Parentheses <code>( )</code> can be used to change the order.</p>

                    <h3>Assignment operator</h3>
<pre><code><span class="comment">// assignment operator: =</span>
<span class="comment">// assigns literal value 1 to int type variable a</span>
int a = 1;
</code></pre>

                    <h3>Equality operators</h3>
<pre><code>int a = 1;
int b = 1;

<span class="comment">// equality operator: ==</span>
<span class="comment">// evaluates if two value types are equal</span>
<span class="comment">// c has value true</span>
int c = a == b;

<span class="comment">// inequality operator: !=</span>
<span class="comment">// evaluates if two value types are not equal</span>
<span class="comment">// c has value false</span>
int c = a != b;
</code></pre>

                    <h3>Comparison operators</h3>
<pre><code>int a = 1;
int b = 2;

<span class="comment">// less than operator: &lt;</span>
<span class="comment">// evaluates if the left operand is less than the right</span>
<span class="comment">// v has value true</span>
var v = a &lt; b;

<span class="comment">// greater than operator: &gt;</span>
<span class="comment">// evaluates if the left operand is greater than right</span>
<span class="comment">// v has value false</span>
var v = a &gt; b;

<span class="comment">// less than or equal to operator: &lt;=</span>
<span class="comment">// evaluates if the left operand is less than or equal to the right</span>
<span class="comment">// v has value true</span>
var v = a &lt;= b;

<span class="comment">// greater than or equal to operator: &gt;=</span>
<span class="comment">// evaluates if the left operand is greater than or equal to the right</span>
<span class="comment">// v has value false</span>
var v = a &gt;= b;
</code></pre>

                    <h3>Arithmetic operators</h3>
<pre><code>int a = 3;
int b = 3;
int c = 3;
int d = 3;

<span class="comment">// postfix increment operator: x++</span>
<span class="comment">// after assigning a's value to e adds 1 to a</span>
<span class="comment">// a has value 4, e has value 3</span>
var e = a++;

<span class="comment">// postfix decrement operator: x--</span>
<span class="comment">// after assigning b's value to f subtracts 1 from b</span>
<span class="comment">// b has value 2, f has value 3</span>
var f = b--;

<span class="comment">// prefix increment operator: ++x</span>
<span class="comment">// adds 1 to c then assigns c's value to g</span>
<span class="comment">// c has value 4, g has value 4</span>
var g = ++c;

<span class="comment">// prefix decrement operator: --x</span>
<span class="comment">// subtracts 1 from d then assigns d's value to h</span>
<span class="comment">// d has value 2, h has value 2</span>
var h = --d;

<span class="comment">// unary minus operator: -</span>
<span class="comment">// sign of -2 is changed and i has value 2</span>
var i = - -2;

<span class="comment">// multiplication operator: *</span>
<span class="comment">// multiplies 3 by 2</span>
<span class="comment">// j has value 6</span>
var j = 3 * 2;

<span class="comment">// The division operator rounds towards 0 when both operators are integers</span>

<span class="comment">// division operator: /</span>
<span class="comment">// divides 3 by 2</span>
<span class="comment">// k has value 1</span>
var k = 3 / 2;

<span class="comment">// division operator: /</span>
<span class="comment">// divides 3 by 2</span>
<span class="comment">// l has value -1</span>
var l = -3 / 2;

<span class="comment">// division operator: /</span>
<span class="comment">// divides 3 by double 2</span>
<span class="comment">// m has value 1.5</span>
var m = 3 / 2d;

<span class="comment">// remainder operator, also called the modulus operator: %</span>
<span class="comment">// returns the remainder after dividing 3 by 2</span>
<span class="comment">// n has value 1</span>
var n = 3 % 2;

<span class="comment">// addition operator: +</span>
<span class="comment">// adds 2 to 3</span>
<span class="comment">// o has value 5</span>
var o = 3 + 2;

<span class="comment">// subtraction operator: -</span>
<span class="comment">// subtracts 2 from 3</span>
<span class="comment">// p has value 1</span>
var p = 3  2;
</code></pre>

                    <h3>Boolean logic operators</h3>
<pre><code>bool a = true;
bool b = false

<span class="comment">// negation operator: !</span>
<span class="comment">// inverts the boolean value</span>
<span class="comment">// c has value false</span>
var c = !a;
<span class="comment">// c has value true</span>
var c = !b;

<span class="comment">// and operator: &</span>
<span class="comment">// returns true only if both operands are true</span>
<span class="comment">// c has value true</span>
var c = a &amp; a;
<span class="comment">// c has value false</span>
var c = a &amp; b;
<span class="comment">// c has value false</span>
var c = b &amp; a;
<span class="comment">// c has value false</span>
var c = b &amp; b;

<span class="comment">// exclusive or operator: ^</span>
<span class="comment">// returns true if only one operand is true</span>
<span class="comment">// c has value false</span>
var c = a ^ a;
<span class="comment">// c has value true</span>
var c = a ^ b;
<span class="comment">// c has value true</span>
var c = b ^ a;
<span class="comment">// c has value false</span>
var c = b ^ b;

<span class="comment">// or operator: |</span>
<span class="comment">// returns true if either operand is true</span>
<span class="comment">// c has value true</span>
var c = a | a;
<span class="comment">// c has value true</span>
var c = a | b;
<span class="comment">// c has value true</span>
var c = b | a;
<span class="comment">// c has value false</span>
var c = b | b;
</code></pre>

                    <h3>Compound assignment</h3>

<p>An expression using an operator <code>op</code> in the form <code>x op= y</code> is equivalent to
<code>x = x op y</code></p>
<pre><code>int a = 6;

<span class="comment">// compound operator: +=</span>
<span class="comment">// adds 1 to a's current value 6 and assigns it back to a</span>
<span class="comment">// a has value 7</span>
a += 1;

<span class="comment">// compound operator: -=</span>
<span class="comment">// subtracts 1 from a's current value 6 and assigns it back to a</span>
<span class="comment">// a has value 5</span>
a -= 1;

<span class="comment">// compound operator: *=</span>
<span class="comment">// multiplies a's current value 6 by 2 and assigns it back to a</span>
<span class="comment">// a has value 12</span>
a *= 2;

<span class="comment">// compound operator: /=</span>
<span class="comment">// divides a's current value 6 by 2 and assigns it back to a</span>
<span class="comment">// a has value 3</span>
a /= 2;

bool b = true;

<span class="comment">// compound operator: &=</span>
<span class="comment">// evaluates a logical 'and' with b's current value assigns it back to b</span>
<span class="comment">// b has value false</span>
b &= false;

<span class="comment">// compound operator: |=</span>
<span class="comment">// evaluates a logical 'or' with b's current value assigns it back to b</span>
<span class="comment">// b has value true</span>
b |= true;

<span class="comment">// compound operator: ^=</span>
<span class="comment">// evaluates an exclusive or with b's current value assigns it back to b</span>
<span class="comment">// b has value true</span>
b  ^= false;
</code></pre>

                    <h3>Conditional operator ?:</h3>

                    <p>The conditional operator <code>?:</code>, also known as the ternary conditional operator takes the form <code>x = predicate ? a : b</code>.
                        If the predicate is true then the expression returns <b>a</b> else it returns <b>b</b>. Both <b>a</b> and <b>b</b> must be of the same type.
                        The conditional operator can also be used as a shorthand way to replace combined <code>if</code> and
                        <code>else</code> statements. Conditional statements can be nested though doing so can make the code hard to read.</p>
<pre><code>int x = 1;

// y has value 'Yes'
var y = x == 1 ? "Yes" : "No";

// y has value 'No'
var y = x == 2 ? "Yes" : "No";
</code></pre>

                    <h3>Conditional and operator &&</h3>

                    <p>In the expression <code>x = a && b</code> <b>x</b> is true if both <b>a</b> and <b>b</b> are true otherwise
                        <b>x</b> is false. If <b>a</b> is false <b>b</b> is not evaluated. This is useful in a situation where, if
                        <b>a</b> is false evaluating <b>b</b> would produce an invalid condition that could result in an exception.</p>

<pre><code>int a = 1;
int b = 1;
int c = 0;

// x has value true
var x = a == 1 && b == 1;

// x has value false
var x = c == 1 && b == 1;

// c != 0 is false so a == b / c is not evaluated
// which prevents a divide by 0 exception
// x has value false
var x != c &gt; 0 && a == b / c;
</code></pre>

                    <h3>Conditional or operator ||</h3>

                    <p>In the expression <code>x = a || b</code>, <b>x</b> is true if either <b>a</b> or <b>b</b> are true otherwise
                        <b>x</b> is false. If <b>a</b> is true <b>b</b> is not evaluated. This is useful in a situation where, if
                        <b>a</b> is true evaluating <b>b</b> would produce an invalid condition that could result in an exception.</p>

<pre><code>int a = 1;
int b = 1;
int c = 0;

// x has value true
var x = a == 1 || b == 0;

// x has value false
var x = c == 1 || c == 1;

// c == 0 is true so a == b / c is not evaluated
// which prevents a divide by 0 exception
// x has value true
var x = c == 0 || a == b / c;
</code></pre>

                    <h3>The null-coalescing operator ??</h3>
                    <p>The null-coalescing operator <code>??</code> returns the left-hand operand if it not null otherwise it evaluates the right-hand
                    expression and returns the result</p>

<pre><code>int? a = null;
// x has value 2
var x = a ?? 2;

int? b = 1;
// y has value 1
var y = b ?? 2;
</code></pre>

                    <h3>The null-coalescing assignment operator ??=</h3>
                        <p>The null-coalescing assignment operator <code>??=</code> evaluates and assigns the-right hand expression to the left-hand variable
                        only if the variable is null</p>

<pre><code>int? a = null;
// a has value 2
a ??= 2;

int? b = 1;
// b has value 1
b ??= 2;
</code></pre>
                    <h3>The Lambda and Expression body definition operator =&gt;</h3>
                    <p>The <code>=&gt;</code> operator has two uses, as part of a <b>Lambda Expression</b> or an <b>Expression-bodied member</b> definition.</p>
<!-- TODO: => add link to anonymous function -->
                    <p>A <b>Lambda expression</b> is comprised of a set of input parameters which are then passed into the body in the form of either an expression or
                        a statement block. They are used to create an Anonymous function. In this case the <code>=&gt;</code> operator is used to separate
                        the input parameters from the body. See Anonymous function expressions.</p>
                    <p>An <b>Expression-bodied member</b> definition provides a shorthand method of writing the body of a member. In this case the <code>=&gt;</code>
                        operator is used to separate the name of the member and its body. Supported members are:</p>
                    <ul>
                        <li>Method</li>
                        <li>Read-only property</li>
                        <li>Property</li>
                        <li>Constructor</li>
                        <li>Finalizer</li>
                        <li>Indexer</li>
                    </ul>
<!-- TODO: => add link to classes -->
                    <p>Information on Expression-bodied member can be found in Classes</p>

                </article>
            </section>
            <!-- !SECTION -->

            <!-- Completed -->
            <!-- SECTION Decision Making Statements -->
            <section class="main-section" id="Decision_Making_Statements">
                <header><h2>Decision Making Statements</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>

                    <h3>if and else statements</h3>

                    <p>The if and else statements allow the program execution to branch in one of two directions based on a condition.</p>
<pre><code>using System;

namespace IfElseExample
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            if (a == 1)
            {
                Console.WriteLine("a equals 1");
            }
            else
            {
                Console.WriteLine("a does not equal 1");
            }
        }
    }
}

// The example prints the following to the console
// a equals 1
</code></pre>

                    <h3>switch statement</h3>

                    <p>The switch statement allows for program execution to branch in one of multiple directions based on a condition.</p>
<pre><code>using System;

namespace SwitchExample
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 5;
            switch (a)
            {
                case 0:
                    Console.WriteLine("none");
                    break;
                case 1:
                    Console.WriteLine("one");
                    break;
                default:
                    Console.WriteLine("many");
                    break;
            }
        }
    }
}

// The example prints the following to the console
// many
</code></pre>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- Completed -->
            <!-- SECTION Iteration Statements -->
            <section class="main-section" id="Iteration_Statements">
                <header><h2>Iteration Statements</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Iteration statements, also known as loop statements, allow the execution of a code block to be repeated until an exit
                        condition is met.</p>

                    <h3>while statement</h3>

                    <p>The while statement iterates until a condition is met. If the condition already exists, program execution won't enter
                        the <b>while</b> loop.</p>
<pre><code>using System;

namespace WhileLoopExample
{
    class Program
    {
        static void Main(string[] args)
        {
            int i = 0;
            while (i &lt; 10)
            {
                Console.Write(i);
                i++;
            }
        }
    }
}

// The example prints the following to the console
// 0123456789
</code></pre>

                    <h3>do statement</h3>

                    <p>The do statement iterates until a condition is met. At least one iteration of the <b>do</b> loop is guaranteed to
                        be executed before testing for the condition.</p>
<pre><code>using System;

namespace DoWhileLoopExample
{
    class Program
    {
        static void Main(string[] args)
        {
            string s = "";
            do
            {
                s = Console.ReadLine();
                Console.WriteLine(s);
            } while (!string.IsNullOrEmpty(s));
        }
    }
}

// Repeats text until enter is pressed after not writing text
</code></pre>

                    <h3>for statement</h3>

                    <p>The for statement iterates a set number of times based on an exit condition.</p>
<pre><code>using System;

namespace ForLoopExample
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i &lt; 10; i++)
            {
                // for loop skips current iteration if i is 5
                if (i == 5)
                    continue;
                Console.Write(i); // does not write 5
            }
        }
    }
}

// The example prints the following to the console
// 012346789
</code></pre>

                    <h3>foreach statement</h3>

                    <p>The foreach statement iterates through all members of a collection.</p>
<pre><code>using System;

namespace ForEachLoopExample
{
    class Program
    {
        static void Main(string[] args)
        {
            string s = "Hello world!";
            foreach (char c in s)
            {
                Console.Write(c + " ");
            }
        }
    }
}

// The example prints the following to the console
// H e l l o   w o r l d !
</code></pre>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Arrays -->
            <section class="main-section" id="Arrays_and_Data_Structures">
                <header><h2>Arrays and Data Structures</h2></header>
<!-- TODO remove bold text-->
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Arrays and data structures store multiple variables together in ways that allows them to be handled and manipulated more efficiently.</p>
                    <h3>array</h3>
                    <p>An array is like a box with separate compartments in which only one item called an <b>element</b> can be stored in each. They can be single-dimensional,
                        multi-dimensional
                        or jagged and all items must be of the same type. A single-dimensional array is like  one row
                        of compartments. A multidimensional array can contain rows, columns or more up to a maximum of 32 dimensions. A jagged array is like
                        storing a separate box within each compartment of the first where each one could have its own set of dimensions with different sizes. A jagged
                        array is sometimes called an array
                        of arrays. In addition to the examples shown here C# also provides the <b>Array</b> class which provides a set of methods for manipulating
                        arrays, information of which can be found in the <a href="#References">C# reference documentation</a>.</p>
                    <h3>declaring, creating and initializing arrays</h3>
                    <p>An array is immutable which means that the number of dimensions and elements or <b>Length</b> of an array must be defined when the array is
                        created and can't be changed. An array can be recreated by using the new keyword which deletes and replaces the existing array <em>and its data</em>
                        with a new one. There
                        are a number of different ways in which to create an array which can also include initializing the element values. If not initialized the default
                        value for the elements in a single-dimensional or multi-dimensional array will be 0 for numeric types and null for reference types. As a jagged
                        array stores other arrays the default type is always null. Following are examples of how arrays can be initialized.
                    </p>

<pre><code>using System;

namespace ArrayCreationExample
{
    class Program
    {
        static void Main(string[] args)
        {

            // Declare an array of type 'string' with the name stringArray
            // stringArray will be null
            string[] stringArray;

            // Declare an array of type 'int' with the name arr1
            // arr1 will be null
            int[] arr1;

            // Create a new array arr1 with 5 elements
            // Each element will have the default value 0
            arr1 = new int[5];

            // Create a new array arr1 of length 6
            // Each element will have the default value 0
            // The previous array with 5 elements and their
            // values are deleted from memory
            arr1 = new int[6];

            // Declare and create an array of length 7.
            // Each element will have the default value of 0
            int[] arr2 = new int[7];

            // Declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 3 and 4 respectively
            int[] arr3 = new int[2] { 3, 4 };

            // Another syntax to declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 8 and 9 respectively
            int[] arr4 = new[] { 8, 9 };

            // Yet another syntax to declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 10 and 11 respectively
            int[] arr5 = { 10, 11 };

            // var can be used in place of int[] in the syntax of
            // arr2, arr3 and arr4 but not arr5

            // Declare and create an array of length 7.
            // Each element will have the default value of 0
            var arr6 = new int[7];

            // Declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 3 and 4 respectively
            var arr7 = new int[2] { 3, 4 };

            // Another syntax to declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 8 and 9 respectively
            var arr8 = new[] { 8, 9 };

            // Uncommenting the following results in the error
            // Cannot initialize an implicitly-typed variable with an array initializer
            //var arr9 = { 11, 12 };

            // Declare, create and initialize an array of type 'string'
            // called with a length of 3
            string[] arr10 = new string[3] { "red", "green", "blue" };

            // Several ways to declare an empty array. The array will not be null
            // but will not be able to store any elements. An empty array has
            // very little uses and most can now replaced by newer data structure types
            int[] emptyArray1 = { };
            int[] emptyArray2 = new int[] { };
            int[] emptyArray3 = new int[0];
            int[] emptyArray4 = Array.Empty &lt; int &gt; ();

            // Declare a multi-dimensional array with 2 dimensions
            int[,] arr11;

            // Create a 2 dimensional array of length 4 in the first
            // and length 2 in the second. You can think of this as having
            // 4 rows and 2 columns
            arr11 = new int[4, 2];

            // Create and initialize a 2 dimensional array
            arr11 = new int[4, 2] { { 1, 2 }, { 3, 4 },
                                    { 5, 6 }, { 7, 8 } };

            // Create and initialize a 2 dimensional array
            // Here the lengths are inferred from
            // from the block inside the curly brackets
            arr11 = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };

            // Declare, create and initialize a 2 dimensional string array
            string[,] arr12 = new string[3, 2] { { "red", "cyan" },
                                            { "green", "magenta" },
                                            { "blue", "yellow" } };

            // Declare, create and initialize a 3 dimensional 'int' array
            // This will create an array with dimensions [2, 2, 3]
            int[,,] arr13 = new int[,,] { { { 1, 2, 3 }, { 4, 5, 6 } },
                                    { { 7, 8, 9 }, { 10, 11, 12 } } };

            // Declares and creates a jagged array. The first array
            // is a single-dimensional array with 3 elements
            // each of which is a 2 dimensional array
            int[][,] arr14 = new int[3][,];

            // Each single-dimensional element of arr13 must also
            // be created before it can be used
            arr14[0] = new int[1, 2];
            arr14[1] = new int[2, 3];
            arr14[2] = new int[4, 5];

            // An array within a jagged array can also be initialized
            arr14[1] = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } };

            // Yet another syntax for initializing a jagged array
            int[][] arr16 =
            {
                new int[] { 1, 2, 3, 4 },
                new int[] { 5, 6, 7 },
                new int[] { 8, 9 }
            };
        }
    }
}
</code></pre>

                    <h3>accessing arrays</h3>
                    <p>Arrays are normally zero index based so the elements in a dimension of length n will be accessed by index values of 0 through n-1.
                        Whilst it is possible to create an array that is not zero based its use is very uncommon and is beyond the scope of this document.</p>

<pre><code>using System;

namespace ArrayAccessExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // Each element in array is accessed using an 'int' type
            // index which is zero based. For an array of length 3
            // the index values for the elements are 0, 1 and 2.
            // To obtain and element specify the index  within
            // square brackets
            string[] colors = { "red", "green", "blue" };
            Console.WriteLine(colors[0]);
            Console.WriteLine(colors[1]);
            Console.WriteLine(colors[2]);
            Console.WriteLine();

            // To assign a value to an element use the assignment operator '='
            colors[0] = "cyan";
            colors[1] = "magenta";
            colors[2] = "yellow";

            // The total number of elements of an array can be found by using
            // the Length property 'array.Length'.
            Console.WriteLine($"colors has {colors.Length} elements");
            Console.WriteLine();

            // Attempting to access an array with an index value less than 0
            // or more than the length - 1 will result in an
            // IndexOutOfRange exception and the program will stop
            // Uncomment the following line will demonstrate this error
            // Console.WriteLine(colors[3]);

            // As the array indexes
            // are 0 based the elements can be accessed using a 'for' loop
            for (int i = 0; i &lt; colors.Length; i++)
            {
                Console.WriteLine(colors[i]);
            }
            Console.WriteLine();

            // Additionally the elements can be accessed using a 'foreach' loop
            foreach (var color in colors)
            {
                Console.WriteLine(color);
            }
            Console.WriteLine();

            // Accessing the elements within a multi-dimensional array
            // is similar to a single-dimensional array using one
            // 'int' type index for each dimension
            int[,] numbers = new int[3, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 } };
            Console.WriteLine(numbers[0, 0]);
            Console.WriteLine(numbers[0, 1]);
            Console.WriteLine(numbers[1, 0]);
            Console.WriteLine(numbers[1, 1]);
            Console.WriteLine(numbers[2, 0]);
            Console.WriteLine(numbers[2, 1]);
            Console.WriteLine();

            // Assigning values to elements in a multi-dimensional
            // is also similar to a single-dimensional array using one
            // 'int' type index for each dimension
            numbers[0, 0] = 6;
            numbers[0, 1] = 5;
            numbers[1, 0] = 4;
            numbers[1, 1] = 3;
            numbers[2, 0] = 2;
            numbers[2, 1] = 1;

            // Looping through a multi-dimensional array can be
            // done using nested for loops, one for each dimension
            // To obtain the length for a given dimension the
            // GetLength() is used 'array.GetLength(dimensionIndex)'
            for (int i = 0; i &lt; numbers.GetLength(0); i++)
            {
                for (int j = 0; j &lt; numbers.GetLength(1); j++)
                {
                    Console.WriteLine(numbers[i, j]);
                }
            }
            Console.WriteLine();

            // The foreach loop can also be used for multi-dimensional arrays
            // however nested for loops allow you traverse an array in any
            // order you require
            foreach (var number in numbers)
            {
                Console.WriteLine(number);
            }
            Console.WriteLine();

            // The number of dimensions of an array
            // can be found using the Rank property 'array.Rank'.
            Console.WriteLine($"numbers has {numbers.Rank} dimensions");
            Console.WriteLine();
            var total = 1;
            for (int i = 0; i &lt; numbers.Rank; i++)
            {
                Console.WriteLine($"numbers[{i}] has {numbers.GetLength(i)} elements");
                total *= numbers.GetLength(i);
            }
            Console.WriteLine($"Numbers has a total {total} of elements which is the same as Numbers.Length: {numbers.Length}");
            Console.WriteLine();

            // Accessing a jagged array is similar to a multi-dimensional
            // This prints 7 to the console which is the third element [2]
            // of the second array [1] of jaggedArray
            int[][] jaggedArray =
            {
                new int[] {1, 2, 3, 4},
                new int[] {5, 6, 7},
                new int[] {8, 9}
            };
            Console.WriteLine($"{jaggedArray[1][2]}");
            Console.WriteLine();

            // Assigning values is also similar to multi-dimensional arrays
            // This assigns 42 to the third element [2] of the second array [1]
            // then prints it to the console
            jaggedArray[1][2] = 42;
            Console.WriteLine($"{jaggedArray[1][2]}");
            Console.WriteLine();

            // This demonstrates looping though a jagged array with for loops
            for (int i = 0; i &lt; jaggedArray.Length; i++)
            {
                Console.Write("The values in array{i} are: ");
                for (int j = 0; j &lt; jaggedArray[i].Length; j++)
                {
                    Console.Write($" {jaggedArray[i][j]}");
                }
                Console.WriteLine();
            }
            Console.WriteLine();

            // Looping through a jagged array with a foreach loop is a bit more
            // complicated as a first loop is required to get the arrays and a
            // second to get the actual values
            foreach (var arr in jaggedArray)
            {
                foreach (var i in arr)
                {
                    Console.WriteLine(i.ToString());
                }
            }
            Console.WriteLine();

            // This demonstrates the types that are stored in a jagged array
            // The first line prints Int32[] where the brackets indicate
            // that it is an array of type 'int' whereas the second prints
            // Int32 without brackets indicating the actual type stored in
            // each array is an 'int'
            Console.WriteLine(jaggedArray[0].GetType().Name);
            Console.WriteLine(jaggedArray[0][0].GetType().Name);
        }
    }
}

// The example prints the following to the console
// red
// green
// blue

// colors has 3 elements

// cyan
// magenta
// yellow

// cyan
// magenta
// yellow

// 1
// 2
// 3
// 4
// 5
// 6

// 6
// 5
// 4
// 3
// 2
// 1

// 6
// 5
// 4
// 3
// 2
// 1

// numbers has 2 dimensions

// numbers[0] has 3 elements
// numbers[1] has 2 elements
// Numbers has a total 6 of elements which is the same as Numbers.Length: 6

// 7

// 42

// The values in array{i} are: 1 2 3 4
// The values in array{i} are: 5 6 42
// The values in array{i} are: 8 9

// 1
// 2
// 3
// 4
// 5
// 6
// 42
// 8
// 9

// Int32[]
// Int32
</code></pre>

                    <h3>collections</h3>
                    <p>.NET provides a number of data structures grouped under the category of collections. They provide common functionality
                        such as to add, remove and modify either individual elements or a range of elements.
                    </p>
                    <p>There are two main types of collections, generic an non-generic. Generic collections take in a type parameter making them
                        type safe at compile time which allows IntelliSense to indicate syntax errors. Non-generic collections store
                        items as type <b>object</b> which requires casting when accessing the data within them. Because of this non-generic collections are
                        less commonly used today and are mostly found in legacy code.</p>
                    <p>Following is a list of some common collection types but only examples of <b>List&lt;T&gt;</b> and <b>Dictionary&lt;TKey, TValue&gt;</b>
                        will be discussed in this article.</p>
                    <ul>
                        <li><b>List&lt;T&gt;</b> - A collection of items stored by index</li>
                        <li><b>Dictionary&lt;TKey, TValue&gt;</b> - Used to store items as key/value pairs</li>
                        <li><b>Queue&lt;T&gt;</b> - Items are accessed first in first out (FIFO)</li>
                        <li><b>Stack&lt;T&gt;</b> - Items are accessed last in first out (LIFO)</li>
                        <li><b>LinkedList&lt;T&gt;</b> - Items are accessed sequentially</li>
                        <li><b>ObservableCollection&lt;T&gt;</b> - Provides notification through events when items are added or removed</li>
                        <li><b>SortedList&lt;TKey, TValue&gt;</b> - A sorted collection</li>
                        <li><b>HashSet&lt;T&gt;</b> - A set for mathematical functions</li>
                        <li><b>SortedSet&lt;T&gt;</b> - A sorted set for mathematical functions</li>
                    </ul>

                    <h3>List&lt;T&gt;</h3>
                    <p>A <b>List&lt;T&gt;</b> is a strongly typed generic collection of objects accessed by an <b>int</b> type <b>index</b>. Unlike an array, a list does
                        not have a fixed size and as such does not have to be defined when it is created. It provides a number of useful methods for manipulating its data
                        such as add, remove, sort, find and clear.</p>

<!-- TODO add link to anonymous functions -->

                    <p>Note: The Find method uses an anonymous expression details of which are in Anonymous expression functions</p>

<pre><code>using System;
using System.Collections.Generic;

namespace ListExample
{
    class Program
    {
        static void Main(string[] args)
        {
            var nl = Environment.NewLine;

            // Create a list of strings
            List&lt;string&gt; animals = new();

            // Add items to the list
            animals.Add("dog");
            animals.Add("cat");
            animals.Add("lizard");
            animals.Add("ball");
            animals.Add("emu");
            animals.Add("emu");
            animals.Add("boat");
            animals.Add("salmon");

            // Use a foreach loop to print the items to the console
            Console.WriteLine("A list of animals");
            foreach (var item in animals) { Console.Write(item + " "); }

            // The 'Find' method returns the first item that
            // matches the conditions specified by the
            // predicate in the anonymous expression.
            // (See Anonymous function expressions)
            // If not the default value for type T is returned.
            // 'Remove' removes the specified item
            // This searches for 'boat' and if found removes it
            // from the list
            var notAnAnimal = animals.Find(item =&gt; item == "boat");
            if (notAnAnimal != null)
                animals.Remove(notAnAnimal);
            Console.WriteLine($"{nl}{nl}Find 'boat' then remove it");
            foreach (var item in animals) { Console.Write(item + " "); }

            // Create a variable to store the index value
            int index = 0;

            // 'Contains' returns true is the list contains the item
            // 'IndexOf' returns the index of an item if found
            // or -1 if not. This first confirms the list has 'lizard'
            // then changes 'lizard' to 'duck'
            if (animals.Contains("lizard"))
            {
                index = animals.IndexOf("lizard");
                animals[index] = "duck";
            }
            Console.WriteLine($"{nl}{nl}If list has 'lizard' replace it with 'duck'");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Insert' inserts an item at a specific index
            // This inserts 'shark' at the current index of 'duck'
            // as found from the previous example. All items after
            // and including 'duck' are moved after 'shark'
            animals.Insert(index, "shark");
            Console.WriteLine($"{nl}{nl}Insert 'shark' before 'duck'");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'RemoveAt' removes an at a specified index
            // The following removes 'ball'
            index = animals.IndexOf("ball");
            if (index != 0)
                animals.RemoveAt(index);
            Console.WriteLine($"{nl}{nl}Remove 'ball'");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Remove' removes the first occurrence of a specific item
            // It returns false if the removal was unsuccessful or the
            // item wasn't found. The following removes the first 'emu'
            // then prints the updated list to the console
            var removed = animals.Remove("emu") ? "'emu' was removed" : "'emu' was NOT removed";
            Console.WriteLine($"{nl}{nl}{removed}");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Sort' sorts the list based on the comparer argument
            // passed in. If none is supplied then the default
            // comparer is used. The following alphabetically sorts the list
            animals.Sort();
            Console.WriteLine($"{nl}{nl}Sort the list");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Reverse' reverses the order of the list
            animals.Reverse();
            Console.WriteLine($"{nl}{nl}The list has been reversed");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Clear' removes all items from the list
            // The 'Count' property is the number of items the list.
            animals.Clear();
            Console.WriteLine($"{nl}{nl}Clear the list");
            Console.WriteLine($"There are {animals.Count} items in the list");
            Console.WriteLine();
        }
    }
}

// The example writes the following to the console
// dog cat lizard ball emu emu salmon

// If list has 'lizard' replace it with 'duck'
// dog cat duck ball emu emu salmon

// Insert 'shark' before 'duck'
// dog cat shark duck ball emu emu salmon

// Remove 'ball'
// dog cat shark duck emu emu salmon

// 'emu' was removed
// dog cat shark duck emu salmon

// Sort the list
// cat dog duck emu salmon shark

// The list has been reversed
// shark salmon emu duck dog cat

// Clear the list
// There are 0 items in the list
</code></pre>

                    <h3>Dictionary&lt;TKey, TValue&gt;</h3>
                    <p>A <b>Dictionary&lt;TKey, TValue&gt;</b> is a strongly typed generic collection of <b>KeyValuePair&lt;TKey, TValue&gt;</b> accessed by a <b>key</b>
                        index.  Like a
                        List, a Dictionary does not have a fixed size and as such does not have to be defined when it is created. Methods include add,
                        remove, contains, clear.</p>

<pre><code>using System;
using System.Collections.Generic;

namespace DictionaryExample
{
    class Program
    {
        static void Main(string[] args)
        {
            var nl = Environment.NewLine;

            // Create a list of strings
            Dictionary&lt;string, int&gt; fruit = new();

            // Add some items
            fruit.Add("Oranges", 6);
            fruit.Add("Pears", 4);
            fruit.Add("Apples", 8);
            fruit.Add("Bananas", 7);
            fruit.Add("Lemons", 3);
            fruit.Add("Peaches", 6);
            fruit.Add("Plums", 6);

            // 'Count' returns the number of items in a Dictionary
            Console.WriteLine($"There are {fruit.Count} fruit items{nl}");

            // To use a Dictionary in a foreach loop use
            // KeyValuePair&lt;TKey, TValue&gt;. The types must be the same
            // as that used in the declaration of the dictionary
            foreach (KeyValuePair&lt;string, int&gt; item in fruit)
                Console.Write($"{item.Key} : {item.Value}{nl}");

            // Each item must have a unique 'key'
            // Uncommenting the following results in
            // System.ArgumentException: System.ArgumentException:
            // 'An item with the same key has already been added.
            // Key: Plums' when the program is run
            //fruit.Add("Plums", 3);

            // 'TryAdd' unlike 'Add' won't result in an
            // exception but will return false if the
            // item could not be added.
            var added = fruit.TryAdd("Plums", 3) ?
                "'Another Plums entry' was added" :
                "'Another Plums entry' could NOT be added";
            Console.WriteLine($"{nl}{nl}{added}");

            // 'Keys' returns a 'KeyCollection' of all the keys
            // in the Dictionary and will have the same type that
            // was used when declaring it
            var keys = fruit.Keys;
            Console.WriteLine($"{nl}We have the following fruit");
            foreach (var key in keys)
                Console.Write(key + " ");

            // 'Values' returns a 'ValueCollection' of all the values
            // in the Dictionary and will have the same type that
            // was used when declaring it
            var values = fruit.Values;

            int total = 0;
            foreach (var value in values)
                total += value;
            Console.WriteLine($"{nl}{nl}There is a total of {total} fruit");

            // Individual items can be accessed using the 'Key' index
            Console.WriteLine($"{nl}There are {fruit["Pears"]} 'Pears'");
            fruit["Pears"] = 3;
            Console.WriteLine($"{nl}There are now {fruit["Pears"]} 'Pears'");

            // The 'Key' index must exist to access an item. Uncommenting the
            // following will result in the exception
            // System.Collections.Generic.KeyNotFoundException:
            // 'The given key 'Mangoes' was not present in the dictionary.'
            // var mangoes = fruit["Mangoes"];

            // 'TryAdd' unlike accessing a Dictionary with the 'Key' index
            // won't result in an exception but will return false if the
            // Key does not exist. If found result will be the value for
            // the item. If not found result will be the type's default value
            if (fruit.TryGetValue("Mangoes", out var result))
            {
                Console.WriteLine($"{nl}There are {result} 'Mangoes'");
            }
            else
            {
                Console.WriteLine($"{nl}There is no 'Mangoes' item in 'fruit'");
            }

            // 'ContainsKey' returns true if the Dictionary contains
            // the specified 'Key'
            if (fruit.ContainsKey("Bananas"))
            {
                Console.WriteLine($"{nl}There are {fruit["Bananas"]} 'Bananas'");
            }
            else
            {
                Console.WriteLine($"{nl}There are no 'Bananas' item in fruit");
            }

            // 'ContainsValue' returns true if the Dictionary contains
            // the specified 'Value'
            if (fruit.ContainsValue(6))
            {
                Console.WriteLine($"{nl}There is at least 1 item with the value '6'");
            }
            else
            {
                Console.WriteLine($"{nl}There are no items with the value '6'");
            }

            // 'Remove' removes the specified 'Key' from the Dictionary
            fruit.Remove("Oranges");
            if (fruit.ContainsKey("Oranges"))
            {
                Console.WriteLine($"{nl}There are {fruit["Oranges"]} 'Oranges'");
            }
            else
            {
                Console.WriteLine($"{nl}There is no longer an 'Oranges' item in fruit");
            }

            // 'Clear' removes all KeyValuePair&lt;TKey, TValue&gt; items from
            // the Dictionary
            fruit.Clear();
            Console.WriteLine($"{nl}There are {fruit.Count} fruit items{nl}");
        }
    }
}


// The example writes the following to the console
// There are 7 fruit items

// Oranges : 6
// Pears: 4
// Apples: 8
// Bananas: 7
// Lemons: 3
// Peaches: 6
// Plums: 6


// 'Another Plums entry' could NOT be added

// We have the following fruit
// Oranges Pears Apples Bananas Lemons Peaches Plums

// There is a total of 40 fruit

// There are 4 'Pears'

// There are now 3 'Pears'

// There is no 'Mangoes' item in 'fruit'

// There are 7 'Bananas'

// There is at least 1 item with the value '6'

// There is no longer an 'Oranges' item in fruit

// There are 0 fruit items
</code></pre>

                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Enumerators -->
            <section class="main-section" id="Enumerators">
                <header><h2>Enumerators</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>The keyword <code>enum</code> is used to declare an enumerator which provides a list of named constants. The code
                        editor allows us to use these names to assign the underlying constant values to variables. We can define the type
                        and value of each constant or allow the editor to assign them for us. The default type for the value is an integer
                        and the list is zero based. The following example shows how to declare and use an enumerator using the defaults.</p>
<pre><code>using System;

namespace EnumExample
{
    class Program
    {
        enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat }

        // Underlying month type is declared as long
        enum Month : long { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }

        static void Main(string[] args)
        {
            var day = Day.Tue;
            var dayType = day.GetType();
            var underlyingDayType = Enum.GetUnderlyingType(dayType);
            Console.WriteLine($"Day is {day}, value is {(int)day}," +
                $" Type is {dayType.Name}, underlying type is {underlyingDayType}");
            var month = Month.Nov;
            var monthType = month.GetType();
            var underlyingMonthType = Enum.GetUnderlyingType(monthType);
            Console.WriteLine($"Month is {month}, value is {(long)month}," +
                $" Type is {monthType.Name}, underlying type is {underlyingMonthType}");

        }
    }
}

// The example prints the following to the console
// Day is Tue, value is 2, Type is Day, underlying type is System.Int32
// Month is Nov, value is 10, Type is Month, underlying type is System.Int64
</code></pre>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Classes -->
            <section class="main-section" id="Classes,_Structs,_Interfaces_and_Inheritance">
                <header><h2>Classes, Structs, Interfaces and Inheritance</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>C# is an Object-oriented programming language (OOP) and objects can be created using reference types such as classes, structures (struct),
                        interfaces and records. Within a C# project these objects can be combined with other resources such as media and text files which are then
                        compiled to create an <b>assembly</b> in the form of either an executable (.exe) or library (.dll) file.</p>

                    <h3>Classes</h3>

                    <p>The main way a C# developer will create an object is through the use of classes. A class is a reference type that is defined using the
                        <code>class</code> keyword and can contain fields, properties, methods, indexers, events, constructors, finalizers and other nested types.
                        Collectively these are called <b>class members</b>. Accessibility to classes from code outside of the assembly and to class members both from
                        outside the assembly and from other objects within the assembly is controlled through the use of access modifier keywords. When no access modifier
                        is applied the default access for a class is <code>internal</code> which means it can only be accessed from within the assembly. For class members
                        the default access is <code>private</code> and only code within the same class can access them.</p>

                    <h4>Fields</h4>

                    <p>A field is a variable or a constant used to store data about an object. A field can be accessed from anywhere within the class.
                        A field's access is normally left as private and access to it is achieved through the use of a property or method.
                        This has the advantage of allowing for data validation and performing other tasks before changing its value. A variable field can also
                        be made readonly through the use of the <code>readonly</code> keyword and can then only be set from within the class
                        constructor when the object is created. A constant field must have its value set when it is declared.</p>

                    <h4>Properties</h4>

                    <p>A property is a way of allowing code external to a class to access its fields. It can use the <code>set</code> keyword to define a
                        <b>setter</b> for writing a value to a field and the <code>get</code> keyword for defining a <b>getter</b> for reading the value from a field.
                        A property can be made read/write by using both <code>set</code> and <code>get</code>, readonly by only using <code>get</code> and write
                        only by only using <code>set</code> though the latter is an extremely rare situation. With <code>set</code> the <code>value</code>
                        keyword is used to hold the value passed in. An alternative to <code>set</code> is <code>init</code> which can only be called by the
                        constructor or an object-initializer. Collectively <code>set</code>, <code>init</code> and <code>get</code> are called <b>accessors</b>. As
                        with all class members, the default access level for a property is private but as the most common use is to access them from outside a class
                        they will usually have an access modifier applied.</p>

                    <p> The default access for accessors is that of the property but can be changed changed through the use of access modifiers provided that</p>
                        <ul>
                            <li>the property is read/write</li>
                            <li>only one of the accessors has the access modifier applied</li>
                            <li>the access modifier is more restrictive than the property container</li>
                        </ul>

                    <p>A property can take two basic forms, manually-implemented and auto-implemented. With a manually-implemented property a separate field known
                        as a backing field must be created. Each accessor must have its own code block with appropriate expressions to read and write to and from
                        the backing field. This has the advantage allowing extra logic to perform other tasks such as validation within the property. With an
                        auto-implemented property accessors are defined without an implementation code block and no backing field is required. During runtime the
                        compiler creates a private backing field that can only be accessed through the property. An advantage of an auto-implemented is that it can
                        be initialized through the declaration like so <code>public int MyProperty { get; set; } = 1;</code>. For a read/write property either both
                        accessors must be manually-implemented or auto-implemented.
                    </p>

                    <h4>Method</h4>

                    <p>A method provides a way of doing things. This could be reading a file, calculating a value, writing to the screen, etc.
                        A method can receive and return values. When not returning a value the return type must use the void keyword.
                        Methods can be overloaded by defining a different number of, or different types of parameters to be passed in. When a method
                        has overloads <b>IntelliSense</b> will show there are more than one version of the method to choose from.</p>

                    <h4>Events</h4>

                    <p>An event is a way for the class to communicate with other objects or other parts within itself that the state of the class instance
                        has changed. The event
                        defines which type of method known as an event handler must be used respond to the event. The event usually passes the
                        object that created the event and an EventArgs that can contain additional information about the event to the event handler. The return
                        type for an event handler is almost always void so if information is to be passed back from the event handler, variables can be included
                        in the EventArgs that can be changed within the event handler.</p>

                    <h4>Indexers</h4>

                    <p>An indexer allows an object to be indexed like an array. It is similar to a property but also takes an index value to
                        set or get a specific instance. In place of an identifier the <code>this</code> keyword is used to define an indexer. The same rules as
                        as those for read/write and accessibility of properties also apply to indexers.</p>

                    <h4>Constructors</h4>

                    <p>A constructor is called when an instance of the class is created and is used to initialize the state of its members.
                        Its syntax is similar to a method but it does not return a value so no return type is to be specified. The name of the the
                        constructor is the same as that of the class. As with methods constructors can be overloaded. If a constructor is not specified
                        the compiler will create a parameterless constructor with an empty code block at runtime with which to create the instance. To create an
                        instance of a class the <code>new</code> keyword is used</p>

                    <h4>Finalizers</h4>

                    <p>A finalizer is used to perform any cleanup of the class when it is no longer in use. The compiler adds a default finalizer to
                        each instance of a class that is created so it would be a rare requirement to add one ourselves.</p>

                    <p>The following example defines a Square class with fields, properties, methods and events. The Program class creates 3
                        instances of the Square class and adds the Square_AreaChanged event handler to the Square_AreaChanged event of both the
                        square2 and square3 instances. After writing the initial area values to the console it then changes the Width property
                        directly on the square2 instance and Height on square3 through the SetHeight method. This triggers the AreaChanged
                        event in each which then calls the Square_AreaChanged event handler which in turn writes the updated values to the console.
                    </p>

<pre><code>using System;

namespace ClassExample
{
    class Square
    {
        // Declare 2 fields a constant to initialize the width and a
        // variable to use as a backing field for the Width property
        const int DEFAULT_VALUE = 1;
        int mWidth;

        // A constructor that sets the Height
        // and Width to the default value internally
        // The name and height must be set
        public Square(string name)
        {
            Name = name;
            Height = DEFAULT_VALUE;
            Width = DEFAULT_VALUE;
        }

        // A constructor that allows the Width to optionally be set
        // if a value is not provided it is set to the default value
        // The name and height must be set
        public Square(string name, int height, int width = DEFAULT_VALUE)
        {
            Name = name;
            Height = height;
            Width = width;
        }

        // An event that fires when there are changes
        // This uses the Expression-bodied member syntax
        public event EventHandler AreaChanged = (sender, e) =&gt; { };

        // The name property has a private setter
        // It can only be set from within the class
        // This is an Auto Property as the compiler
        // automatically creates a hidden private
        // backing field
        public string Name { get; private set; }

        // The Height property can be set both from inside
        // and from outside the class but does not trigger
        // the AreaChanged event. This is also an
        // Auto Property
        public int Height { get; set; }

        // The Width property can be set both from inside
        // and from outside the class and triggers
        // the AreaChanged event by calling the
        // OnAreaChanged method
        public int Width
        {
            get =&gt; mWidth;
            set
            {
                if (mWidth == value)
                    return;
                mWidth = value;
                OnAreaChanged();
            }
        }

        // The SetHeight method changes the height and
        // triggers the area changed event by calling the
        // OnAreaChanged method. This method's return
        // type is set to void which means that it does
        // not return a value. It accepts a parameter
        // of type int called height
        public void SetHeight(int height)
        {
            Height = height;
            OnAreaChanged();
        }

        // The GetArea method calculates the area from the
        // Height and Width values and returns the result
        // as an int
        public int GetArea()
        {
            return Height * Width;
        }

        // This is the expression-bodied member syntax for the GetArea method
        // and performs the same function. It is useful when only one line
        // of code is to be entered within the curly braces
        public int GetArea2() =&gt; Height * Width;

        // An overloaded GetArea2 method. When selecting this method
        // IntelliSense will show there are two versions of this
        // method to choose from
        public int GetArea2(int doesNothing) =&gt; Height * Width;

        // The OnAreaChanged method first checks if an event handler exists
        // and if so calls the event through the invoke command passing on
        // the arguments in this case this class instance by using the this
        // keyword and an empty EventArgs
        // This method also uses Expression-bodied member syntax
        private void OnAreaChanged() =&gt; AreaChanged?.Invoke(this, EventArgs.Empty);
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Three squares are created using the new keyword and alternative
            // constructors
            Square square1 = new("Square 1");
            Square square2 = new("Square 2", 5);
            Square square3 = new("Square 3", 5, 10);
            // The Square_AreaChanged event handler is added to both the
            // square2 and square3 AreaChanged events
            square2.AreaChanged += Square_AreaChanged;
            square3.AreaChanged += Square_AreaChanged;
            // The initial area values are written to the console
            Console.WriteLine($"{square1.Name} area is {square1.GetArea().ToString()}");
            Console.WriteLine($"{square2.Name} area is {square2.GetArea().ToString()}");
            Console.WriteLine($"{square3.Name} area is {square3.GetArea().ToString()}");
            // Changing the width triggers the square2 AreaChanged event
            square2.Width = 3;
            // Changing the height triggers the square3 AreaChanged event
            square3.SetHeight(10);

        }

        // This is the Square_AreaChanged event handler which has been added to both the
        // square1 and square2 AreaChanged events
        private static void Square_AreaChanged(object sender, EventArgs e)
        {
            var square = sender as Square;
            Console.WriteLine($"{square.Name} area changed and is now {square.GetArea().ToString()}");
        }
    }
}

// The example writes the following to the console
// Square 1 area is 1
// Square 2 area is 5
// Square 3 area is 50
// Square 2 area changed and is now 15
// Square 3 area changed and is now 100

</code></pre>

<p>The following example defines a string collection which uses an indexer to index instances of itself. The Program class
    creates a new StringCollection instance, assigns the string "Hello World" to the instance at index 0 in the collection, then
    retrieves the same and finally writes its value to the console.
</p>

<pre><code>using System;

namespace IndexExample
{
    class StringCollection
    {
        private string[] strings = new string[10];

        public string this[int i]
        {
            get =&gt; strings[i];
            set =&gt; strings[i] = value;
        }
    }

    class Program
    {
        static void Main()
        {
            StringCollection stringCollection = new();
            stringCollection[0] = "Hello world";
            Console.WriteLine(stringCollection[0]);
        }
    }
}
</code></pre>

                    <h3>Static classes and static members</h3>

                    <p>So far the majority of the examples we have looked at involve creating an instance of a class by using the <code>new</code> keyword. This
                        allows for multiple instances of a class to be created each with its own initialized state which can be set either by arguments passed in
                        through an instance constructor or with an object-initializer. Creating an instance of a class in this way is known as instantiation.</p>

                    <p>In addition we can make a class static by applying the <code>static</code> keyword to the class definition. Here the class cannot be instantiated.
                        Instead it is
                        created automatically during runtime and only one instance of it exists. As a static class is not assigned an identifier, to access its
                        members the class name is used instead. For a class called <code>MyClass</code> with a method called <code>MyMethod</code> to access the method
                        you would use <code>MyClass.MyMethod</code>.</p>

                    <p>Class members can also be either instance types or made static through use of the <code>static</code> keyword. Note that members within a static
                        class must always be be static whilst members in an instance class can be either instance or static. As with a static class static
                        members are created
                        automatically during runtime and are accessed using the class name.  To initialize a static field a static constructor
                        must be used which cannot have values passed in. Within a class, static
                        members can only access other static members.</p>

                    <p>A static method can be useful when it is to perform simple functions that don't have to store
                        or retrieve data from within the class, for example squaring a number. As the method is created as soon as the program is
                        running it can be shared from multiple locations throughout the programs code without the necessity to create a new class instance every time.
                        The .NET <code>System.Math</code> class which contains numerous small math functions is an example of a static class.</p>

                    <p>It is important to note that whereas each instance of an object carries has its own copy of an instance member static members are shared by all
                        code in an assembly. If a static filed or property's value is changed in one instance of its containing class then the value will be changed
                        for all instances</p>

                    <p>In the following example, <code>InstanceClass</code> contains both instance and static, fields and methods. Whilst <code>InstanceMethod</code> can
                        access both <code>instanceField</code> and <code>staticField</code>, <code>StaticMethod</code> can only access <code>staticField</code>.</p>

                    <p> Next <code>MyClass</code> contains an instance property <code>InstanceProperty</code> and a static property <code>StaticProperty</code>.
                        <code>MyClass</code> also contains methods that can separately set and get the property values. The static property is first set without
                        an instance of <code>MyClass</code> through the use of <code>MyClass.StaticProperty</code>. Next 2 instances of <code>MyClass</code>,
                        <code>myClass1</code> and <code>myClass2</code> are created and when the values of the properties are displayed we see that
                        <code>InstanceProperty</code> has the value 0 and the <code>StaticProperty</code> the value 1. Next <code>myClass1</code> is used to change
                        the value of the instance property to 2 and the static property to 3. When the properties of both instances are again displayed we see that
                        only the instance property in <code>myClass1</code> has changed whereas the the static property in both now has the value 3. This shows us that
                        each instance has its own copy of <code>InstanceProperty</code> whereas both share <code>StaticProperty</code>.</p>

                    <p>Lastly we have the static class <code>MyMathFunctions</code> which has the static method <code>SquareNumber</code> which is called directly
                        using <code>MyMathFunction.SquareNumber</code> to display the square of 3.</p>

<pre><code>using System;

namespace StaticExample
{
    public class InstanceClass
    {
        int instanceField;
        static int staticField;

        public void InstanceMethod(int value)
        {
            // An instance method can access both
            // static and instance
            staticField = value;
            instanceField = value;
        }

        public static void StaticMethod(int value)
        {
            staticField = value;

            // A static method cannot access an instance field
            // IntelliSense won't even show an option to select
            // instanceVariable and using it here results in an error.
            // Uncommenting the following results in the error
            // An object is required for the non-static field
            // method or property 'Program.InstanceClass.instanceVariable'

            //instanceVariable = value;
        }
    }

    // MyClass requires an instance to be created
    // before any instance members within it can be used
    // Static members can be used without an instance
    public class MyClass
    {
        public int InstanceProperty { get; set; }

        public static int StaticProperty { get; set; }

        public int GetInstanceProperty()
        {
            return InstanceProperty;
        }

        public void SetInstanceProperty(int value)
        {
            InstanceProperty = value;
        }

        public int GetStaticProperty()
        {
            return StaticProperty;
        }

        public void SetStaticProperty(int value)
        {
            StaticProperty = value;
        }
    }

    // A static class cannot be instantiated
    // and can only contain static members
    public static class MyMathFunctions
    {
        public static int SquareNumber(int value)
        {
            return value * value;
        }

        // Uncommenting the following results in the error
        // 'InstanceMethod': cannot declare
        // instance members in a static class
        //public void InstanceMethod() { }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var nl = Environment.NewLine;

            // Set MyClass.StaticProperty
            MyClass.StaticProperty = 1;

            // An instance of a class must be created to use an instance member.
            // Uncommenting the following results in the error
            // An object reference is required for the non-static
            // field, method or property 'Program.MyClass.InstanceProperty'
            //MyClass.InstanceProperty = 1;

            // Create a first instance of MyClass
            MyClass myClass1 = new();

            // Create a second instance of MyClass
            MyClass myClass2 = new();

            // Display the initial values of the instance and
            // static properties in instanceClass1 and instanceClass2
            // Both instance values will be 0 as they were set when the
            // instance was created. The static property is shared by all
            // instances and was set to 1 by MyClass.StaticProperty = 1; above
            Console.WriteLine("Display initial static and instance property");
            Console.WriteLine($"values of the two instances of MyClass{nl}");
            Console.WriteLine($"myClass1 InstanceProperty: {myClass1.GetInstanceProperty()}");
            Console.WriteLine($"myClass2 InstanceProperty: {myClass2.GetInstanceProperty()}");
            Console.WriteLine($"myClass1 StaticProperty: {myClass1.GetStaticProperty()}");
            Console.WriteLine($"myClass2 StaticProperty: {myClass2.GetStaticProperty()}");

            // Change the instance and static properties in myClassInstance2
            Console.WriteLine($"{nl}The instance and static properties are changed in myClassInstance2");


            // Each instance of MyClass has there own instance of
            // InstanceProperty so only myClassInstance1's is changed
            //
            myClass1.SetInstanceProperty(2);

            // Both instances of MyClass share StaticProperty
            // so changing the value in myClassInstance1 changes
            // it for both
            myClass1.SetStaticProperty(3);
            Console.WriteLine($"values of the two instances of MyClass are now{nl}");
            Console.WriteLine($"myClass1 InstanceProperty: {myClass1.GetInstanceProperty()}");
            Console.WriteLine($"myClass2 InstanceProperty: {myClass2.GetInstanceProperty()}");
            Console.WriteLine($"myClass1 StaticProperty: {myClass1.GetStaticProperty()}");
            Console.WriteLine($"myClass2 StaticProperty: {myClass2.GetStaticProperty()}");

            // The MyMathFunctions.Square method can be called
            // without creating an instance of MyMathFunctions
            Console.WriteLine($"{nl}The square of 3 is {MyMathFunctions.SquareNumber(3)}");

            // A static class cannot be instantiated
            // Uncommenting the following results in the error
            // Cannot declare a variable of static type 'Program.MyMathFunctions'
            //MyMathFunctions staticClass;
        }
    }
}

// The example writes the following to the console

// Display initial static and instance property
// values of the two instances of MyClass

// myClass1 InstanceProperty: 0
// myClass2 InstanceProperty: 0
// myClass1 StaticProperty: 1
// myClass2 StaticProperty: 1

// The instance and static properties are changed in myClassInstance2
// values of the two instances of MyClass are now

// myClass1 InstanceProperty: 2
// myClass2 InstanceProperty: 0
// myClass1 StaticProperty: 3
// myClass2 StaticProperty: 3
    </code></pre>

                    <h3>Structures (struct)</h3>

                    <p>A <b>structure</b> usually referred to by its keyword <code>struct</code> is similar to a class with the following main differences.</p>

                    <ul>
                        <li>A struct is a value type</li>
                        <li>The static, abstract and sealed modifiers cannot be applied to a struct</li>
                        <li>The readonly modifier can be applied to a struct</li>
                        <li>An instance field or property in a struct can't be initialized when a struct is declared.</li>
                        <li>A constructor in a struct must initialize all instance fields</li>
                        <li>A struct cannot have a parameterless constructor (Note: will be allowed beginning with C# 10.0) </li>
                        <li>A struct cannot have a finalizer</li>
                        <li>A struct can't inherit or be inherited by a another class or struct</li>
                    </ul>

                    <p>A struct is normally used to create a basic data type with little or no functionality. Within C# <code>int</code>, <code>double</code>,
                        <code>char</code> and <code>bool</code> are all examples of structs. As a struct is a value type so all instance fields it contains must be
                        assigned
                        a value before it can be used. Although we can't create a parameterless constructor in a struct, the compiler creates one which sets all instance
                        fields to their default values. We can then use this when instantiating a struct with the <code>new</code> keyword. If all instance fields in a
                        struct are accessible then a struct can be instantiated
                        without using the <code>new</code> keyword. For example an integer can be assigned the value 0 either by <code>int x = new();</code> or
                        <code>int x = 0;</code>.
                    </p>

                    <p>The following example declares a struct called <code>Box</code> with <code>Width</code>, <code>Height</code> and <code>Depth</code> fields and
                        a method called <code>GetVolume</code>. It demonstrates several ways to declare and assign values to a struct and then writes the values to the
                        console.</p>

<pre><code>using System;

namespace StructExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // Create a new box then set its field values
            Box box1 = new();
            box1.Width = 1;
            box1.Height = 2;
            box1.Depth = 3;

            // Create a box and set its field values in the constructor
            Box box2 = new(2, 3, 4);

            // Create a box using an alternate constructor
            Box box3 = new(2);

            // Create a box and set its field values with an object-initializer
            Box box4 = new()
            {
                Width = 4,
                Height = 5,
                Depth = 6
            };

            Console.WriteLine($"Box1 Width: { box1.Width}, Height: {box1.Height}, Length: {box1.Depth}, Volume: {box1.GetVolume()}");
            Console.WriteLine($"Box2 Width: { box2.Width}, Height: {box2.Height}, Length: {box2.Depth}, Volume: {box2.GetVolume()}");
            Console.WriteLine($"Box3 Width: { box3.Width}, Height: {box3.Height}, Length: {box3.Depth}, Volume: {box3.GetVolume()}");
            Console.WriteLine($"Box4 Width: { box4.Width}, Height: {box4.Height}, Length: {box4.Depth}, Volume: {box4.GetVolume()}");

            // If all instance fields are accessible a struct can
            // be instantiated without the new keyword but instance fields
            // must be set before it can be used
            Box box5;

            // Uncommenting the following results in the error
            // Use of unassigned variable 'box5'
            //var v = box5.GetVolume();

            box5.Width = 5;
            box5.Height = 6;
            box5.Depth = 7;

            Console.WriteLine($"Box5 Width: { box5.Width}, Height: {box5.Height}, Length: {box5.Depth}, Volume: {box5.GetVolume()}");

            // Although we can't create a parameterless constructor
            // the compiler always creates one that assigns all instance
            // fields their default values. When displayed box6 will
            // have all fields set to 0 resulting in a volume of 0
            Box box6 = new();

            Console.WriteLine($"Box6 Width: { box6.Width}, Height: {box6.Height}, Length: {box6.Depth}, Volume: {box6.GetVolume()}");
        }
    }

    public struct Box
    {
        public Box(int width, int height, int depth)
        {
            Width = width;
            Height = height;
            Depth = depth;
        }

        // A struct cannot contain a parameterless constructor
        // Uncommenting the following results in the error
        // Structs cannot contain explicit parameterless constructors
        //public Box() { }

        // A structs constructor must assign values to all instance fields
        // Uncommenting the following results in the following error
        // Field 'Box.Depth' must be fully assigned
        // before control is returned to the caller
        //public Box(double width)
        //{
        //    Width = width;
        //    Height = 1;
        //}

        // This is OK as all instance fields have been assigned a value
        public Box(int width)
        {
            Width = width;
            Height = 1;
            Depth = 1;
        }

        public int Width;

        public int Height;

        public int Depth;

        public int GetVolume()
        {
            return Width * Height * Depth;
        }
    }
}

// The example writes the following to the console

// Box1 Width: 1, Height: 2, Length: 3, Volume: 6
// Box2 Width: 2, Height: 3, Length: 4, Volume: 24
// Box3 Width: 2, Height: 1, Length: 1, Volume: 2
// Box4 Width: 4, Height: 5, Length: 6, Volume: 120
// Box4 Width: 5, Height: 6, Length: 7, Volume: 210
// Box6 Width: 0, Height: 0, Length: 0, Volume: 0
</code></pre>
                    <h3>Inheritance</h3>

                    <p>Inheritance is one of the main concepts in Object Oriented Programming. It allows us to create a parent class with common features that child
                        classes can inherit and expand upon. In C# a parent class is called a base class and a child a derived class. C# only allows single inheritance,
                        that is a derived class can only inherit from one base class but it does allow for multiple generations which means a base class can be inherited
                        by a second which it turn can inherited by a third and so on. As a result members that are in the base class will be available in each
                        generation of derived classes with the following exceptions.
                    </p>

                    <ul>
                        <li>Static constructors</li>
                        <li>Instance constructors</li>
                        <li>Finalizers</li>
                    </ul>

                    <p>Whilst all other members are available in derived classes their visibility is dependent on the Scope rules. Apart from classes only interfaces can
                        be inherited.</p>

                    <p>The following example demonstrates the syntax for inheriting a class. First base class <code>A</code> is declared as normal. Derived Class
                        <code>B</code> is then declared followed by a colon, then the name of the class to be inherited, followed by the code block for class
                        <code>B</code>.</p>

<pre><code>using System;

namespace ClassInheritanceExample
{
    // Base class A is fist declared
    class A { }

    // Derived class B inherits class A
    class B : A { }
}
</code></pre>

                    <p>It is important to note that a derived class cannot be made more accessible than a base class. In this next example base class <code>A</code>
                        does not have an
                        accessibility keyword applied so it will be internal by default. When derived public class <code>B</code> then attempts to inherit internal class
                        <code>A</code> this results in a syntax error. Following this base public class <code>C</code> is declared then derived class <code>D</code>
                        inherits class <code>C</code>. Although <code>D</code> is internal by default, this is allowed as <code>D</code> is less accessible that
                        <code>C</code>. Then when public class <code>E</code> inherits <code>D</code> again we have an error as <code>E</code> is more accessible than
                        <code>D</code>.</p>

                    <p>This illustrates that relying on the default accessibility for a class or interface can easily lead to unexpected errors so it is advisable
                        to always use the <code>internal</code> keyword if that is your intention. This is important as the default template provided by Visual Studio
                        does not provide an accessibility keyword so if you see an 'Inconsistent accessibility' error, check that the base class has been declared
                        public.</p>

<pre><code>using System;

namespace ClassInheritanceExample
{
    // Base class A default accessibility is internal
    class A { }

    // Uncommenting the following results in the error
    // Inconsistent accessibility: base class 'A'
    // is less accessible than class 'C'
    //public class B : A { }

    public class C { }

    // This is OK as internal class D is less
    // accessible than public class C
    class D : C { }

    // Uncommenting the following results in the error
    // Inconsistent accessibility: base class 'D'
    // is less accessible than class 'E'
    //public class E : D { }
}
</code></pre>

                    <p>The following example creates a base class called <code>Animal</code> with a public property <code>Legs</code> that provides access to a private
                        field <code>mLegs;</code>. Both classes <code>Bird</code> and <code>Cat</code> inherit and extend the <code>Animal</code> class with
                        <code>Bird</code> adding the property <code>Wings</code> and <code>Cat</code> the property <code>Meowing</code>. In the <code>Program</code>
                        class an instance of <code>Bird</code> is created setting values for both <code>Legs</code> and <code>Wings</code> and an instance of
                        <code>Cat</code> setting values for both <code>Legs</code> and <code>Meowing</code>. A message describing each is then written to the console with
                        their corresponding properties. The example also shows that attempting to access the private <code>mLegs</code> field in <code>Animals</code> from
                        the derived class <code>Cat</code> results in a syntax error.
                    </p>

<pre><code>using System;

namespace ClassInheritanceExample
{
    public class Animal
    {
        int mLegs;

        public int Legs
        {
            get
            {
                return mLegs;
            }
            set
            {
                mLegs = value;
            }
        }
    }

    public class Bird : Animal
    {
        public string Flying { get; set; }
    }

    public class Cat : Animal
    {
        public string Meowing { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Bird bird = new()
            {
                Legs = 2,
                Flying = "Slowly"
            };

            Cat cat = new()
            {
                Legs = 4,
                Meowing = "Loudly"
            };

            Console.WriteLine($"The bird has {bird.Legs} legs and is flying {bird.Flying}");
            Console.WriteLine($"The cat has {cat.Legs} legs and is meowing {cat.Meowing}");

            // Uncommenting the following results in the error
            // 'Animal.mLegs' is inaccessible due to its protection level
            //cat.mLegs = 4;
        }
    }
}

// The example writes the following to the console
// The bird has 2 legs and is flying Slowly
// The cat has 4 legs and is meowing Loudly
</code></pre>

                    <p>The implementation of a member in a derived class can overridden provided that the member in the base class is marked with the <code>virtual</code>
                        keyword or has overridden a member in a previous base class. To do so the member in the derived class must be marked with the
                        <code>override</code> keyword. Base class members are not virtual by default and attempting to override a member not marked as virtual results in
                        an error.</p>

                    <p>In the following example a base class <code>LogAnalyser</code> is created that has a method <code>AnalyzeLogMessage()</code> and a virtual method
                        <code>DisplayMessage()</code>. Derived class <code>LogAnalyser1</code> inherits <code>LogAnalyser</code> and overrides the virtual method
                        providing its own implementation. <code>LogAnalyser2</code> inherits <code>LogAnalyser1</code> and overrides the virtual method that it had
                        overridden. <code>LogAnalyser3</code> also inherits <code>LogAnalyser</code>. It does not override the virtual method but it shows that attempting
                        to override the non virtual method results in a syntax error. When <code>DisplayMessage()</code> is called from each of the derived class
                        instances <code>LogAnalyser1</code> and <code>LogAnalyser2</code> each display the message in their own overridden methods whereas
                        <code>LogAnalyser3</code> displays the message from the base class.
                    </p>

<pre><code>using System;

namespace ClassInheritanceExample
{
    public class LogAnalyser
    {
        public void AnalyzeLogMessage()
        {
            Console.WriteLine("Analyzing log message");
        }

        public virtual void DisplayMessage()
        {
            Console.WriteLine("Log message has occurred");
        }
    }

    public class LogAnalyser1 : LogAnalyser
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 1 has occurred");
        }
    }

    public class LogAnalyser2 : LogAnalyser1
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 2 has occurred");
        }
    }

    public class LogAnalyser3 : LogAnalyser
    {
        // Uncommenting the following results in the error
        // 'LogAnalyser3.AnalyzeLogMessage()':cannot override inherited member
        // 'LogAnalyser.AnalyzeLogMessage()' because it is not marked
        // virtual, abstract or override
        //public override void AnalyzeLogMessage() { }
    }

    class Program
    {
        static void Main(string[] args)
        {
            LogAnalyser1 logAnalyser1 = new();
            LogAnalyser2 logAnalyser2 = new();
            LogAnalyser3 logAnalyser3 = new();

            Console.WriteLine("Using logAnalyser1");
            logAnalyser1.AnalyzeLogMessage();
            logAnalyser1.DisplayMessage();

            Console.WriteLine();
            Console.WriteLine("Using logAnalyser2");
            logAnalyser2.AnalyzeLogMessage();
            logAnalyser2.DisplayMessage();

            Console.WriteLine();
            Console.WriteLine("Using logAnalyser3");
            logAnalyser3.AnalyzeLogMessage();
            logAnalyser3.DisplayMessage();
        }
    }
}

// The example writes the following to the console
// Using logAnalyser1
// Analyzing log message
// Log message type 1 has occurred

// Using logAnalyser2
// Analyzing log message
// Log message type 2 has occurred

// Using logAnalyser3
// Analyzing log message
// Log message has occurred
</code></pre>

                    <p>In the previous example each derived class was created and the methods called separately. Ideally it would have been better to do this
                        all through a loop. We can do this as polymorphism allows us to substitute a parent for a child then when the parent's method is called at runtime
                        it will be substituted for the child's.
                    </p>

                    <p>In this example example a base class <code>LogAnalyser</code> is defined that has a virtual <code>DisplayMessage</code> method. Derived class
                        <code>LogAnalyser1</code> inherits from <code>LogAnalyser</code> and <code>LogAnalyser2</code> inherits from <code>LogAnalyser1</code> with each
                        overriding <code>DisplayMessage</code> with its own implementation. In the <code>Program</code> class a list of type <code>LogAnalyser</code> is
                        created that adds an instance of the base and the two derived classes. A foreach loop then loops through the list using a
                        <code>LogAnalyser</code> type iterator calling the <code>DisplayMessage</code> method which at runtime is replaced by the overridden version of
                        each item.</p>

<pre><code>using System;
using System.Collections.Generic;

namespace ClassInheritanceExample
{
    public class LogAnalyser
    {
        public virtual void DisplayMessage()
        {
            Console.WriteLine("Log message has occurred");
        }
    }

    public class LogAnalyser1 : LogAnalyser
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 1 has occurred");
        }
    }

    public class LogAnalyser2 : LogAnalyser1
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 2 has occurred");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            List&gt;LogAnalyser&lt; logAnalysers = new()
            {
                new LogAnalyser(),
                new LogAnalyser1(),
                new LogAnalyser2(),
            };

            foreach(LogAnalyser logAnalyser in logAnalysers)
            {
                logAnalyser.DisplayMessage();
            }
        }
    }
}

// The example writes the following to the console
// Log message has occurred
// Log message type 1 has occurred
// Log message type 2 has occurred
</code></pre>

                    <p>To prevent a class from being inherited it can be marked with the <code>sealed</code> keyword. A member that is being overridden in a class can
                        also be marked as <code>sealed</code> which prevents it from being overridden in any further derived classes.</p>

<pre><code>using System;

namespace SealedClassExample
{
    public sealed class A
    {
        public void Method1() { }

        // Uncommenting the following results in the error
        // 'A.Method2()' is a new virtual member in a sealed type 'A'
        //public virtual void Method2() { }
    }

    // Uncommenting the following results in the error
    // 'B':cannot derive from sealed class 'A'
    //public class B : A { }

    public class C
    {
        public virtual void Method1() { }
    }

    public class D : C
    {
        public sealed override void Method1() { }
    }

    public class E : D
    {
        // Uncommenting the following results in the error
        // 'E.Method1()' cannot override inherited member 'D.Method1()' because it is sealed
        //public override void Method1() { }
    }
}
</code></pre>

<!-- TODO Rewrite this -->
                    <p>Although constructors cannot be inherited those in the base class are still called after the derived constructor is called but before the enclosed
                        code of the derived class constructor is run. Additionally the <code>base</code> keyword can be used in a derived class to call constructors and
                        overridden instance members within the base class. Only those in the immediate base class in the derived class declaration can be accessed. Lastly
                        if a base class is provided with one or more parameterized constructors then the compiler forgoes providing the default parameterless constructor.
                        As a result when inheriting such a class we will then need to provide the derived class with at least one constructor with the same signature as
                        one of the constructors in the base class. The constructor in the derived class must call the constructor in the base class by using the
                        <code>base</code> keyword and pass the arguments provided to it on to the base class constructor.</p>

                    <p>In this example <code>BaseClass</code> has a parameterless constructor that writes to the console when it is called, then sets a value in a
                        a field called <code>mField</code>. It also has a parameterized constructor that takes a value which it uses to set <code>mField</code>
                        and a virtual method <code>GetFieldValue</code> that returns the value of <code>mField</code>. <code>DerivedClass</code> inherits from
                        <code>BaseClass</code>. It too has a parameterless constructor that writes to the console when it is called, then sets a value in its own
                        field called <code>mField</code>. It also has a parameterized constructor which first calls its counterpart in the base class through use of the
                        <code>base</code> keyword which requires passing all arguments it receives to the base class. The derived class also overrides
                        <code>GetFieldValue</code> returning its own <code>mField</code> value and has a method called <code>CallBaseMethod</code> which, using the
                        <code>base</code> keyword, calls <code>GetFieldValue</code> in the base class.</p>

                    <p>In the <code>Program</code> class an instance of <code>DerivedClass</code> is created using the parameterless constructor which results in first
                        the base class then the derived class constructor being called. Then the return value of <code>GetFieldValue</code> followed by
                        <code>CallBaseMethod</code> are written to the console. Next a second instance of <code>DerivedClass</code> is created using the parameterized
                        constructor with the string 'instance 2' passed in and again the return value of <code>GetFieldValue</code> followed by
                        <code>CallBaseMethod</code> are written to the console.</p>

                    <p>The example also declares a class <code>BaseClass2</code> which contains a parameterized constructor. Deriving the class
                        <code>DerivedClass2</code> from <code>BaseClass2</code> without providing a parameterized constructor with the same signature as that of the base
                        class results in a syntax error.
                    </p>

<pre><code>using System;

namespace BaseClassExample
{
    public class BaseClass
    {
        string mField;

        public BaseClass()
        {
            Console.WriteLine("Base class constructor");
            mField = "Base class";
        }

        public BaseClass(string value)
        {
            mField = "Base Class " + value;
        }

        public virtual string GetFieldValue()
        {
            return mField;
        }
    }

    public class DerivedClass : BaseClass
    {
        string mField;

        public DerivedClass()
        {
            Console.WriteLine("Derived class constructor");
            mField = "Derived class";
        }

        public DerivedClass(string value) : base(value)
        {
            mField = "Derived Class " + value;
        }

        public override string GetFieldValue()
        {
            return mField;
        }

        public string CallBaseMethod()
        {
            return base.GetFieldValue();
        }
    }

    public class BaseClass2
    {
        public BaseClass2(int value) { }
    }

    // Uncommenting the following results in the error
    // There is no argument given that corresponds to the
    // required formal parameter 'value' of 'BaseClass2.BaseClass2(int)'
    //public class DerivedClass2 : BaseClass2 { }

    class Program
    {
        static void Main(string[] args)
        {
            DerivedClass instance1 = new();
            Console.WriteLine();
            Console.WriteLine(instance1.GetFieldValue());
            Console.WriteLine(instance1.CallBaseMethod());

            Console.WriteLine();
            DerivedClass instance2 = new("instance 2");
            Console.WriteLine(instance2.GetFieldValue());
            Console.WriteLine(instance2.CallBaseMethod());
        }
    }
}

// The example writes the following to the console
// Base class constructor
// Derived class constructor

// Derived class
// Base class

// Derived Class instance 2
// Base Class instance 2
</code></pre>

                    <p> An <b>abstract</b> class is used when it makes sense to define a common base class but where the implementation is specific to each derived class.
                        A base
                        class and its members can be declared abstract by marking them with the <code>abstract</code> keyword. It cannot be instantiated so to be used, a
                        derived class must be created that inherits it and overrides all abstract members it contains. Abstract classes can be inherited by sealed,
                        abstract and non abstract classes and can inherit from an abstract or non abstract base class that is not a sealed class. Abstract members cannot
                        declare an implementation and within a derived class are treated the same as a virtual member. Any class that contains an abstract member must be
                        marked with the <code>abstract</code>keyword. An abstract class can contain both abstract and non abstract members.</p>

                    <p>In the following example an abstract class <code>PriceCalculator</code> is declared with an abstract method called <code>CalculateAmount</code>.
                        Two derived classes that inherit from <code>PriceCalculator</code> are declared. The first <code>ItemsPriceCalculator</code> has two properties,
                        <code>ItemPrice</code> and <code>Quantity</code> and overrides <code>CalculateAmount</code> to return an amount by multiplying these two
                        properties. The second class <code>HoursPriceCalculator</code> has three properties, <code>StartTime</code>, <code>FinishTime</code> and
                        <code>HourlyRate</code>. In this case the overridden <code>CalculateAmount</code> first subtracts <code>StartTime</code> from
                        <code>FinishTime</code> then multiplies thy result by <code>HourlyRate</code> and then returns the amount. Lastly as can be seen, attempting to
                        instantiate <code>PriceCalculator</code> results in a syntax error.</p>

<!-- TODO Add info somewhere about creating datetime and ToString("C", CultureInfo.CurrentCulture) -->

<pre><code>using System;
using System.Globalization;

namespace AbstractClassExample
{
    public abstract class PriceCalculator
    {
        public abstract double CalculateAmount();
    }

    public class ItemsPriceCalculator : PriceCalculator
    {
        public double ItemPrice { get; set; }

        public int Quantity { get; set; }

        public override double CalculateAmount()
        {
            return ItemPrice * Quantity;
        }
    }

    public class HoursPriceCalculator : PriceCalculator
    {
        public  DateTime StartTime { get; set; }

        public  DateTime FinishTime { get; set; }

        public double HourlyRate { get; set; }

        public override double CalculateAmount()
        {
            var timeTaken = FinishTime - StartTime;
            return timeTaken.TotalHours * HourlyRate;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ItemsPriceCalculator itemsPriceCalculator = new();
            itemsPriceCalculator.Quantity = 6;
            itemsPriceCalculator.ItemPrice = 3.10;
            Console.WriteLine($"The price of the items is {itemsPriceCalculator.CalculateAmount().ToString("C", CultureInfo.CurrentCulture)}");

            HoursPriceCalculator hoursPriceCalculator = new();
            hoursPriceCalculator.StartTime = new DateTime(2021, 11, 4, 9, 0, 0);
            hoursPriceCalculator.FinishTime = new DateTime(2021, 11, 4, 17, 0, 0);
            hoursPriceCalculator.HourlyRate = 30;
            Console.WriteLine($"The price of the hours is {hoursPriceCalculator.CalculateAmount().ToString("C", CultureInfo.CurrentCulture)}");

            // Uncommenting the following results in the error
            // Cannot create an instance of the abstract type or instance 'PriceCalculator'
            //PriceCalculator priceCalculator = new();
        }
    }
}

// The example writes the following to the console
// The price of the items is $18.60
// The price of the hours is $240.00
}
</code></pre>

                    <p>All classes in C#, even the ones we write, are ultimately derived from the <b>object</b> class. This means that even if we don't explicitly use the
                        syntax to inherit from <code>object</code> our class will still contain the following overridable members</p>

                    <ul>
                        <li>Equals(Object)</li>
                        <li>Finalize()</li>
                        <li>GetHashCode()</li>
                        <li>ToString()</li>
                    </ul>

                    <p>the following non-overridable members</p>

                    <ul>
                        <li>GetType()</li>
                        <li>MemberwiseClone()</li>
                    </ul>

                    <p>and the following static members</p>

                    <ul>
                        <li>Equals(Object, Object)</li>
                        <li>ReferenceEquals(Object, Object)</li>
                    </ul>

                    <p>The default implementation of <code>ToString()</code> is to return the result of <code>GetType()</code> which is the fully qualified type name. As
                        a result it is not uncommon to override <code>ToString()</code> with something more meaningful. In the following example the class
                        <code>Person</code> takes in first and last name arguments in its constructor and <code>ToString()</code> is overridden to combine the
                        first and last names then return the full name which is written to the console.</p>

<pre><code>using System;

namespace OverridingToStringExample
{
    public class Person
    {
        public string FirstName { get; set; }

        public string LastName { get; set; }

        public override string ToString()
        {
            return FirstName + " " + LastName;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Person person = new()
            {
                FirstName = "Denise",
                LastName = "Jones"
            };

            Console.WriteLine($"This person is {person.ToString()}");
        }
    }
}

// The example writes the following to the console
// This person is Denise Jones
</code></pre>

                    <h3>Interfaces</h3>

                    <p>"An interface is a contract" has to be one of the worst explanations as to what an interface is, yet it still persists throughout much of the
                        literature you may find on line, including that of Microsoft's own C# reference. So what is an interface.</p>

                    <p>Take a computer manufacturer. They can't anticipate every printer, keyboard, mouse, etc, that will be plugged into their devices. To allow for this,
                        the industry as a whole has created a set of specifications of which various devices must adhere to, so that they are compatible. For a keyboard
                        this may be the signals it must produce when a key is pressed, but it is not the computer manufacturer's job to tell the keyboard manufacturer
                        how to make their keyboards. Providing that the specifications are met the keyboard manufacturer is free to design it as they like. An interface
                        works on a similar basis by defining which members a class or struct will have without saying how they are to be implemented.</p>

                    <p>An interface is created using the <code>interface</code> keyword. The following signature only members can be declared within an interface.</p>

                    <ul>
                        <li>Methods</li>
                        <li>Properties</li>
                        <li>Indexers</li>
                        <li>Events</li>
                    </ul>

                    <p>Members that are not implemented are public by default and access modifiers cannot be applied to them. Additionally interfaces can contain members
                        that are implemented which is called default implementation. These are</p>

                    <ul>
                        <li>Constants</li>
                        <li>Operators</li>
                        <li>Static constructors</li>
                        <li>Nested types</li>
                        <li>Static fields</li>
                        <li>Static Methods</li>
                        <li>Static Properties</li>
                        <li>Static Indexers</li>
                        <li>Static Events</li>
                        <li>Member declarations using explicit interface implementation syntax</li>
                        <li>Explicit access modifiers</li>
                    </ul>

                    <p>An interface cannot contain an instance field or instance auto-property as an interface cannot have an instance state. Note, whilst the declaration
                        of a property in an interface is written with the same syntax as an instance <span class="nowrap">auto-property,</span> it differs in that the
                        compiler does not create an instance backing field. An interface can inherit from and be inherited by another interface. Implemented members in an
                        interface can be overridden. When this is done explicit interface implementation syntax must be used.</p>

                    <p>Whereas a class can only inherit a single base class it can implement multiple interfaces. This is done in the same manner, i.e. the class name is
                        followed by a colon then the name of all interfaces in a comma separated list. If a class also inherits a base class its name must come first in
                        the list. A class can also explicitly implement a member of an interface. Explicitly implemented members and default implemented members in an
                        interface can only be accessed through an instance of the interface.</p>

                    <p>Whilst on the surface an interface may seem to provide much of the same function as an abstract class the important distinction is that a class can
                        contain a state and thus can represent a thing where as an interface cannot and is used to represent a behavior.</p>

                    <p>In the following example the <code>Car</code> class inherits the base class <code>Vehicle</code> and overrides the <code>ApplyBrakes</code>
                        method. The <code>Dog</code> class has a method <code>Speak</code>. Whilst both are quite different objects both are able to move and make a sound
                        and so implement the <code>IMotion</code> and <code>ISound</code> interfaces which respectively include the <code>Move</code> method and
                        <code>Sound</code> property. As can be seen whilst the base class <code>Vehicle</code> must come first in the declaration list, the order of the
                        interface declaration is irrelevant.</p>

<pre><code>using System;

namespace InterfaceExample
{
    public interface IMotion
    {
        void Move();
    }

    public interface ISound
    {
        string Sound { get; set; }
    }

    public abstract class Vehicle
    {
        public abstract void ApplyBrakes();
    }

    public class Car : Vehicle, ISound, IMotion
    {
        public string Sound { get; set; }

        public void Move()
        {
            Console.WriteLine("Car accelerates");
        }

        public override void ApplyBrakes()
        {
            Console.WriteLine(Sound);
            Console.WriteLine("Car slows");
        }
    }

    public class Dog : IMotion, ISound
    {
        public string Sound { get; set; }

        public void Move()
        {
            Console.WriteLine("Dog chases car");
        }

        public void Speak()
        {
            Console.WriteLine(Sound);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Car car = new();
            car.Sound = "Brakes squeal";

            Dog dog = new();
            dog.Sound = "Dog barks";

            car.Move();
            dog.Move();
            car.ApplyBrakes();
            dog.Speak();
        }
    }
}

// The example writes the following to the console
// Car accelerates
// Car slows
// Dog chases car
// Dog barks at car
</code></pre>

                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Delegates, Actions and Functions -->
            <section class="main-section" id="Anonymous_function_expressions">
                <header><h2>Anonymous function expressions</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
<!-- TODO Write up this section-->
                <article>
                    <p>Lorem</p>


<pre><code>using System;

namespace DelegateExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // Example of an anonymous function
            // with an expression body
            // prints 27 to the console
            Func &lt;int, int&gt; volume = x =&gt; x* x *x;

            Console.WriteLine($"volume = {volume(3)}");

            // Example of an anonymous function
            // with a statement block
            // prints 50.2654824 to the console
            Action &lt;int&gt; printArea = r =&gt;
            {
                const double pi = 3.14159265;
                var area = pi * r * r;
                Console.WriteLine($"area = {area}");
            };

            printArea(4);
        }
    }
}

// The example prints the following to the console
// volume = 27
// area = 50.2654824
</code></pre>

                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION References and Namespaces -->
            <section class="main-section" id="References_and_Namespaces">
                <header><h2>References and Namespaces</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
<!-- TODO complete this section -->
                <article>

                    <h3>References</h3>
                    <p>An application can be made up of multiple sources of code including that which you write. In Visual Studio an application is called a
                        <b>Solution</b> and can be viewed in the <b>Solution Explorer</b> window which can be accessed via the <b>Solution Explorer</b> tab
                        on the right side of the application.  If the tab is not visible, click on <b>View</b> then <b>Solution Explorer</b> in the menu. Here you
                        will see the name of your solution and the projects contained within it. Under each project are code files which can be arranged in folders
                         along with . These can contain Frameworks such as the current
                        .Net 5.0, applications and libraries.  called projects which together form an application
                        solution. To use such code a reference to it must be added.
                        In <b>Visual Studio</b> this is done through the <b>Solution Explorer</b>  Under each project you will find any folders and files associated
                         with it and also a node called <b>Dependencies</b>. Expanding the Dependencies node will reveal several more nodes. If any references have
                         been added a node will be present called Projects under which you will find the referenced code. To add a reference right click on any











                         The Frameworks node
                         contains the frameworks that have been added by Visual Studio when the solution was created. For a console application created with a
                         .Net 5.0 target framework. Expanding the Framework node reveals that this is called Microsoft.NETCore.APP and expanding this node reveals
                         the libraries that are included by default.

                    </p>

                    <h3>Namespaces</h3>
                    <p>C# requires that each object within a particular scope be unique and namespaces do this by organizing the code into a tree structure
                        similar to that of the file system on a computer. For example in order to have 2 files called MyFile.txt on a computer you may put one
                        in a folder called RootFolder\MyFiles1 and the other in RootFolder\MyFiles2. Namespaces are the same except that the root namespace is
                        normally the name of a project and the backslashes are replaced with a dot. A sublevel namespace is known as a nested namespace</p>

                    <h3>namespace</h3>
                    <p>The <code>namespace</code> keyword followed by a code block is used to declare objects belonging to a particular <b>namespace</b>. Objects can then
                        be identified in code by using their <b>fully qualified</b> names in the form <code>MyNamespace.MyObject</code>. <b>IntelliSense</b> uses
                        namespaces to assist you by providing suggestions as you type. After typing the root namespace then pressing <kbd>.</kbd>, all the objects and
                        nested namespaces within it
                        will appear
                        in the suggestion box. If one of the nested namespaces is selected, the <kbd>.</kbd> can again be pressed to find all objects and nested namespaces
                        within it and the process can be repeated until no nested namespaces remain.</p>

<pre><code>// A using directive can be placed at
at the top of the file
namespace MyProject
{
    class SomeClass  { }

    enum SomeEnum { sun, mon, tue, wed, thu, fri, sat }

    interface ISomeInterFace { }
}

// Declare an object in a sublevel namespace
namespace MyProject.DataModels
{
    class Person { }

    class Employer { }

    class Job { }
}

// An alternate way to declare in a
// sublevel using a nested namespace
namespace MyProject
{
    namespace Animals
    {
        class Dog { }

        class Cat { }
    }
}

namespace AnotherNamespace
{
    class AnotherClass
    {
        public void Example()
        {
            // Objects identified by using their
            // fully qualified names
            MyProject.MyClass myClass = new();
            MyProject.MyEnum myEnum = MyProject.MyEnum.Mon;
            MyProject.Animals.Cat cat = new();
            MyProject.DataModels.Person person = new();
        }
    }
}
</code></pre>

                    <p>When adding a new class using the default class template, Visual Studio automatically puts it within a namespace based on the folder in
                        the project in which the class is added. If you want to use the root namespace instead and want to avoid editing the namespace, add the
                        new class to the root project then move the file to your desired folder. The following shows the code generated by adding a class called
                        <b>MainViewModel</b> to a folder called <b>ViewModels</b> in a project called <b>MyCompany</b>.
                    </p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MyCompany.ViewModels
{
    class MainViewModel
    {
    }
}
</code></pre>
                    <h3>using</h3>

                    <p>Identifying every object by its <b>fully qualified</b> name soon becomes cumbersome and can make the code hard to read. The <code>using</code>
                        directive makes all objects and nested namespaces within a namespace available for use. This is also known as importing. The name of just
                        the objects name can then be used within the code.</p>
                    <p>If you know the name of the object you want to add to your code but don't know its namespace, Visual Studio provides a shortcut for this.
                        After typing the object's full name and with the cursor touching it, for example <code>List</code>, press <kbd>Ctrl</kbd> + <kbd>.</kbd>
                        and IntelliSense will suggest the correct using directive to use, most likely at the top of the list. Click on the suggestion and it will
                        added to the code. Please note that the full name name must be entered with the correct case. Also, the project must have a reference
                        to the library containing object. (See below)</p>
                    <p>To remove unused <b>using</b> directives, right click anywhere in the code editor and click <b>Remove and Sort Usings</b>.</p>
                    <p> The following assumes that the first example in this section already exists.</p>

<pre><code>using MyProject.Animals;
using MyProject.DataModels;

namespace SomeNamespace
{
    class SomeClass
    {
        Cat cat = new();
        Person person = new();
    }
}
</code></pre>
                    <h3>Aliases</h3>

                    <p>The <code>using</code> can also be used to create an alias for a namespace or object. The following assumes that the first example in this
                        section already exists.</p>

<pre><code>using Project = MyProject;
using Employment = MyProject.DataModels;
using MyDog = MyProject.Animals.Dog;

namespace SomeNamespace
{
    class SomeClass
    {
        Project.Animals.Dog dog = new();
        Employment.Employer employer = new();
        MyDog myDog = new();
    }
}
    </code></pre>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Scope and Access Modifiers -->
            <section class="main-section" id="Scope_and_Access_Modifiers">
                <header><h2>Scope and Access Modifiers</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
<!-- TODO complete this section -->
                <article>
                    <h3>Scope</h3>
                    <p>Scope is the accessibility of a variable from one part of the code to another. In C# scope is arranged like the layers of an onion. Variables in an
                        outer scope can be accessed from those within but not vise versa. In computer science this is known as encapsulation and inner scopes that are
                        contained within outer scopes are said to be nested.
                        </p>
<!-- TODO variable links-->
                    <p>A <b>local variable</b> is a variable declared in a method, property or indexer or one of its nested code blocks. The variable is only accessible
                        after it has been declared and only within the same code block or a nested code block. A local variable within the same block or a nested code
                        block cannot be declared with the same name. A parameter that is passed into a method or indexer is accessible outside the member and becomes a
                        local variable within the member.</p>

                    <p>A variable declared inside a class, struct or record type but outside any member is called a field and is also a member of that type. A field can
                        be directly accessed by any of the type's methods, properties or indexers and any nested code blocks they contain, irrespective of the location of
                        the field's declaration within the class. By convention fields are normally declared at the top of a class before any other code. A field can be
                        modified to be readonly and its accessibility level can be changed with the use of an access modifier, (See Access modifiers below).</p>

                    <p>A local variable in the same container (enclosing type) as a field can be declared with the same name and any type. When this is done the field is
                        said to be hidden by the local variable. In this case, to then access the field the <code>this</code> name qualifier this must be used. For
                        example if in a class a field <code>int someName</code> exists and in a method <code>string someName;</code> to access the field you would use
                        <code>var x = this.someName</code>.</p>

                    <p>Following are examples of scope.</p>
<!-- TODO scope code example -->
<pre><code>using System;

namespace ScopeExample
{
    public class Class1
    {
        string nl = Environment.NewLine;

        // Define field1 and field2 at the top of the class
        // Fields do not have to be initialized so field1
        // has the default integer value 0
        int field1;
        string field2 = "field2";

        public void Method1(int value)
        {
            // variable1 is declared and initialized within the
            // scope of Method1. All code following this within
            // Method1 will have access to it
            int variable1 = 1;

            // The variable 'value' was declared in the signature of Method1
            // and as such is a local variable in the scope of Method 1
            // Uncommenting the following results in the error
            // A local or parameter named 'value' cannot be declared in this scope because
            // that name is used in an enclosing local scope to define a local or parameter
            //int value = 0;

            Console.WriteLine($"Initial class level field1 value = {field1}");

            // A local variable field2 is declared after this statement
            // which hides the class level declaration of field2
            // Uncommenting the following results in the error
            // Cannot use variable 'field2' before it is declared.
            // The declaration of the local variable hides the field 'Class1.field2'.
            //Console.WriteLine($"Initial field2 value = {field2}");

            // Declaring a local field2 variable hides the class level field2
            // Local field2 is an int whereas class level field2 is a string
            int field2 = 0;
            Console.WriteLine($"Initial local variable field2 value = {field2}");

            // To access the hidden class level field2 use the 'this' qualifier
            Console.WriteLine($"Class level field2 value = {this.field2}");

            Console.WriteLine($"{nl}Display iterator 'i' from Loop 1");

            // Loop 1 defines a nested scope within the scope of Method1
            // A variable named 'i' has been declared as the iterator for Loop 1
            for (int i = 0; i &lt;= 5; i++)
            {
                Console.Write($"{i}, ");
                variable1 += i;
                int variable2 = i * 2;
                field1 += variable2;
            }

            Console.WriteLine($"{nl}Result of variable1 in Loop 1 = {variable1}");
            Console.WriteLine($"Result of field1 in Loop 1 = {field1}");

            variable1 = 0;
            field1 = 0;

            Console.WriteLine($"{nl}Display iterator 'i' from Loop 2");

            // Loop 2 also defines a scope within Method1 but is outside
            // the scope of Loop 2. As such a variable named 'i' can
            // also be declared as an iterator for Loop 2
            for (int i = 0; i &lt;= 15; i += 3)
            {
                Console.Write($"{i}, ");
                variable1 += i;
                int variable2 = i * 4;

                // Although field3 was declared within Class1 after Method1
                // as it is a Field the location of its declaration within
                // the class does not matter so it can be accessed here
                field3 += variable2;

                // As Loop 2 has declared variable 'i' as its iterator and as any
                // code here is within the scope of Loop 2 no other variables
                // named 'i' can be declared here.
                // Uncommenting the following results in the error
                // A local or parameter named 'i' cannot be declared in this scope because that
                // name is used in an enclosing local scope to define a local or parameter
                //for (int i = 0; i &lt; 10; i++) { }

                // As variable3 is declared after Loop 2
                // uncommenting the following results in the error
                // Cannot use variable 'variable3' before it is declared
                //variable3 = 1;

                // Even though variable3 is declared after Loop 2 and thus cannot
                // be used here it is still with in the code block for Method1 and
                // as such is a local variable in respect to the scope of Loop 2
                // Uncommenting the follow results in the error
                // A local or parameter named 'variable3' cannot be declared in this scope because
                // that name is used in an enclosing local scope to define a local or parameter
                //int variable3 = i;

                // Loop 3 creates a nested scope within Loop 2
                for (int j = 0; j &lt; 5; j++)
                {
                    // Loop 2 iterator i and variable2 can
                    // be accessed within the scope of Loop 2
                    int variable4 = j + i + variable2;
                    field1 += variable4;
                }
            }

            Console.WriteLine($"{nl}Result of variable1 in Loop 2 = {variable1}");
            Console.WriteLine($"Result of field1 in Loop 2 = {field1}");
            Console.WriteLine($"Result of field3 in Loop 2 = {field3}");
            Console.WriteLine($"local field2 = {field2}");
            Console.WriteLine($"class level field2 = {this.field2}");

            // 'variable2' and 'i' from Loop 1 and Loop 2 and 'j' from Loop 3
            // are all out of scope outside the loops so uncommenting
            // any of the following 3 statements results in an error
            //Console.WriteLine($"variable2 = {variable2}");
            //Console.WriteLine($"i = {i}");
            //Console.WriteLine($"j = {j}");

            int variable3 = 0;
        }

        // Although by convention fields are defined at
        // the top of a class they can be placed anywhere
        int field3 = 20;

        // None of the local variables within the scope of Method1
        // can be accessed outside of it at the class level
        // Uncommenting the following will result in an error
        //variable1 = 0;
        //variable2 = 0;
        //variable3 = 0;
        //variable4 = 0;
        //i = 0;
        //j = 0;
        //value = 0;

        // Method2 declares the same local variables as Method1
        // There is no conflict as the variables within each
        // method are within their own local scope
        public void Method2(string value)
        {
            int variable1 = 0;
            int variable2 = 0;
            int variable3 = 0;
            int variable4 = 0;
            int i = 0;
            int j = 0;
            field2 = value;
            Console.WriteLine($"Method2 field2 = {field2}");
        }

        // An attempt is made to define another field1 within the same scope
        // Uncommenting the following results in the error
        // The type 'Class1' already contains a definition for 'field1'
        //int field1;
    }

    class Program
    {
        static void Main(string[] args)
        {
            Class1 class1 = new();
            class1.Method1(10);
            class1.Method2("New value");
        }
    }
}

// The example prints the following to the console
// Initial class level field1 value = 0
// Initial local variable field2 value = 0
// Class level field2 value = field2

// Display iterator 'i' from Loop 1
// 0, 1, 2, 3, 4, 5,
// Result of variable1 in Loop 1 = 16
// Result of field1 in Loop 1 = 30

// Display iterator 'i' from Loop 2
// 0, 3, 6, 9, 12, 15,
// Result of variable1 in Loop 2 = 45
// Result of field1 in Loop 2 = 1185
// Result of field3 in Loop 2 = 200
// local field2 = 0
// class level field2 = field2
// Method2 field2 = New value
</code></pre>
                    <h3>Access modifiers</h3>
                    <p> Accessibility level defines where a type or type's members can be used by other code within your assembly or other assemblies.
                        Each type or member has a default access level which, depending on the context, can be changed either by the access level of the
                        container or by the use of an access modifier keyword. A local variable's
                        accessibility is always restricted to the scope in which it is contained and cannot be modified. Except for <code>protected internal</code>
                        and <code>private protected</code> only one access modifier keyword can be applied to a type or a member. For information about accessibility
                        of the accessors for a property or indexer see Classes.
                        Following is the list of access modifier keywords and the access level provided by them.
                    </p>

                    <ul>
                        <li><b>public</b> - the same assembly or another assembly that references it</li>
                        <li><b>protected internal</b> - the same assembly or in a derived class in another assembly</li>
                        <li><b>protected</b> - the same class or a derived class in the same or another assembly</li>
                        <li><b>internal</b> - the same assembly only</li>
                        <li><b>private protected</b> - the same class or a derived class in the same assembly only</li>
                        <li><b>private</b> - the same class or a derived class nested within a base class only</li>
                    </ul>

                    <p>Types declared directly within a namespace (i.e. not nested), can only be declared public or internal where internal is the default level. The
                        following types can be be declared in a namespace <code>class</code>, <code>struct</code>, <code>interface</code>, <code>delegate</code>,
                        <code>record</code> and <code>enum</code>.</p>

                    <p>The following list shows containing types, which access modifiers can be applied to the members and nested types within them and their
                        default access level.</p>

                    <ul>
                        <li><b>class or record</b> - <code>public</code>, <code>protected internal</code>, <code>protected</code>,
                            <code>internal</code>, <code>private protected</code>, <code>private(default)</code></li>
                        <li><b>interface</b> - <code>public (default)</code>, <code>protected internal</code>, <code>protected</code>,
                            <code>internal</code>, <code>private protected</code>, <code>private</code>*</li>
                        <li><b>struct</b> - <code>public</code>, <code>internal</code>, <code>private(default)</code></li>
                    </ul>

                    <p>Enum members do not have any declared accessibility. An enum member's accessibility  is determined by the accessibility of the
                        enum type container and access modifiers cannot be applied to them.</p>

                    <p>The following example demonstrates various accessibility scenarios. </p>

<pre><code>code
code
</code></pre>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Object-oriented Programming -->
            <section class="main-section" id="Object-oriented_Programming">
                <header><h2>Object-oriented Programming</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>

                    <p>Object-oriented programming (OOP) is a programming paradigm used extensively throughout C#. It encompasses a number of
                        concepts that provide the developer a structured process for writing a program. This is particularly important for large
                        applications that may be maintained by multiple teams of developers. Instead of having one massive
                        length of code that does everything, it is instead broken down into objects that each have a narrowly defined responsibility.
                        C# uses a sort of template in the form of either a Class or Struct to define an object and each specific object is known as a type.
                        These are then combined to create an application.
                    </p>

                    <p> Major principles of OOP include:</p>

                    <ul>
                        <li>Object</li>
                        <li>Encapsulation</li>
                        <li>Inheritance</li>
                        <li>Abstraction</li>
                        <li>Polymorphism</li>
                    </ul>

                    <h3>Object</h3>

                    <p>An object combines data and methods to represent everyday things such as a number, a spreadsheet, a person or
                        even something less tangible such as the relationship between a part's name and its quantity in a database. During runtime multiple objects
                        based on the same type can be created each with its own own internal state. This allows different versions (instances) of an object to exist. For
                        example two number type objects could be created, one with a value of 5 and another with 7. Three techniques employed by C# to define an
                        object are:</p>

                    <ul>
                        <li>Properties - a particular state of an object such as color, the number of columns, what a thing is made of.</li>
                        <li>Methods - something an object can do such as add numbers, manipulate text, etc. Methods can take in and return modified data.</li>
                        <li>Events - a way of communicating to other objects that its state has changed.</li>
                    </ul>

                    <p>Take for example a light. It could have a 'Light Is On' property, a 'Turn Light On' method and a 'Light Has Turned' On event. A person object
                        could then check the 'Light Is On' property and if it's off (false), use the 'Turn Light On' method to turn the light on. The method would then
                        set 'Light Is On' to true and then trigger the 'Light Has Turned On' event. A second person object could be watching out for the event and when
                        it happens it would know to run its own 'Read Book' method.
                    </p>

                    <h3>Encapsulation</h3>

                    <p>Encapsulation protects the data and methods used to define the internal state of an object from direct manipulation.
                        This way code external to an object need not be concerned with the data it contains or how a method works, only that by using it, it will provide
                        the expected result. Take for example the posting of a letter. Provided that you give it the correct address and a stamp, once you place it in
                        the mail box you expect it to arrive at the recipient. You need not be concerned with the details of the method (how it will be delivered) or
                        the internal data (the name of the person doing the delivery). With this the creator of the object is free to change the internal workings of
                        an object without affecting those using it, as long as it continues to do what it says on the box. In order to decide which object members are
                        made available externally to an object, C# provides access modifier keywords such as <code>public</code> and <code>private</code>.
                    </p>

                    <h3>Inheritance</h3>

                    <p>Many things in life have similarities. For example a car and a motorbike both have an engine, wheels and brakes but where as a motorbike has
                        handle bars a car has a steering wheel. This makes it difficult to use one object to represent both but rather than create two objects duplicating
                        much of the same functionality we can use the concept of inheritance. Here, first an parent object containing all the common traits is created
                        then separate child objects based on the parent are created, each adding just their own differences. Using the previous example we
                        could create a vehicle object that has the engine, brakes and wheels properties then from that create a motorbike object that adds handle bars
                        and a car object that adds a steering wheel. By having a common inherited wheels property the number of wheels can be set at runtime to 2
                        for a motorbike and 4 for car or even 3 if it is a three-wheeler.</p>

                    <p>Other names for parent are ancestor or superclass and for child, descendant or subclass. Just to be different, C# calls a parent a
                        base class and a child a derived class which is specifically mentioned here as C# provides the <code>base</code> keyword to access
                        a base class from a derived class. Also note that structs can neither inherit or be inherited by another class or struct.
                    </p>

                    <h3>Abstraction</h3>

                    <p>Abstraction is the process of determining and extracting from a complex problem just the information we require to define a solution. For example
                        what does it take to eat food. Here we need to ask an expert in this case lets consider what a child would say. They'd probably say something
                        like, you  put food in your mouth chew it then swallow. That's it. Now of course the human body is an extremely complex organism, to actually
                        eat food the brain has to send signals to the jaw muscles to chew the food, then to the tongue to swallow it. From there it goes into the stomach
                        where it is mixed with acid, then into the small intestine ... But for the purposes of survival all the user has to be concerned with is
                        food, mouth, chew, swallow. Of course had we omitted the chew step then the choke method may have kicked in resulting in a premature end to our
                        program. It is important then to extract exactly what is required, no less, no more and this is an essential design step before the first line
                        of code is even written.</p>

                    <p>Another term you may come across is abstraction layers which is the dividing of a problem into the various layers of complexity. Take for instance
                        what is involved in writing and running an application. As mentioned in the C Sharp Language section all a computer knows is ones and zeroes but
                        even that is not the lowest level. If we go further we get down to the quantum level where the state of electrons are controlled by transistors.
                        This is the hardware abstraction layer limited mainly to the manufacturer. Above the ones and zeroes, or binary abstraction layer, is the assembly
                        language which is a set of instructions in a pseudo human language provided by hardware manufacturers as to what the hardware does. This is
                        the language used by by those creating the compiler that translates the C# language we write into the binary language amd ultimately into the
                        quantum state of the hardware. This does not mean that someone writing in C# is completely separated from the other layers. For example as you
                        use the code editor the the compiler is constantly interpreting what you write and if it can't, it will warn you that there is a syntax
                        error.</p>

                    <h3>Polymorphism</h3>
<!-- TODO Rewrite -->
                    <p>Polymorphism is the ability to substitute any child object for its parent and the members they contain. Using the inheritance example, we want to
                        make sure that we can steer our vehicle so we provide a steer method. This presents a problem as we can't be sure whether the consumer is going
                        to buy a car or a motorbike. The car has a steering wheel property that has to be set whereas the motor bike has handle bars. Polymorphism allows
                        us to substitute what the steer method does in the child object. If we then have a purchasing object, that has a buy method that can take in
                        a vehicle object and when it is called, we can substitute the vehicle parent object for either car or motorbike child object. This way whichever
                        is provided will have the correct steer method.
                    </p>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Keywords -->
            <section class="main-section" id="Keywords_and_Specifications">
                <header><h2>Keywords and Specifications</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <h3>Keywords</h3>
                    <p>Keywords are words reserved for use by the compiler and cannot be used as identifiers unless prefixed with<code>@</code>.
                        It is advisable not to do so as there is the possibility of introducing errors.</p>
                    <h4>C# Reserved keywords</h4>
                    <p>These are keywords that are reserved throughout any part of a C# program</p>
                    <div class="four-column">
                        <!-- Column 1 -->
                        <div>
                            <a class="keyword-link" href="#Keywords">abstract</a>
                            <a class="keyword-link" href="#Keywords">as</a>
                            <a class="keyword-link" href="#Keywords">base</a>
                            <a class="keyword-link" href="#Keywords">bool</a>
                            <a class="keyword-link" href="#Keywords">break</a>
                            <a class="keyword-link" href="#Keywords">byte</a>
                            <a class="keyword-link" href="#Keywords">case</a>
                            <a class="keyword-link" href="#Keywords">catch</a>
                            <a class="keyword-link" href="#Keywords">char</a>
                            <a class="keyword-link" href="#Keywords">checked</a>
                            <a class="keyword-link" href="#Keywords">class</a>
                            <a class="keyword-link" href="#Keywords">const</a>
                            <a class="keyword-link" href="#Keywords">continue</a>
                            <a class="keyword-link" href="#Keywords">decimal</a>
                            <a class="keyword-link" href="#Keywords">default</a>
                            <a class="keyword-link" href="#Keywords">delegate</a>
                            <a class="keyword-link" href="#Keywords">do</a>
                            <a class="keyword-link" href="#Keywords">double</a>
                            <a class="keyword-link" href="#Keywords">else</a>
                            <a class="keyword-link" href="#Keywords">enum</a>
                        </div>
                        <!-- Column 2 -->
                        <div>
                            <a class="keyword-link" href="#Keywords">event</a>
                            <a class="keyword-link" href="#Keywords">explicit</a>
                            <a class="keyword-link" href="#Keywords">extern</a>
                            <a class="keyword-link" href="#Keywords">FALSE</a>
                            <a class="keyword-link" href="#Keywords">finally</a>
                            <a class="keyword-link" href="#Keywords">fixed</a>
                            <a class="keyword-link" href="#Keywords">float</a>
                            <a class="keyword-link" href="#Keywords">for</a>
                            <a class="keyword-link" href="#Keywords">foreach</a>
                            <a class="keyword-link" href="#Keywords">goto</a>
                            <a class="keyword-link" href="#Keywords">if</a>
                            <a class="keyword-link" href="#Keywords">implicit</a>
                            <a class="keyword-link" href="#Keywords">in</a>
                            <a class="keyword-link" href="#Keywords">int</a>
                            <a class="keyword-link" href="#Keywords">interface</a>
                            <a class="keyword-link" href="#Keywords">internal</a>
                            <a class="keyword-link" href="#Keywords">is</a>
                            <a class="keyword-link" href="#Keywords">lock</a>
                            <a class="keyword-link" href="#Keywords">long</a>
                        </div>
                        <!-- Column 3 -->
                        <div>
                            <a class="keyword-link" href="#Keywords">namespace</a>
                            <a class="keyword-link" href="#Keywords">new</a>
                            <a class="keyword-link" href="#Keywords">null</a>
                            <a class="keyword-link" href="#Keywords">object</a>
                            <a class="keyword-link" href="#Keywords">operator</a>
                            <a class="keyword-link" href="#Keywords">out</a>
                            <a class="keyword-link" href="#Keywords">override</a>
                            <a class="keyword-link" href="#Keywords">params</a>
                            <a class="keyword-link" href="#Keywords">private</a>
                            <a class="keyword-link" href="#Keywords">protected</a>
                            <a class="keyword-link" href="#Keywords">public</a>
                            <a class="keyword-link" href="#Keywords">readonly</a>
                            <a class="keyword-link" href="#Keywords">ref</a>
                            <a class="keyword-link" href="#Keywords">return</a>
                            <a class="keyword-link" href="#Keywords">sbyte</a>
                            <a class="keyword-link" href="#Keywords">sealed</a>
                            <a class="keyword-link" href="#Keywords">short</a>
                            <a class="keyword-link" href="#Keywords">sizeof</a>
                            <a class="keyword-link" href="#Keywords">stackalloc</a>
                        </div>
                        <!-- Column 4 -->
                        <div>
                            <a class="keyword-link" href="#Keywords">static</a>
                            <a class="keyword-link" href="#Keywords">string</a>
                            <a class="keyword-link" href="#Keywords">struct</a>
                            <a class="keyword-link" href="#Keywords">switch</a>
                            <a class="keyword-link" href="#Keywords">this</a>
                            <a class="keyword-link" href="#Keywords">throw</a>
                            <a class="keyword-link" href="#Keywords">TRUE</a>
                            <a class="keyword-link" href="#Keywords">try</a>
                            <a class="keyword-link" href="#Keywords">typeof</a>
                            <a class="keyword-link" href="#Keywords">uint</a>
                            <a class="keyword-link" href="#Keywords">ulong</a>
                            <a class="keyword-link" href="#Keywords">unchecked</a>
                            <a class="keyword-link" href="#Keywords">unsafe</a>
                            <a class="keyword-link" href="#Keywords">ushort</a>
                            <a class="keyword-link" href="#Keywords">using</a>
                            <a class="keyword-link" href="#Keywords">virtual</a>
                            <a class="keyword-link" href="#Keywords">void</a>
                            <a class="keyword-link" href="#Keywords">volatile</a>
                            <a class="keyword-link" href="#Keywords">while</a>
                        </div>
                    </div>
                    <h4>Contextual keywords</h4>
                    <p>These are keywords that are reserved in only limited context within the program.

                    </p>
                    <div class="four-column">
                        <!-- Column 1 -->
                        <div>
                            <a class="keyword-link" href="#Keywords">add</a>
                            <a class="keyword-link" href="#Keywords">and</a>
                            <a class="keyword-link" href="#Keywords">alias</a>
                            <a class="keyword-link" href="#Keywords">ascending</a>
                            <a class="keyword-link" href="#Keywords">async</a>
                            <a class="keyword-link" href="#Keywords">await</a>
                            <a class="keyword-link" href="#Keywords">by</a>
                            <a class="keyword-link" href="#Keywords">descending</a>
                            <a class="keyword-link" href="#Keywords">dynamic</a>
                            <a class="keyword-link" href="#Keywords">equals</a>
                            <a class="keyword-link" href="#Keywords">from</a>
                        </div>
                        <!-- Column 2 -->
                        <div>
                            <a class="keyword-link" href="#Keywords">get</a>
                            <a class="keyword-link" href="#Keywords">global</a>
                            <a class="keyword-link" href="#Keywords">group</a>
                            <a class="keyword-link" href="#Keywords">init</a>
                            <a class="keyword-link" href="#Keywords">into</a>
                            <a class="keyword-link" href="#Keywords">join</a>
                            <a class="keyword-link" href="#Keywords">let</a>
                            <a class="keyword-link" href="#Keywords">managed (function pointer calling convention)</a>
                            <a class="keyword-link" href="#Keywords">nameof</a>
                            <a class="keyword-link" href="#Keywords">nint</a>
                            <a class="keyword-link" href="#Keywords">not</a>
                        </div>
                        <!-- Column 3 -->
                        <div>
                            <a class="keyword-link" href="#Keywords">notnull</a>
                            <a class="keyword-link" href="#Keywords">nuint</a>
                            <a class="keyword-link" href="#Keywords">on</a>
                            <a class="keyword-link" href="#Keywords">or</a>
                            <a class="keyword-link" href="#Keywords">orderby</a>
                            <a class="keyword-link" href="#Keywords">partial (type)</a>
                            <a class="keyword-link" href="#Keywords">partial (method)</a>
                            <a class="keyword-link" href="#Keywords">record</a>
                            <a class="keyword-link" href="#Keywords">remove</a>
                            <a class="keyword-link" href="#Keywords">select</a>
                        </div>
                        <!-- Column 4 -->
                        <div>
                            <a class="keyword-link" href="#Keywords">set</a>
                            <a class="keyword-link" href="#Keywords">unmanaged (function pointer calling convention)</a>
                            <a class="keyword-link" href="#Keywords">unmanaged (generic type constraint)</a>
                            <a class="keyword-link" href="#Keywords">value</a>
                            <a class="keyword-link" href="#Keywords">var</a>
                            <a class="keyword-link" href="#Keywords">when (filter condition)</a>
                            <a class="keyword-link" href="#Keywords">where (generic type constraint)</a>
                            <a class="keyword-link" href="#Keywords">where (query clause)</a>
                            <a class="keyword-link" href="#Keywords">with</a>
                            <a class="keyword-link" href="#Keywords">yield</a>
                        </div>
                    </div>

                    <h3>C# Specifications</h3>
<!-- TODO Write specifications intro-->
                    <p></p>

                    <h4>Variable types, range and size</h4>

                    <p>Value types</p>
                    <ul>
                        <li>Boolean: <b>bool</b></li>
                        <li>Signed integer: <b>sbyte, short, int, long</b></li>
                        <li>Unsigned integer: <b>byte, ushort, uint, ulong</b></li>
                        <li>IEEE binary floating-point: <b>float, double</b></li>
                        <li>Decimal floating-point: <b>decimal</b></li>
                        <li>Unicode characters: <b>char</b></li>
                        <li>User-defined type of form enum E {...}</li>
                        <li>User defined type of form struct S {...}</li>
                        <li>Nullable value type: Extension of all other value types with a null value</li>
                    </ul>
                    <p>Reference types</p>
                    <ul>
                        <li>Class types</li>
                        <li>Ultimate base class of all other types: <b>object</b></li>
                        <li>Unicode strings: <b>string</b></li>
                        <li>User defined type of form class C {...}</li>
                        <li>User defined type of form interface I {...}</li>
                        <li>Array types: Single dimensional int[], multi-dimensional int[,]</li>
                        <li>User-defined type of form delegate int D(...)</li>
                    </ul>
                    <p>Simple type range and size</p>
                    <ul>
                        <li><span><b>bool</b> :</span> false, true (1 byte, 8 bits)</li>
                        <li><b>sbyte</b> : -128 to 127 (1 byte, 8 bits)</li>
                        <li><b>short</b> : -32,768 to 32,767 (2 bytes, 16 bits)</li>
                        <li><b>int</b> : -2,147,438,648 to 2,147,483,647 (4 bytes, 32 bits)</li>
                        <li><b>long</b> : -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (8 byte, 64 bits)</li>
                        <li><b>byte</b> : 0 to 255 (1 byte, 8 bits)</li>
                        <li><b>ushort</b> : -128 to 127 (2 byte, 16 bits)</li>
                        <li><b>uint</b> : 0 to 65,535 (4 byte, 32 bits)</li>
                        <li><b>ulong</b> : 0 to 18,446,744,073,709,551,615 (8 byte, 64 bits)</li>
                        <li><b>float</b> : 1.5 x 10-45 to 3.4 x 1038, 7-digit precision (4 byte, 32 bits)</li>
                        <li><b>double</b> : 5.0 x 10-324 to 1.7 x 10308, 15-digit precision (8 byte, 64 bits)</li>
                        <li><b>decimal</b> : 1.0 x 10-28 to  7.9 x 1028, 28-bit precision (16 byte, 128 bits)</li>
                    </ul>

                    <p>The default value for all integer and floating-point types is 0.</p>

                <p>A literal is interpreted by the compiler both by the way it is written and the context
                    in which it is used. A compile error will result if a literal is outside the range for
                    the type it is being assigned to.</p>

                <p>In the following</p>
<!-- Line space at bottom of code block is to prevent vertical scroll bar due to underline -->
<pre><code>byte b = 25; <span class="comment">// This is OK</span>
<u class="syntax">byte b = 311;</u> <span class="comment">// Compile error: Value '311' cannot be converted to a 'byte'.</span>

</code></pre>
                <p>Literals are interpreted as follows.</p>
                <p class="no-bottom-margin">Boolean literal, one of:</p>
                <p><b>true &emsp; false</b></p>
<pre><code>bool test = true;
bool test = false;
</code></pre>
                <p>Integer literals consist of combinations of the following.</p>
                <p class="no-bottom-margin">decimal digits:</p>
                <p><b>0 1 2 3 4 5 6 7 8 9</b></p>
                <p class="no-bottom-margin">hex digits:</p>
                <p><b>0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f</b></p>
                <p class="no-bottom-margin">unsigned, long and unsigned long identification suffix, one of:</p>
                <p><b>U  u  L  l  UL  Ul  uL  ul  LU  Lu  lU  lu</b></p>
                <p class="no-bottom-margin">sign prefix, one of:</p>
                <p><b>+ -</b></p>
                <p class="no-bottom-margin">hexadecimal identification prefix, one of:</p>
                <p><b>0x hex-digits&emsp;0X hex-digits</b></p>
                <p>Integer literals type are interpreted in the following order</p>
                <ul>
                    <li>No suffix : <b>int, uint, long, ulong</b></li>
                    <li>Suffixed with <b>U</b> or <b>u</b> : <b>uint, ulong</b></li>
                    <li>Suffixed with <b>L</b> or <b>l</b> : <b>long, ulong</b></li>
                    <li>Suffixed by <b>UL, Ul, uL, ul, LU, Lu, lU, lu</b> : <b>ulong</b></li>
                </ul>
                <p>Some examples of usage</p>
<pre><code>var a = 1; <span class="comment">// int</span>
var b = -2147483648; <span class="comment">// int</span>
var c = 2147483648; <span class="comment">// uint</span>
var d = -9223372036854775808; <span class="comment">// long</span>
var e = 9223372036854775808; <span class="comment">// ulong</span>
var f = 4294967295u; <span class="comment">// uint</span>
var g = 4294967296u; <span class="comment">// ulong</span>
var h = -1L; <span class="comment">// long</span>
var j = 9223372036854775807L; <span class="comment">// long</span>
var k = 9223372036854775808L; <span class="comment">// ulong</span>
var l = 1UL; <span class="comment">// ulong</span>
var hex = 0xF81A; <span class="comment">// int</span>
</code></pre>
                <p>A value outside of the range of the ulong type results in a compile error</p>
<pre><code>var tooBig = 18446744073709551616; <span class="comment">// compile error: Integral constant too large</span>
</code></pre>
                <p>Real literals consist of combinations of the following:</p>
                <p class="no-bottom-margin">decimal digits:</p>
                <p><b>0 1 2 3 4 5 6 7 8 9</b></p>
                <p class="no-bottom-margin">exponent part, one of:</p>
                <p><b>e sign decimal digits &emsp; E sign decimal digits</b></p>
                <p class="no-bottom-margin">sign prefix, one of:</p>
                <p><b>+ -</b></p>
                <p class="no-bottom-margin">real type suffix, one of:</p>
                <p><b>F  f  D  d  M  m</b></p>
                <p>Real literals are interpreted as follows</p>
                <ul>
                    <li>No suffix : <b>double</b></li>
                    <li>Suffixed with <b>F</b> or <b>f</b> : <b>float</b></li>
                    <li>Suffixed with <b>D</b> or <b>d</b> : <b>double</b></li>
                    <li>Suffixed with <b>M</b> or <b>m</b> : <b>decimal</b></li>
                </ul>
                <p><em>Note:</em> As per integer literals above a literal digit that is a whole number will be interpreted as an integer</p>
<pre><code>var i = 1; <span class="comment">// int</span>
</code></pre>
                <p>Literals interpreted as real numbers</p>
<pre><code>var a = 1.0; <span class="comment">//double</span>
var b = 2.3; <span class="comment">// double</span>
var c = 3e9; <span class="comment">// double</span>
var d = -2.1e-3; <span class="comment">// double</span>
var e = 1f; <span class="comment">// float</span>
var f = 2.3f; <span class="comment">// float</span>
var g = 3e9f; <span class="comment">// float</span>
var h = -2.1e-3f; <span class="comment">// float</span>
var j = 1d; <span class="comment">// double</span>
var k = 2.3d; <span class="comment">// double</span>
var l = 3e9d; <span class="comment">// double</span>
var m = -2.1e-3d; <span class="comment">// double</span>
var n = 1m; <span class="comment">// decimal</span>
var o = 2.3m; <span class="comment">// decimal</span>
var p = 3e9m; <span class="comment">// decimal</span>
var q = -2.1e-3m; <span class="comment">// decimal</span>
</code></pre>
                <h4>Character specifications</h4>
                <p>Single character, one of:</p>
                <p>any character except <code>'</code> <b>(U+0027)</b>, <code>\</code> <b>(U+005C)</b> or line character</p>
                <p>Simple escape character, one of:</p>
                <ul>
                    <li><b>\'</b>&emsp; Single quote</li>
                    <li><b>\"</b>&emsp; Double quote</li>
                    <li><b>\\</b>&emsp; Backslash</li>
                    <li><b>\0</b>&emsp; Null</li>
                    <li><b>\a</b>&emsp; Alert</li>
                    <li><b>\b</b>&emsp; Backspace</li>
                    <li><b>\f</b>&emsp; Form feed</li>
                    <li><b>\n</b>&emsp; New line</li>
                    <li><b>\r</b>&emsp; Carriage return</li>
                    <li><b>\t</b>&emsp; Horizontal tab</li>
                    <li><b>\v</b>&emsp; Vertical tab</li>
                </ul>
                <p class="no-bottom-margin">Unicode escape character, one of:</p>
                <p><b>\u0000</b> to <b>\uFFFF</b></p>
                <p class="no-bottom-margin">hexadecimal escape character:</p>
                <p><b>\x</b>&emsp; <em>Note:</em> Due to possible confusion with Unicode characters it is not recommended to
                    use <b>\x</b></p>
                <p>The default value is the NUL character \u0000</p>
                <p>Character literal examples</p>
<pre><code>var a = 'a' <span class="comment">\\ the <b>a</b> character</span>
var b = '\\' <span class="comment">\\ the <b>\</b> character</span>
var c = '\u0123' <span class="comment">\\ the <b>g</b> character</span>
</code></pre>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- Completed -->
            <!-- SECTION References -->
            <section class="main-section" id="References">
                <header><h2>References</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>
                        <a href="https://docs.microsoft.com/en-us/dotnet/csharp/"
                         rel="external nofollow noopener noreferrer" target="_blank">Microsoft C# reference documentation</a>
                    </p>
                    <p>
                        <a href="https://www.ecma-international.org/wp-content/uploads/ECMA-334_5th_edition_december_2017.pdf"
                         rel="external nofollow noopener noreferrer" target="_blank">ECMA-334 C# Language Specification</a>
                    </p>
                </article>
            </section>
            <!-- !SECTION -->

            <!-- SECTION Disclaimer -->
            <section class="main-section" id="Disclaimer">
                <header><h2>Disclaimer</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
            <!-- TODO add copyright -->
                <article>
                    <p>You accept all risk of using the website and content on the website. As far as the law allows, Stephen Ward provides the website as is,
                        without any warranty whatsoever.</p>

                        <p>The website may hyperlink to and integrate websites and services run by others. Stephen Ward does not make any warranty about services
                            run by others, or content they may provide. Use of services run by others may be governed by other terms between you and the one
                            running the service.</p>
                </article>
            </section>
            <!-- !SECTION -->

        </main>
<!-- TODO Uncomment freecodecamp script-->
        <!-- <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script> -->
    </body>
</html>