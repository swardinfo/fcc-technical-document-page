<!DOCTYPE html>
<html lang="en">
    <head>
        <!--meta-->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!--title-->
        <title>C# Documentation</title>
        <!-- favicons -->
        <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="theme-color" content="#ffffff">
        <!--css-->
        <link rel="stylesheet" href="css/style.css">
    </head>
    <body>
        <!-- SECTION Main menu -->
        <!-- project requirement - nav element with a corresponding id="navbar" -->
        <nav id="navbar">
            <!-- project requirement - navbar should contain one header element with text describing topic of technical documentation -->
            <!-- project requirement - header element in navbar must come before any link elements -->
            <header><h1>C# Guide</h1></header>
            <ul>
                <!-- project requirement - navbar contains link elements with class of nav-link, one for every element with class main-section -->
                <!-- project requirement - each nav-link element should contain text corresponding header text in each section -->
                <!-- project requirement - clicking nav-link element navigates page to the corresponding main-doc section -->
                <li><a class="nav-link" href="#Introduction">Introduction</a></li>
                <li><a class="nav-link" href="#Code_Syntax_and_Program_Execution">Code Syntax and Program Execution</a></li>
                <li><a class="nav-link" href="#Code_Writing_and_Debugging">Code Writing and Debugging</a></li>
                <li><a class="nav-link" href="#Errors_and_Exception_Handling">Errors and Exception Handling</a></li>
                <li><a class="nav-link" href="#Variables,_Constants,_Types_and_Literals">Variables, Constants, Types and Literals</a></li>
                <li><a class="nav-link" href="#Characters_and_Strings">Characters and Strings</a></li>
                <li><a class="nav-link" href="#Expressions_and_Operators">Expressions and Operators</a></li>
                <li><a class="nav-link" href="#Conditional_Statements">Conditional Statements</a></li>
                <li><a class="nav-link" href="#Iteration_Statements">Iteration Statements</a></li>
                <li><a class="nav-link" href="#Arrays_and_Data_Structures">Arrays and Data Structures</a></li>
                <li><a class="nav-link" href="#Enumerators_and_Tuples">Enumerators and Tuples</a></li>
                <li><a class="nav-link" href="#Classes_and_Other_User_Defined_Types">Classes and Other User Defined Types</a></li>
                <li><a class="nav-link" href="#Anonymous_functions">Anonymous functions</a></li>
                <li><a class="nav-link" href="#Dependencies_and_Namespaces">Dependencies and Namespaces</a></li>
                <li><a class="nav-link" href="#Scope_and_Modifiers">Scope and Modifiers</a></li>
                <li><a class="nav-link" href="#Object-oriented_Programming">Object-oriented Programming</a></li>
                <li><a class="nav-link" href="#Keywords_and_Specifications">Keywords and Specifications</a></li>
                <li><a class="nav-link" href="#References">References</a></li>
                <li><a class="nav-link" href="#Terms_and_Conditions">Terms and Conditions</a></li>
            </ul>
        </nav>
        <!-- !SECTION Main menu -->

        <!-- project requirement - main element with id="main-doc" -->
        <main id="main-doc">
            <!-- project requirement - several section elements, each with a class of main-section. There should be a minimum of 5 -->
            <!-- project requirement - section with class of main-section, id corresponds to header text, spaces replaced with underscores -->
<!-- TODO Remove under construction when finished -->
<!-- TODO check all menu selections are in from a > b > c wrapped in nowrap -->
<!-- TODO check all shortcuts are wrapped in nowrap -->
            <div class="under-construction">
                <p>Under Construction</p>
            </div>
            <!-- SECTION Introduction -->
            <section class="main-section" id="Introduction">
                <header><h2>Introduction</h2></header>
                <!-- project requirement -  first element in each .main-section is a header element which contains text that describes the topic -->
                <article>
                    <!-- project requirement - .main-section elements should contain at least 10 p elements total, not each -->
                    <p>The purpose of this guide is to give you an idea of what C# is about and the tools it provides for writing a program. What this is not is a step by
                        step guide into computer programming. Whilst someone with no programming skills may get some benefit, this guide it is aimed at those who have
                        experience with other languages and want to see what C# has to offer.</p>
                    <p>So what do you need to know. Firstly, developing a program in almost any programming language will require some basic maths skills, such as,
                        logical thinking, basic algebra, knowing the difference between integers and floating-point numbers, etc. You should also know how to install and
                        upgrade software and operating systems on a computer, and have an internet connection. It would also be useful to know some of the basics of how a
                        computer works such as CPU's, memory, file systems, etc.</p>
                    <p>Lastly and perhaps most importantly is theory of mind, what the user maybe thinking when they use your program. This should be a constant
                        consideration as you create your program. For example, entering a letter in a program when a number is required may be invalid. But having an
                        error message popup with each wrong keystroke that then needs to be cancelled...  This sort of user interface, (<i>UI</i>), will quickly lead to
                        frustration and result in your program ending up in the trash.</p>
                    <p>Throughout this guide, numerous links are provided to provide pathways to related information.</p>
                    <!-- SECTION The C# language -->
                    <h3 id="The_C_sharp_language">The C# language</h3>
                    <p>A written language is a system for using a combination of words and symbols to provide a means of communicating abstract ideas between two
                        entities. A computer language allows you to take abstractions from ideas and turn them into concrete implementations that can be interpreted by a
                        computer. As a developer, unless you only ever write software for yourself, your job is as a kind of ghost writer who uses a computer language to
                        tell someone else's story.</p>
                    <p>C# is a high level computer language, created by Microsoft and now maintained by the .NET Foundation as part of .NET, for the purpose of developing
                        computer programs. A computer uses binary, the language of ones and zeros. To put it at its simplest, all a computer can do is, like a light
                        switch, turn things on or off, albeit at billions of times a second. For any person trying to write in ones and zeros, this soon becomes an
                        impossible task. A high level programming language is a type of shorthand that is human readable making it easier for a developer to read and
                        write code.</p>
                    <!-- !SECTION The C# language -->
                    <!-- SECTION .NET -->
                    <h3 id="dot_NET">.NET</h3>
                    <p>.NET is an open-source, cross platform framework created by Microsoft, now maintained by the .NET Foundation and distributed under the MIT License.
                        It provides the <i>Common Language Runtime</i>(CLR) which will run our code and other services such as memory management, debugging, garbage
                        collection, etc, making our job of writing code easier. The phrase <i>during runtime</i>, is often used to refer to the time in which the code is
                        running.</p>
                    <p>.NET also provides a large quantity of pre written code we can use that provides many of the basic functions such as file I/O, network access,
                        collections, user interfaces, etc, so we don't have to write our own. Whenever a console, WinForms or WPF program is created the .NET is added to
                        the available frameworks by default and can be accessed through the System <a href="#Namespaces">namespace.</a></p>
                    <p> The .Net version used throughout this guide is 6.0 and the C# version is 10.0.</p>
                    <p>For more information on C# and .NET see the <a href="#References">Microsoft C# reference documentation</a></p>
                    <!-- !SECTION .NET -->
                    <!-- SECTION Integrated Development Environment -->
                    <h3 id="Integrated_Development_Environment">Integrated Development Environment</h3>
                    <p>An Integrated Development Environment or <i>IDE</i> is a program that contains various tools that assist the developer to write, run and test a
                        program. The IDE used in this guide is
                        <a href="https://visualstudio.microsoft.com/" rel="external nofollow noopener noreferrer" target="_blank"> Microsoft's Visual Studio 2022.</a>
                        While Visual Studio has many tools, the three most important are the:</p>
                    <ul>
                        <!-- project requirement -.main-section elements should contain at least 5 li items total, not each -->
                        <li><a href="#Code_editor">Code editor</a></li>
                        <li>Compiler</li>
                        <li><a href="#Debugger_and_breakpoints">Debugger</a></li>
                    </ul>
                    <p>The <a href="#Code_editor">code editor</a>, like a word processor, provides many tools that help in writing code. These include indication of
                        <a href="#Syntax_errors">syntax errors</a> shown with a <u class="error">red wavy underline</u> that may prevent the program from running, and
                        <a href="#Syntax_errors">warnings</a> shown with a <u class="warning">green wavy underline</u> that won't stop the program from running but should
                        be addressed. It also provides code auto completion, called IntelliSense in Visual Studio, that provides suggestions with documentation and
                        formatting tools that help keep the code consistent with coding conventions. The code editor also provides interactive help. After highlighting a
                        word or symbol in the code, pressing <b>F1</b> will open the <a href="#References">Microsoft C# reference documentation</a> to the appropriate
                        page.</p>
                    <p>The compiler is used by C# to convert the code the developer writes into the language the computer requires and using it is known as building the
                        program. On completion, the compiler will report if the result was successful or produce a list of errors that must be corrected before the code
                        can be run.</p>
                    <p>The debugger aids the developer in finding errors in the code. Not every program will be written perfectly first time and the errors that prevent
                        it from functioning correctly are known as bugs. If all you could do were to write, compile and run the program, then you would not have much to
                        go on. The debugger allows you to step through the code one line at a time to find the problem. This is known as running the program with the
                        debugger attached.</p>
                    <p>At the time of this writing there are three versions of Visual Studio.</p>
                    <ul>
                        <li>Community</li>
                        <li>Professional</li>
                        <li>Enterprise</li>
                    </ul>
                    <p>All examples in this document can be created and run on the community version, which can be downloaded and installed free for individual developers
                        for free or paid apps, from the
                        <a href="https://visualstudio.microsoft.com/" rel="external nofollow noopener noreferrer" target="_blank"> Visual Studio</a> web page. Use by
                        organizations is subject to conditions which can be found though the Visual Studio web page.</p>
                    <p><em>Note 1:</em> <i>This guide assumes that Visual Studio has already been installed, updated and the default settings have not been
                        changed. In particular it is assumed that the color theme is set to 'Light'. This can be set in the Options dialog under <b>Environment</b> &gt;
                        <b>General</b> &gt; <b>Visual Experience</b>. The Options dialog can be opened by selecting <b>Tools</b> &gt; <b>Options</b> in the main
                        menu.</i></p>
                    <p><em>Note 2:</em> <i>Whilst the code editor in Visual Studio provides color coding for different code elements, only the
                        <u class="error">red wavy underline</u> used to indicate <a href="#Syntax_errors">syntax errors</a> and
                        <u class="warning">green wavy underline</u> to indicate warnings will be shown in the code examples in this guide.</i></p>
                    <!-- !SECTION Integrated Development Environment -->
                    <!-- SECTION Create a Hello World Project -->
                    <h3 id="Create_a_Hello_World_Project">Create a Hello World Project</h3>
                    <p>To create a new project</p>
                    <ol>
                        <li>Start Visual Studio then click <b>Create a new project</b></li>
                        <li> On the <span class="nowrap"><b>Create a new project</b></span> page in the search box at the top type
                            <span class="nowrap"><b>console</b></span>.</li>
                        <li>A project template titled <span class="nowrap"><b>Console App</b></span> should appear at the top of the list. It
                            has an icon that looks like a document with C# in the top right corner. Select <span class="nowrap"><b>Console App</b></span> then
                            choose <b>Next</b> (Hint: if <span class="nowrap"><b>Console App</b></span> is not at the top, click <b>Clear all</b> and search
                            again)</li>
                        <li>On the <span class="nowrap"><b>Configure your new project</b></span> page type <b>HelloWorld</b>
                            in the <span class="nowrap"><b>Project name</b></span> box. Leave the <b>Location</b> and <span class="nowrap"><b>Solution name</b></span> as
                            filled in by the IDE and choose <b>Next</b></li>
                        <li>In the <span class="nowrap"><b>Additional information</b></span> page make sure <b>.NET6.0(Long-term support)</b> is selected in the
                            <i>Framework</i> dropdown selector then choose <b>Create</b></li>
                    </ol>
                    <p>The main window of the IDE opens with <i>Solution Explorer</i> open on the right and the code editor on the left. The <i>Program.cs</i> code file
                        should be open in the code editor with the code as per the following example. Not shown here are the line numbers in the left column visible in
                        the code editor. These are not part of the program and are purely for reference.</p>
<!-- Warning, pre and code tags require html to be formatted here which makes it look like crap in the code editor! -->
<pre><code>// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");
</code></pre>
                    <p>To run the program click on the <i>Start Debugging</i> button <span class="play-button"></span> in the toolbar or press <b>F5</b></p>
                    <p>The console, a <i>command window</i> in Windows, opens displaying the words <span class="nowrap"><b>'Hello World!'</b> .</span> Congratulations,
                        you have now created and run your first C# program. The remainder of the text tells you the program finished but the IDE has kept the console open
                        so that you can see the result. Press any key to close the console.</p>
                    <p>When you started debugging, the compiler built then ran the program with the debugger attached. The program runs or
                        <a href="#Program_execution">executes</a> all the instructions, known as <a href="#Code_Syntax">statements</a>, it finds within the code
                        file. As can be seen there are two lines of text in the example. The first is a comment as marked by the two forward slashes at the beginning of
                        the line. Comments are ignored by the compiler and do not form part of the running program. The second line,
                        <code>Console.WriteLine("Hello World!");</code>, is the only statement in the file. This tells the computer to write a line followed by a carriage
                        return to the command window. The text to be written is located within the round brackets <code>( )</code>, which in this case is
                        <span class="nowrap"><b>'Hello World!'</b></span>. As there are no further lines in our code before the closing brace <code>}</code>, the program
                        exits. At this point the window of a program would normally close but Visual Studio has an option to keep console windows open so that you can see
                        the results. This option is turned on by default.</p>
                    <p>The <b>Console App</b> template used in the example is new to Visual Studio 2022 and .NET 6.0 and can use
                        <a href="#Program_structure">top-level statements</a> which also hides some of the boiler plate code that is required by a C# program. The
                        remaining code examples guide will include the boiler plate code as demonstrated in the <a href="#Program_structure">Program structure</a>
                        section.</p>
                    <!-- !SECTION Create a Hello World Project -->
                </article>
            </section>
            <!-- !SECTION Introduction -->
            <!-- TODO complete Program execution code example -->
            <!-- SECTION Code Syntax and Program Execution -->
            <section class="main-section" id="Code_Syntax_and_Program_Execution">
                <header><h2>Code Syntax and Program Execution</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Some of the terms that will be mentioned in this section have not yet been covered and links are provided to their details. Consider this as a
                        reference to come back to as you become more familiar with them.</p>
                    <p><em>Note:</em> <i>All code examples in this guide use the <a href="#Create_a_Hello_World_Project">.NET 6 Console App</a> template in which both
                        <a href="#null">project wide nullable aware context</a> and <a href="#Importing_system_types">implicit global usings</a> are enabled.</i></p>
                    <!-- SECTION Program structure -->
                    <h3 id="Program_structure">Program structure</h3>
                    <p>A C# project may consist of multiple sources of code along with other resources such as media and text files which are then compiled to create an
                        <i>assembly</i>. This can be in the form of either a class library (.dll) which contains discrete units of code that can be individually used by
                        other projects or an executable (.exe) file that can be started and run directly. An application may consist of one or more of these.</p>
                    <p>In Visual Studio when a C# project is first created it creates a <i>Solution</i> that includes the project and other files required by the compiler
                        to build the assembly. These can be viewed in the <i>Solution Explorer</i> window which can be accessed via the <i>Solution Explorer</i> tab on
                        the right side of Visual Studio. If the tab is not visible, select <b>View</b> &gt; <b>Solution Explorer</b> in the main menu. The Solution
                        Explorer appears similar to that of tree view of the File Explorer. Under the Solution root node is listed each project and under these each of
                        the folders and files they contain. To a large extent, you can customize the folder and file locations to suit your own requirements. When the
                        compiler first builds a project, several other files are generated and then updated with each rebuild.</p>
                    <p>A C# source code file is a text file with the extension <i>.cs</i> and can be opened and edited in a code editor or even a basic text file editor.
                        A code editor is normally preferred as it can provide tools for displaying and formatting the code text with the correct program structure and
                        syntax. Whilst it is possible to create a program in which all code is contained in a single file, except for the simplest program, most consist
                        of multiple files in which the code from one will reference or be referenced from that in another. Most commonly a file will contain a single
                        <a href="#class">class.</a></p>
                    <p>The Visual Studio 2022 <i>Console App</i> template creates a project that allows the use of top-level statements. This removes some of the
                        <i>boiler plate</i> code required by a C# program and allows <a href="#Code_syntax">statements</a> to be entered directly into a file without it,
                        as demonstrated in the <a href="#Create_a_Hello_World_Project">Create a Hello World Project</a> example. The code is then implicitly generated
                        when the program is compiled and is inaccessible from the code editor. The example below shows how the code looks with the boiler plate code in
                        place with further details as to its meaning in the <a href="#Code_syntax">Code syntax</a> section. All executable programs must have an entry
                        point, which here is <code>static void Main(string[] args)</code>, which in most documentation is usually referred to just as the
                        <i>Main method</i>. There are several rules that it must follow but the main ones that are of concern are</p>
                    <ul>
                        <li>There can only be entry point within a program</li>
                        <li>It must be a method with the name <code>Main</code></li>
                        <li>It must be marked with the <a href="#static">static</a> modifier</li>
                    </ul>
                    <p>When a file has no top level statements and an explicit Main method as shown in the example, the compiler will use it as the single entry point. If
                        the file also has any top level statements, then the explicitly entered Main method will be ignored and the compiler will produce a warning of
                        this. When top-level statements are present they are contained within the hidden Main method implicitly created by the compiler. All code
                        preceding the Main method in the example are either <a href="#Code_syntax">directives</a> or <a href="#Code_syntax">declarations</a> so don't
                        create an issue.</p>
                    <p>Top level statements were designed for simple applications and supposedly making it easier to teaching someone new to C# without having to see the
                        boiler plate code. Realistically however, the vast majority of code you work with won't contain them so they won't be explored in this guide. For
                        more information on entry point requirements and top level statements please see the
                        <a href="#References">Microsoft C# reference documentation.</a></p>
<pre><code>using System;

namespace ProgramStructure
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
</code></pre>
                    <!-- !SECTION Program structure -->
                    <!-- NOTE Ignore all TODO in this section -->
                    <!-- SECTION Comments and Task Lists -->
                    <h3 id="Comments_and_Task_Lists">Comments and Task Lists</h3>
                    <p>Comments provide information to developers as to what the code does and can also aid in debugging.</p>
                    <p>The following example demonstrates the use of comments.</p>
                    <p>A comment can be in two forms, single line comments that start with two forward slashes <code>//</code> and extend to the end of the line or
                        delimited comments that start with a slash followed by an asterisk <code>/*</code>, end with an asterisk followed by a forward slash
                        <code>*/</code> and which can span multiple lines. For technical reasons that won't be detailed here, it is preferred to use multiple single line
                        rather than delimited comments and the code editor has tools that assist with this. Whilst a comment can be placed at the end a statement as
                        shown, this is not recommended.</p>
                    <p>As comments are ignored by the compiler when building the program, a technique often applied when debugging code is to <i>commented out</i> suspect
                        <a href="#Code_syntax">statements.</a></p>
                    <p>To comment out multiple lines, first select all the lines by placing the cursor in front of the first statement, then drag the mouse diagonally
                        down to the end of the last statement. Then while pressing <b>Ctrl</b> press and release <b>k</b> then
                        <span class="nowrap">press <b>c</b> .</span> To uncomment, again with all lines selected, while pressing <b>Ctrl</b> press and release <b>k</b>
                        then <span class="nowrap">press <b>u</b></span></p>
                    <p>The comment, <code>// TODO: This comment will be added to the tasks list</code>, is interpreted by the code editor as a task to
                        be added to the Task List. There are four predefined task tokens, <code>HACK</code>, <code>TODO</code>, <code>UNDONE</code>,
                        <code>UnresolvedMergeConflict</code> and custom tokens can also be added. Task tokens are not case sensitive. To see the task list, select
                        <span class="nowrap"><b>View</b> &gt; <b>Task List</b></span> in the main menu.</p>
                    <p><i>Documentation comments</i> provide information that is displayed by IntelliSense when entering code and can be applied to
                        <a href="#User_defined_types">user defined types</a> or the <a href="#Members">members</a> they contain. They are similar to single line comments
                        but instead start with three forward slashes <code>///</code> and can contain XML tags that provide special meaning to IntelliSense. Visual Studio
                        provides a shortcut for entering them; place the cursor immediately above the type or member then enter 3 forward slashes <code>///</code> and a
                        template of documentation comments with the appropriate XML tags will be inserted. Comments can then be entered within each tag which usually
                        includes a summary for a type and for a member, the return type and <a href="#Parameters,_signatures_and_overloading">parameters</a> if
                        applicable. The <code>GetFullName</code> <a href="#Methods">method</a> at the end of the example illustrates how a typical block of documentation
                        comments appear. Additional XML tags and attributes can be entered such as <code>cref</code> as shown in the example. For more information on
                        these please see the <a href="#References">Microsoft C# reference documentation.</a></p>
<pre><code>namespace Comments
{
    class Program
    {
        static void Main(string[] args)
        {
            // This is a single line comment
            string s = "Hello World!"; // This starts after the statement

            /*
                this is
                    a multi-line comment
                */
            // this is a better way
            // to do a multi-line comment

            // Program execution can be temporarily changed in
            // order to debug and determine where a fault may lie.
            // The following statement will be ignored when the program runs
            // suspectedError++;

            // See the description in the main text on how to comment out
            // multiple lines of code such as the following 3 lines
            Console.WriteLine(s);
            Console.WriteLine(s);
            Console.WriteLine(s);

            // TODO: This comment will be added to the tasks list
        }

        /// &lt;summary&gt;
        /// Returns a &lt;see cref= "string" /&gt; of the full name of a person
        /// &lt;/summary&gt;
        /// &lt;param name = "firstName" &gt; The first name of the person&lt;/param&gt;
        /// &lt;param name = "lastName" &gt; The last name of the person&lt;/param&gt;
        /// &lt;returns&gt;The full name of the person&lt;/returns&gt;
        static string GetFullName(string firstName, string lastName) =&gt; $"{firstName} {lastName}";
    }
}
</code></pre>
                    <!-- !SECTION Comments and Task Lists -->
                    <!-- SECTION Code syntax -->
                    <h3 id="Code_syntax">Code syntax</h3>
                    <p>C# consists of text and symbols, each of which tells the compiler how to convert our code into a program. The <i>syntax</i> is the set of rules that
                        governs how our code must be put together, i.e. which word or symbol goes where. Together these words and symbols are combined to form statements,
                        declarations and directives that are the instructions used to create a C# program.</p>
                    <p>First a quick look at the structure of the code which we'll go to into detail throughout this guide. In general, a program takes the form of a list
                        of instructions with one per line, though C# allows for an instruction to span multiple lines if required. C# also allows for multiple
                        instructions to be enclosed within a pair of braces <code>{ }</code> called a <i>code block</i>. A code
                        block can be empty or it can contain any combination of statements, declarations, directives, comments and other code blocks. Each instruction,
                        depending on its type, must be followed by either a code block, a semicolon <code>;</code> or a carriage return. The compiler ignores comments and
                        whitespace other than as separators for words and symbols.</p>
                    <p>A statement is the part of the code that becomes the instructions that tells the computer what to do. The program runs or
                        <a href="#Program_Execution">executes</a> statements as they appear, top to bottom, unless a statement redirects execution to another part of the
                        program. A declaration instructs the compiler to create a placeholder for an <a href="#Object">object</a> that is to exist and become part of the
                        program. In some cases, a declaration can also be a statement. Before an object can be used, if it is a
                        <a href="#Variables,_Constants,_Types_and_Literals">value type</a> it must be initialized or if it is a
                        <a href="#Variables,_Constants,_Types_and_Literals">reference type</a> it must be created, also known as being <i>instantiated</i>. A directive is
                        an instruction for the compiler that while not directly part of our program will affect how our program will be built and run.</p>
                    <p>There are varying conventions on how to format code. These don't affect how the program runs and are purely for human readability. One such
                        convention used throughout this guide is to place code blocks containing statements directly under the beginning of the statement they belong to
                        and indent everything within them. An empty code block may be placed on the same line after the statement. The IDE has tools to aid with code
                        formatting styles such as these.</p>
                    <p>The first example doesn't contain too much code and when run, simply opens the console and nothing more. There's still a lot going on here so let's
                        break it down.</p>
                    <p>The line <code>using System;</code> is a using directive and must always end with a <span class="nowrap">semicolon <code>;</code> .</span> The
                        first word <code>using</code> is a reserved word called a <i>keyword</i> in C#. <a href="#Keywords_and_Specifications">Keywords</a> are directly
                        used by the compiler as instructions. The next word <code>System</code> is an <i>identifier</i>. Identifiers are used to name types such as
                        <a href="#class">classes</a>, <a href="#interface">interfaces</a>, <a href="#struct">structs</a>, <a href="#record">records</a>,
                        <a href="#Anonymous_functions">delegates, </a> <a href="#Enumerators">enums</a>, <a href="#Tuple">tuples</a>, a type's
                        <a href="#Members">members</a>, as well as <a href="#Variables,_Constants,_Types_and_Literals">variables</a> and
                        <a href="#Namespaces">namespaces.</a></p> <p><em>Note:</em><i> As with many C# reference texts the words <b>name</b> and <b>identifier</b> are
                            used interchangeably throughout this guide.</i></p>
                    <p>The rules for identifiers are</p>
                    <ul>
                        <li>Identifiers must begin with a letter or the <code>_</code> character</li>
                        <li>Identifiers can only contain letters, numbers or the <code>_</code> character</li>
                        <li>Identifiers shouldn't contain two or more consecutive <code>_</code> characters as these are reserved for
                            compiler generated identifiers</li>
                        <li>Identifiers are case sensitive</li>
                        <li>Identifiers can only be declared once within the same <a href="#Scope">scope</a></li>
                        <li>A keyword can't be used as an identifier</li>
                    </ul>
                    <p>By being case sensitive it is valid for two identifiers to differ by case only, e.g., <code><b>n</b>ame</code> and <code><b>N</b>ame</code> are two
                        different identifiers.</p>
                    <p>More recently, C# has introduced the discard variable which is used when the output of an <a href="#Expressions_and_Operators">expression</a> is
                        not required. This is an advanced subject that won't be discussed in this guide but is mentioned here for completeness. The identifier for the
                        discard variable is the <code>_</code> character by itself. Unlike other variables, multiple discard variable identifiers can be declared within
                        the same scope.</p>
                    <p><code>namespace SyntaxExample1</code> is a <a href="#namespace">namespace declaration.</a> Namespaces are used to organize types into logical
                        groups. The <a href="#using_and_importing_types">using directive</a> instructs the compiler to import a namespace and the types it contains.
                        Following the namespace declaration is an opening brace <code>{</code> which signifies the beginning of a code block and its closing brace
                        <code>}</code> is the last line in the example. All code blocks must have an opening and closing brace. Nested within this code block is a
                        <a href="#class">class</a> as declared by <code>public class Program</code> and its associated code block. The <code>public</code> keyword is an
                        <a href="#Access_modifiers">access modifier.</a></p>
                    <p>Nested within the class is a <a href="#Methods">method</a> declaration <code>static void Main(string[] args)</code> and its code block. The
                        <code>static</code> keyword is a <a href="#static">modifier</a> keyword that modifies the behavior of another keyword that it adjoins and
                        <code>void</code> declares that the method does not return a value. Following the method's identifier <code>Main</code>,
                        <code>(string[] args)</code> defines a <a href="#string">string</a> type <a href="#Parameters,_signatures_and_overloading">parameter</a> with the
                        identifier <code>args</code> that is passed into the method. The <a href="#Index_operator">index operator</a> <code>[]</code> declares that the
                        parameter is an <a href="#Array">array</a> which can contain multiple values of the same type. A method can have multiple parameters in the form
                        of a comma separated list and a class can have multiple methods, known as <a href="#Parameters,_signatures_and_overloading">overloads</a>, that
                        have the same identifier but differ by the number and/or type of parameters.</p>
                    <p>In addition to the naming rules above, there are various naming conventions that can be followed and you are encouraged to research these.
                        Ultimately it is up to you or the company you work for to define these but of most importance is that you are consistent throughout your
                        applications. One note, avoid having a class with the same identifier as a namespace as this can lead to confusion and possible
                        <i>naming conflicts</i>.</p>
                    <p>There may also be situations where using a specific identifier may result in a naming conflict with an identifier of a built-in type. In
                        particular all types, even those you define yourself, are provided by .NET with a number of standard <a href="#Members">members.</a> Unless these
                        are specifically being <a href="#override">overridden</a> the identifiers, <code>Equals</code>, <code>GetHashCode</code>, <code>GetType</code> and
                        <code>ToString</code> should be avoided.</p>
<pre><code>// using directive.
using System;

// namespace declaration.
namespace CodeSyntaxExample1
{
    // class declaration.
    public class Program
    {
        // Method declaration.
        static void Main(string[] args)
        {
        }
    }
}
</code></pre>
                    <p>New to .NET 6 are <a href="#Importing_system_types">implicit global usings.</a> This option adds a number of
                        <a href="#using_and_importing_types">global using</a> directives to import various namespaces appropriate to the type of project. It is turned on
                        by default in the .NET 6 <a href="#Create_a_Hello_World_Project">Console App</a> new project template. As with top level statements, implicit
                        global usings are in a hidden file and are unavailable in the code editor. Throughout the remainder of this guide, it will be assumed that
                        implicit global usings is enabled and unless pertinent to a code example, the hidden using statements will not be shown. For a list of all the
                        hidden using statements for the .NET 6 Console App, please see <a href="#Importing_system_types">importing system types.</a></p>
                    <p>In the next example, <code>Console.WriteLine("Hello World!");</code> , a single line statement, is the first in the
                        Main method code block. In this context, the dot <code>.</code> between <code>Console</code> and
                        <code>WriteLine ("Hello World")</code> is called the <a href="#Member_access_operator">member access operator.</a> It allows access to a
                        <a href="">member</a>, here a <a href="#Methods">method</a> called <code>WriteLine</code> in a class called
                        <span class="nowrap"><code>Console</code>.</span> The round brackets <code>( )</code> allow
                        <a href="#Parameters,_signatures_and_overloading">arguments</a> to be passed to the parameters of a
                        <a href="#Program_execution">called method</a>. Here the
                        <a href="#string">string</a> <a href="#Variables,_Constants,_Types_and_Literals">literal</a> <code>"Hello World!"</code> is being passed into the
                        <a href="#null">nullable</a> <code>string?</code> parameter <span class="nowrap"><code>value</code>.</span> All single line statements must end
                        with a semicolon <code>;</code></p>
                    <p>When writing the code for <a href="#Program_execution">calling a method</a>, IntelliSense will provide <a href="#Code_editor">assistance in the
                        code editor</a> with entering the arguments for the method's <a href="#Parameters,_signatures_and_overloading">signature.</a></p>
                    <p>Visual Studio has a number of built-in <i>code snippets</i> that allows you to use shortcuts to enter frequently used code. One such snippet is for
                        <span class="nowrap"><code>Console.WriteLine();</code>.</span> To use the shortcut type <b>c</b> then <b>w</b> then press the <b>tab</b> key
                        twice. In addition to the in-built snippets, you can add your own. For more information on the built-in snippets and how to create a user snippet,
                        please see the <a href="#References">Microsoft C# reference documentation.</a></p>
                    <p>Following are three further examples of single line statements showing how <a href="#Variables,_Constants,_Types_and_Literals">variables</a> can be
                        declared and assigned values.</p>
                    <p> The <code>while (true)</code> statement also called a <a href="#while_statement">while</a> loop, together with the braces and enclosed code form a
                        code block. No semicolon is required after the closing brace. Within the code block is an assignment statement, followed by a <code>break</code>
                        statement followed by another assignment statement. As the <a href="#break">break</a> statement causes the program to leave the while loop before
                        reaching the second assignment statement, it can't be executed and is known as unreachable code. This won't prevent the program from being built
                        or run but will result in a warning in the code editor and should be rectified.</p>
                    <p>Next are three <code>if</code> statements which are <a href="#Conditional_Statements">conditional statements.</a> Some statements like these allow
                        for a single statement known as an embedded statement, to be placed directly after it without the need for braces. The second <code>if</code>
                        statement followed directly by <code>k = 1;</code> demonstrate this. Together they form a compound statement so the first two <code>if</code>
                        statements here are equivalent. An embedded statement cannot be a declaration or labelled statement so the last <code>if</code> statement example
                        is invalid and uncommenting it results in a <a href="#Syntax_errors">syntax error.</a></p>
                    <p>Two more warnings are present in the code. Variables <code>i</code> and <code>j</code> are
                        assigned values but they are not used anywhere in the code which results in a warning for each. As such declarations and assignments
                        are common so are the warnings and as decisions change while the code is written, it is possible that orphan variables can be left scattered
                        throughout. It is important then that periodic reviews are made and unused code removed before such warnings become unmanageable. Note that while
                        variables <code>a</code> and <code>i</code> both appear in the if statements, <code>a</code> is used to test them so does not produce a warning
                        whereas <code>i</code> is only assigned a value.</p>
<pre><code>namespace CodeSyntaxExample2
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // Single statement.
            Console.WriteLine("Hello World!");

            // Single statements, declaring and assigning variables.
            bool a;
            a = true;
            int i = 0;
            int j = 0;


            // while statement with code block.
            while (true)
            {
                i = 1;
                break;
                // Unreachable code.
                j = 2;
            }

            // These two 'if' statements are equivalent.
            if (a)
            {
                i = 1;
            }

            if (a)
                i = 1; // Embedded statement.

            //if (a)
            //    var y = 1; // Syntax error, embedded statement cannot be a declaration.
        }
    }
}

// The example writes the following to the console
// Hello World!
</code></pre>
                    <p>The following example contains two <a href="#class">class</a> declarations within the CodeSyntaxExample3 namespace. The first is called MyClass
                        followed by Program. MyClass contains declarations for several <a href="#Members">members</a> including an empty
                        <a href="#Constructors">constructor</a>, an <a href="#Variables,_Constants,_Types_and_Literals">int</a> type <a href="#Properties">property</a>
                        called Property, a <a href="#Methods">method</a> called Square and a second method called Cube that employs an
                        <a href="#The_lambda_and_expression-body_definition_operator">expression body.</a></p>
                    <p>The compiler ignores line breaks, tabs and whitespace, so a statement can span multiple lines as it's the semicolon that instructs the compiler
                        where the end of the statement is. In the Program class, the <code>Console.WriteLine ("Hello World");</code> statement has been rearranged to span
                        five lines but is still valid code. The result however is quite poor for human readability and coding format conventions should be followed to
                        avoid this. As with naming conventions it is up to you or the company you work for to define these but of most importance is that you are
                        consistent throughout your applications. For the remainder of this guide, <i>statement</i> will refer to a statement that ends with a semicolon,
                        even if that statement spans multiple lines.</p>
                    <p>Following is a verbatim <a href="#string">string</a> literal. Regular string literals such as "Hello World!" can't contain line breaks so C# has
                        verbatim string literals prefixed with an <code>@</code> symbol that can. The result here is that "Hello World!" is written on two lines in the
                        console.</p>
                    <p>The <code>new</code> keyword must be used to instantiate a <a href="#Variables,_Constants,_Types_and_Literals">reference type.</a> When this occurs
                        the type's constructor is called to initialize the object that is created. Depending on the access level of a type's member, they can also be
                        initialized through an object initializer.</p>
<pre><code>namespace CodeSyntaxExample3
{
    // Declare a second class within CodeSyntaxExample3 namespace.
    public class MyClass
    {
        // Constructor declaration with empty code block.
        public MyClass() { }

        // Declare a property.
        public int Property { get; set; }

        // Declare a method.
        public int Square(int x)
        {
            return x * x;
        }

        // Declare a method using an expression body.
        public int Cube(int x) =&gt; x * x * x;
    }

    internal class Program
    {
        static void Main(string[] args)
        {
            // The  Console.WriteLine("Hello World!"); rearranged.
            // Whilst this is a valid statement human readability is poor.
            Console
                .
                    WriteLine

                ("Hello World")
                                ;  // The semicolon here determines the end of the statement.

            // OK string statement, can put line break in verbatim string.
            Console.WriteLine(@"Hello
World!");

            // Creating or instantiating an object using a constructor.
            MyClass class1 = new();

            // Creating or instantiating an object using a constructor
            // and assign a value to Property in an object initializer.
            MyClass class2 = new()
            {
                Property = 1
            };

        }
    }
}

// The example writes the following to the screen
// Hello World
// Hello
// World!
</code></pre>
                    <p>The following examples demonstrate invalid code that generates syntax errors as indicated by <u class="error">red wavy underlines</u>.</p>
                    <p><a href="#keywords">Keywords</a> and identifiers can't contain whitespace or line breaks as shown by the first two statements.</p>
                    <p>Regular <a href="#string">string</a> literals such as "Hello World!" can't contain line breaks as shown in the last statement.</p>
<pre><code>namespace CodeSyntaxExample4
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // Invalid statement, can't put space in keyword.
            <u class="error">Con</u> sole.<u class="error">WriteLine</u>("Hello World");

            // Invalid statement, can't put line break in keyword.
            <u class="error">Con</u>
                <u class="error">sole</u>.WriteLine("Hello World");

            // Invalid string statement, can't put line break in regular string.
            Console.WriteLine(<u class="error">"</u>Hello<u class="error"> </u>
                                <u class="error">World</u>!<u class="error">");</u>
        }
    }
}
</code></pre>
                    <!-- !SECTION Code syntax -->
                    <!-- TODO complete Program execution code example -->
                    <!-- SECTION Program execution -->
                    <h3 id="Program_execution">Program execution</h3>
                    <p>When a <a href="#Code_syntax">statement</a> is run it is said to be executed. Normal program execution starts with the first and ends after the
                        last statement has been executed in the <a href="#Program_structure">Main method</a>
                        <span class="nowrap"><a href="#Code_syntax">code block.</a></span> Abnormal execution can result in the program exiting prematurely or becoming
                        unresponsive.</p>
                    <p>Within a code block, statements are executed from top to bottom. If the statement is a <a href="#Conditional_Statements">conditional statement</a>,
                        alternate paths will be introduced in which one will be chosen dependent on the condition for that path being true. If an
                        <a href="#Iteration_Statements">iterative statement</a>, the statements it contains will be repeatedly executed until a condition is met that
                        allows execution to <a href="#break">break</a> out of the loop. A statement can also pass execution on to another
                        <a href="#Methods">method</a> known as <i>calling</i> or <i>invoking</i>, with the statement known as a <i>method call</i> and the method that
                        contains it known as the <i>calling method</i> or simply the <i>caller</i>. The <i>invoked</i> or <i>called</i> method is said to be <i>nested</i>
                        within the caller. In normal circumstances, execution is returned to the method call through a return statement if the method returns a value or
                        if the called method returns <code>void</code>, a return statement or the end of the method is reached. Program execution can continually call and
                        be returned from methods until the last statement in the Main method has been executed where, assuming there have been no errors, the program
                        exits normally.</p>
                    <p>A method call is in the form of <code>instance.Method(parameters)</code> for an instance of a type and <code>TypeName.Method(parameters)</code>
                        for a <a href="#static">static</a> type. To call an instance method an object must first be instantiated from the type that contains it. All
                        <a href="">statements</a> in C# programs are executed with respect to a <a href="#Methods">method.</a> For example, a
                        <a href="#Properties">property</a> is a method with a special syntax and an <a href="#Events">event</a> merely calls a
                        <a href="#delegate">delegate</a> to a method that acts as the event handler.</p>
                    <p>The <a href="#dot_NET">CLR</a> handles method calls by using a <i>stack</i> which in this context is known as the
                        <span class="nowrap"><i>call stack</i>.</span> This can be thought of as a stack of paper where each sheet represents a method. When a method is
                        called it is placed on top, known as <i>pushed</i>, and its statements are executed until returned to the caller. The returning method is then
                        removed, known as <i>popped</i>, and execution resumes with the method call. In computer science a stack is implemented using a
                        <i>Last In First Out</i> memory structure or <span class="nowrap"><i>LIFO</i>.</span> How the return from a called method is treated depends on
                        whether the method returns a value and which of the following is encountered.</p>
                    <ul>
                        <li>A return statement is executed.</li>
                        <li>The end of the method is reached.</li>
                        <li>An <span class="nowrap"><a href="#Exceptions">exception is thrown.</a></span></li>
                        <li>An Exit statement is executed.</li>
                    </ul>
                    <p>If a method returns a value, then a return statement must be present for all possible return paths. Reaching the end of the method without
                        encountering one will result in a syntax error and the program won't compile. Here the return statement takes the form of <code>return T</code>
                        where T is literal or <a href="#Variables,_Constants,_Types_and_Literals">variable</a> of the return type declared in the method's
                        <span class="nowrap"><a href="#Methods">header.</a></span> If a method does not return a value, i.e. the return type is <code>void</code>, then
                        execution will be returned to the caller when either a return statement or the end of the method is reached. In this case the method can contain
                        any number of return statements including none, with the return statement taking the form of <span class="nowrap"><code>return;</code>.</span></p>
                    <p>If an exception is thrown, further execution is halted and the methods are popped off the call stack until one containing a
                        <a href="#try-catch">catch block</a> to handle the exception is reached. If one is not found, the program will exit resulting in an unhandled
                        exception. If a call to an <code>Exit</code> method is encountered the program exits immediately without returning to the caller.
                        <code>Exit</code> can be used in a conditional statement that tests if the program has an error that has put it into a non-recoverable state. This
                        way, along with other code, <code>Exit</code> can allow for the program to exit gracefully. For a
                        <a href="#Create_a_Hello_World_Project">Console App</a> <code>Exit</code> is in the <code>Environment</code> <a href="#Namespaces">namespace</a> so
                        the <a href="#Namespaces">fully qualified</a> name is <span class="nowrap"><code>Environment.Exit</code>.</span></p>
                    <p>Without intervention a program will simply run its course and exit. To prevent this and allow for user input, a pattern often employed is to use an
                        infinite loop containing a conditional statement that upon detecting a specific character, breaks out of the loop then executes the remaining
                        statements as normal. Care must be taken however, because if the condition cannot be met, the loop cannot be broken and the program will become
                        unresponsive requiring the user to manually force the program to quit.</p>
                    <p>The Console type provides such a loop in the method <span class="nowrap"><code>Console.ReadLine</code>.</span> When executed, this method waits for
                        input from the user, writing each <a href="#character">character</a> to the console as it's typed. Depending on the operating system, when the
                        return key is pressed, this will produce a carriage return, new line or a combination of both. If any of these are encountered, execution is
                        returned to the caller with a <a href="#string">string</a> value containing the characters entered.</p>
                    <p>A computer has a finite amount of memory and if totally consumed this could result in the operating system crashing. As this could occur from too
                        many nested method calls, the CLR will protect the system by throwing a <span class="nowrap"><code>StackOverflowException</code>.</span> One
                        notable cause for this is a pattern called a recursive algorithm where a method calls itself. If no safeguards are put in place the stack is
                        filled with calls to the method until it overflows.</p>
                    <p><em>Note:</em> <i> A <code>StackOverflowException</code> can't be caught in a try-catch so it is important that careful consideration be made when
                        utilizing such patterns.</i></p>
                    <p>CodeExample</p>
<pre><code>namespace Namespace
{
    class Program
    {
        static void Main()
        {

        }
    }
}
</code></pre>
                    <!-- !SECTION Program execution -->
                </article>
            </section>
            <!-- !SECTION Code Syntax and Program Execution -->
            <!-- TODO complete Code Writing and Debugging -->
            <!-- SECTION Code Writing and Debugging -->
            <section class="main-section" id="Code_Writing_and_Debugging">
                <header><h2>Code Writing and Debugging</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION Code editor -->
                    <h4 id="Code_editor">Code editor</h4>
                    <p>The <a href="#Program_structure">program structure</a> of a C# application consists of one or more code files that can be browsed in the
                        <a href="#Program_structure">Solution Explorer.</a> These can be opened in the <i>Code Editor</i> which provides many tools to assist in writing
                        and <a href="#Debugging">debugging</a> code such as code formatting and <i>IntelliSense,</i> which provides autocompletion options you can choose
                        from as you enter your code. For example, when entering the code for <a href="#Program_execution">calling a method</a>, as you type the opening
                        round bracket <code>(</code>, IntelliSense will display a panel with the <a href="#Parameters,_signatures_and_overloading">signature</a> for the
                        <a href="#Methods">method</a>. This includes the required and optional <a href="#Parameters,_signatures_and_overloading">parameters</a> and a
                        description of what the method does as well as each parameter as they are entered. If there are
                        <a href="#Parameters,_signatures_and_overloading">overloads</a> for the method, the number available and up/down arrows will be displayed allowing
                        you to cycle through and find the correct one. Additionally, a scrollable list will be displayed showing the possible arguments that can be
                        entered. If <a href="#Variables,_Constants,_Types_and_Literals">variables</a> or parameters from the containing method have been previously
                        declared, they will appear at the top of the list, which in the following example includes <code>args</code> from
                        <span class="nowrap"><code>Main(string[] args)</code>.</span> To view all overloads after the statement has been written, place the cursor
                        anywhere within the round brackets and press <span class="nowrap"><b>Ctrl + Shift + Space</b></span>, then use the arrow keys to navigate to each
                        argument to see the description for the associated parameter. To view the argument list, place the cursor just before any argument and press
                        <span class="nowrap"><b>Ctrl + Space</b></span></p>
                    <p>Popup help information is provided when hovering over types or <a href="#Code_syntax">identifiers</a>. In the example below, hovering over
                        <code>string</code> will result in the following popup dialog about the <a href="#string">string</a> type.</p>
<pre><code>class System.String

Represents text as a sequence of UTF-16 code units.
</code></pre>
                    <p>To aid in debugging, the code editor highlights <a href="#Syntax_errors">syntax errors</a> that prevent the program from compiling with a
                        <u class="error">red wavy underline</u>. It also provides <a href="#Syntax_errors">warnings</a> of code that won't prevent the program from
                        compiling but can cause issues during runtime and need to be addressed. These are highlighted with a <u class="warning">green wavy underline</u>.
                        Information on each error and warning can be found as an entry in the <i>Error List,</i> usually located at the bottom of the code editor. After
                        selecting an entry, you can display help information by either clicking the error number or pressing <b>F1</b>, which in most cases will be a help
                        page on the <a href="#References">Microsoft C# reference documentation</a> website. Double clicking an entry or by selecting it and pressing
                        <b>Enter</b> will move the cursor to the associated statement, opening its containing code file if necessary. The error list also provides various
                        filters, sorting and search ability to narrow down specific entries. To view the error list, you may need to click on the  <b>Error List</b> tab
                        or if it is not displayed, open it by select <span class="nowrap"><b>View</b> &gt; <b>Error List</b></span> in the main menu.</p>
                    <p>In the following example, the identifier <code>WriteLine</code> has been misspelt in the statement <code>Console.WriteLin("Hello World!")</code>
                        resulting in the syntax error as shown. The statement <code>int x = 1</code> results in two warnings with both <code>int</code> and <code>i</code>
                        being underlined, due to the statement appearing after a return statement and the variable <code>x</code> not being used.</p>
<pre><code>namespace CodeEditorErrors
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.<u class="error">WriteLin</u>("Hello World!");
            return;
            <u class="warning">int</u> <u class="warning">x</u> = 1;
        }
    }
}
</code></pre>
                    <p>In the error list the following is displayed.</p>
<pre><code><span class="nowrap"><span class="code-link">CS0117</span> 'Console' does not contain a definition for 'WriteLin'</span>
<span class="nowrap"><span class="code-link">CS0162</span> Unreachable code detected</span>
<span class="nowrap"><span class="code-link">CS0219</span> The variable 'x' is assigned but its value is never used</span>
</code></pre>
                    <p>By hovering the mouse over the underlined code, a popup dialog will provide information on the problem, usually with a link indicating the error
                        number. As with the error list, clicking this opens the help information. After a short pause, the dialog may also provide a
                        <i>'Show potential fixes'</i> link that can be opened by clicking it or by using the shortcut <span class="nowrap"><b>Alt + Enter</b></span> When
                        opened, a list of fixes is shown and when hovering over each of these, another popup showing the suggested change is displayed.</p>
                    <p>By hovering over the syntax error in the above example the following popup dialog will be displayed.</p>
<pre><code><span class="code-link">CS0117</span>: 'Console' does not contain a definition for 'WriteLin'

<span class="code-link">Show potential fixes</span> (Alt+Enter or Ctrl+.)
</code></pre>
                    <p>Pressing <span class="nowrap"><b>Alt + Enter</b></span> reveals only one solution, <code>Change 'WriteLin' to 'WriteLine'.</code>. Pressing
                    <b>Enter</b> accepts the change and the syntax error is resolved.</p>
                    <p>By hovering over <code><u class="warning">int</u></code> warning we get</p>
<pre><code>readonly struct System.Int32
Represents a 32-bit signed integer.

<span class="code-link">CS0162</span> Unreachable code detected

<span class="code-link">Show potential fixes</span> (Alt+Enter or Ctrl+.)
</code></pre>
                    <p>Two solutions are presented for this warning, the first is to remove the statement and the second to suppress the warning. In this case it's
                        decided that neither are what will be required for the code that is yet to be written and that the real solution is to remove the
                        <code>return</code> statement. As you can see, whilst IntelliSense can provide a number of potentially useful solutions, it can't mind read your
                        intent so it is up to you to make the final decisions.</p>
                    <p>This leaves the last warning regarding the unused variable 'x'. Due to the necessity of assigning variables before they are used elsewhere in
                        code, warnings like these will be frequent and can be temporarily safely ignored as your program evolves. Then, as you complete the various
                        sections of code containing such variables, if such warnings persist you should access whether a <a href="#Logical_errors">logical error</a> has
                        been introduced or remove the variable if in the end it was not required.</p>
                    <!-- !SECTION Code editor -->
                    <!-- SECTION Debugging -->
                    <h3 id="Debugging">Debugging</h3>
                    <p>Unlike computers, we humans make mistakes and as developers these can create problems, or <i>bugs,</i> that prevent our programs from operating
                        correctly. Debugging is the process of analyzing the program and removing such <a href="#Error_types">errors.</a> Visual Studio provides several
                        tools to help with this. Some of these are</p>
                    <ul>
                        <li><a href="#Code_editor">Code editor</a></li>
                        <li><a href="#Debugger_and_breakpoints">Debugger which is used in conjunction with break points</a></li>
                        <li><a href="#Immediate_window">Immediate window</a></li>
                        <li><a href="#Locals_window">Locals window</a></li>
                        <li><a href="#Watch_window">Watch window</a></li>
                        <li><a href="#Call_stack_window">Call stack window</a></li>
                    </ul>
                    <p>While these tools can greatly assist by highlighting errors and even making suggestions as how to fix them, they cannot fix bugs automatically.
                        Ultimately it is up to you to understand what is happening and to choose the correct solution to each specific issue. This is a skill that can
                        only be learnt with continual practice.</p>
                    <p>Debugging follows a repeated pattern, "what do you expect the code to do?", run the code, "what did the code do?". The way this is achieved is by
                        writing small, well defined pieces of code to which a single assumption can be applied. The program is then run to determine if it met that
                        assumption and if not, appropriate corrections are applied until it does. This is then repeated for each piece of code that is added until the
                        program is completed.</p>
                    <!-- !SECTION Debugging -->
                    <!-- SECTION Debugger and breakpoints -->
                    <h3 id="Debugger_and_breakpoints">Debugger and breakpoints</h3>
                    <p>When running a program, it may end unexpectedly without providing any information. Worse, it may run through to the end and exit normally but the
                        function it provides may not be as expected. The debugger provides extra information and allows you to step through the code one line at a time
                        allowing you to locate exactly where the code is going wrong. Breakpoints can be assigned to any line and can assist you by instructing the
                        debugger to pause or <i>break</i> at the line prior to executing it. From here you can step through the program and examine the current state of
                        the <a href="#Variables,_Constants,_Types_and_Literals">variables</a>, parameters and type members that are in <a href="#Scope">scope</a>.
                        Breakpoints and the current debugger state appear as icons in the left margin just to the left of the line numbers.</p>
                    <p>There are two ways a program can be configured when it is being built; <i>Debug</i> and <i>Release.</i> Debug configuration adds extra information
                        to the build, specifically for use by the debugger. The release configuration removes the debug information and optimizes the program for
                        performance, for when the program is deployed. Debug or release configurations can be selected from the <i>Solution Configurations</i> dropdown
                        list in the Visual Studio toolbar. There are also two ways in which to run the program in Visual Studio; <i>With the Debugger Attached</i> and
                        <i>Without the Debugger Attached</i>. To run a program in <i>Debug Mode</i> the program must be run, both with the debugger attached and with
                        debug configuration selected.</p>
                    <!-- SECTION Controlling the debugger -->
                    <h4 id="Controlling_the_debugger">Controlling the debugger</h4>
                    <p> There are a number of ways in which you can control the debugger.</p>
                    <ul>
                        <li><span class="nowrap">Start debugging <span class="play-button"></span></span> (<b>F5</b>)</li>
                        <li><span class="nowrap">Stop debugging <span class="stop-button"></span></span> (<span class="nowrap"><b>Shift + F5</b></span>)</li>
                        <li>Restart debugging (<span class="nowrap"><b>Ctrl + Shift + F5</b></span>)</li>
                        <li>Add/remove breakpoint (<b>F9</b>)</li>
                        <li>Step into (<b>F11</b>)</li>
                        <li>Step over (<b>F10</b>)</li>
                        <li>Step out (<span class="nowrap"><b>Shift + F11</b></span>)</li>
                        <li>Run to cursor (<span class="nowrap"><b>Ctrl + F10</b></span>)</li>
                        <li><span class="nowrap">Run to <span class="next-button"></span></span></li>
                        <li>Start without debugging (<span class="nowrap"><b>Ctrl + F5</b></span>)</li>
                    </ul>
                    <p>In the first code example we'll look at the <span class="nowrap"><i>Start debugging</i>,</span> <span class="nowrap"><i>Stop debugging</i>,</span>
                        <span class="nowrap"><i>Restart debugging</i>,</span> and <span class="nowrap"><i>Step into</i></span> functions.</p>
                    <p>With debug configuration selected, the debugger can be started in <i>debug mode</i> by clicking on the <span class="nowrap"><i>Start Debugging</i>
                        button <span class="play-button"></span></span> in the toolbar or by pressing <b>F5</b> In the example, press <b>F5</b> now. The debugger starts
                        and pauses or <i>breaks</i> the program at the statement <span class="nowrap"><code>var c = a / b</code>.</span> Next to it, a dialog is displayed
                        indicating that an <a href="#Exceptions">exception</a> has been <a href="#throw">thrown</a> with the name of the exception, in this case
                        DivideByZeroException, along with other information pertaining to it. When an exception is thrown or a breakpoint encountered, the debugger breaks
                        the program at the line in the code where this occurs, known as being in <i>break mode,</i> highlighting it in yellow and placing a
                        <span class="nowrap">yellow arrow
                            <span class="yellow-arrow-point">
                                <span class="yellow-arrow-point-fill">
                                    <span class="yellow-arrow-tail">
                                    </span>
                                </span>
                            </span>
                        </span>
                        in the left margin pointing to it. When the debugger is running or in break mode, the text to the right of the
                        <span class="nowrap">Start Debugging button <span class="play-button"></span>,</span> that normally displays the name of the project, will change
                        to <i>Continue.</i> Clicking it now or pressing <b>F5</b> will continue the program as normal if in break mode due to a breakpoint and stop the
                        program if an exception was thrown. If multiple breakpoints have been set, the debugger will break at each one it encounters. Also while running
                        or in break mode, a <span class="nowrap"><i>Stop Debugging</i> button <span class="stop-button"></span></span> will appear in the toolbar.
                        Clicking it or pressing <span class="nowrap"><b>Shift + F5</b></span> will stop the debugger. An alternative to stopping and starting the debugger
                        is to use the restart function by pressing <span class="nowrap"><b>Ctrl + Shift + F5.</b></span>
                    <p><em>Note:</em> <i>When using the debugger, the program being tested may have been made the active window and you may need to click on the Visual
                        Studio IDE to regain focus. Also, if the program type is a <a href="#Create_a_Hello_World_Project">Console App</a>, after the program has ended or
                        been stopped, you may also need to manually close the console window.</i></p>
                    <!-- !SECTION Controlling the debugger -->
                    <!-- SECTION Setting breakpoints and inspecting values -->
                    <h4 id="Setting_breakpoints_and_inspecting_values">Setting breakpoints and inspecting values</h4>
                    <p>If the statement is the true source of an exception, then it can be corrected and the program rerun. More often than not, the source of the
                        exception is elsewhere. For example, dividing a number by zero will result in a <i>DivideByZeroException,</i> but the place where the denominator
                        became zero may be prior to this point. To solve this, you can place a breakpoint prior to where you suspect this may be occurring, then by
                        stepping through one line at a time and inspecting each variable's value as it changes, you can determine the defective statement. To set a
                        breakpoint, you click in the left margin next to the required location and a <span class="nowrap">red dot <span class="red-dot"></span></span>
                        will appear indicating the breakpoint and the accompanying line of code will be highlighted in red. When the program is rerun, it will break at
                        the selected line with all code prior to the line having been executed but not the line itself. To remove a breakpoint, click on its
                        <span class="nowrap">red dot <span class="red-dot"></span></span>. An alternative way to add or remove a breakpoint is to place the cursor on the
                        required line of code and press <b>F9.</b></p>
                    <p>In the example, with the debugger still in break mode at the <span class="nowrap"><code>var c = a / b</code></span> statement, set a breakpoint
                        on it and restart the debugger. This time the program will break at the statement, highlighting it but having not yet executed it, no exception is
                        thrown. When the mouse is hovered over each of the variables <code>a,</code> <code>b,</code> and <code>c</code> in the statement, a popup dialog
                        is shown indicating their values which are 6, 0 and 0 respectively. As denominator <code>b</code> is 0, this is producing the exception. Stop the
                        debugger, close the console and change <code>var b = 0;</code> to <code>var b = 2;</code> in the code editor. Next, remove the breakpoint and set
                        a new on <code>Console.WriteLine($"c = {c}").</code> When the program is rerun <code>var c = a / b</code> is executed without an exception being
                        thrown and the program breaks at <span class="nowrap"><code>Console.WriteLine($"c = {c}").</code></span> Inspecting the variables <code>a,</code>
                        <code>b,</code> and <code>c,</code> show their values are now 6, 2 and 3. Also, by hovering over the
                        <a href="#Expressions_and_Operators">expression</a> <code>a / b,</code> we see its value is 3. To do this, you may need to move the mouse away
                        from the variables and then back over the division <code>/</code> <a href="#Expressions_and_Operators">operator</a>. There is also a parameter and
                        another variable that can be observed. The parameter <code>args</code> is passed in through
                        <span class="nowrap"><code>Main(string[] args),</code></span> which is a an <a href="#Array">array</a> of type <a href="#string">string</a> and
                        like a variable, its value can be observed by hovering over it. The popup dialog displays it to be <code>{string[0]}</code> which means that it is
                        a <code>string</code> array with zero elements. The other variable, <code>arr</code> is an array of type <code>int.</code> As the statement that
                        declares and assigns values to it has not yet been executed, observing it now shows its value to be null, the default value for an array. We'll
                        examine how its value changes after assignment, next in <a href="#Step_into">Step into</a>. When <b>F5</b> is next pressed, the program continues,
                        <span class="nowrap">'c = 3'</span> is written to the console and the program exits. Close the console.</p>
                    <p>There are various other options for inspecting values including the <a href="#Immediate_window">immediate</a>, <a href="#Locals_window">locals</a>
                        and <a href="#Watch_window">watch</a> windows.</p>
                    <!-- !SECTION Setting breakpoints and inspecting values -->
                    <!-- SECTION Step into -->
                    <h4 id="Step_into">Step into</h4>
                    <p>Step into executes the program one line at a time. By pressing <b>F11,</b> the currently highlighted line will be executed and the program advanced
                        to the next line or if the current line is a <a href="#Program_execution">method call</a>, to the opening brace of the
                        <a href="#Program_execution">called method's</a> code block. The variables can then be rechecked and the program state evaluated. This process can
                        be repeated until either the problem is found, an exception is thrown or the program ends. If the program isn't running, pressing <b>F11</b> will
                        start the debugger and put the program into break mode at the opening brace of the <code>Main</code> method. By default, only your code is stepped
                        through but this can be changed in Visual Studio's options.</p>
                    <p>Using the now modified code in the example, press <b>F11</b> twice. This first starts the debugger with the program in break mode at the first
                        brace after <code>static void Main(string[] args),</code> then advances it to <code>var a = 6</code>. Checking the variables <code>a,</code>
                        <code>b,</code> and <code>c,</code> reveals their values to all be 0. This shows that even though the
                        <a href="#Variable_declaration_and_assignment">declaration and assignment</a> statements for these variables have yet to be executed, the compiler
                        has already looked at the code and having seen the <code>var</code> keyword, implicitly declared them to be of type <code>int</code> and assigned
                        them 0, being the default value for an <code>int</code>. Pressing <b>F11</b> twice more first executes <code>var a = 6</code> then
                        <code>var b = 2,</code> changing a and b's values to 6 and 2 respectively. As the program is now in break mode on <code>var c = a / b</code>,
                        again pressing <b>F11</b> twice first executes the statement assigning 3 to <code>c</code>, then executes
                        <code>Console.WriteLine($"c = {c}")</code> which writes <span class="nowrap">'c = 3'</span> to the console. At this point,
                        <code>int[] arr = { 1, 2, 3, 4 }</code> has not yet been executed so the value of <code>arr</code> is still null. Press <b>F11</b> to step into
                        and execute the statement. Observing <code>arr</code> now shows its value has changed to <span class="nowrap">{int[4]}</span> indicating it is an
                        array of type <code>int</code> with 4 elements. Additionally, an arrow has appeared at the left side of the dialog. Hovering over this reveals a
                        list of the elements, which as an array is zero based, are numbered [0] to [3], and their values, 1 to 4. One more press of <b>F11</b> advances
                        the program to the end where it exits and the console can now be closed.</p>
                    <!-- !SECTION Step into -->
<pre><code>namespace Debugger1
{
    class Program
    {
        static void Main(string[] args)
        {
            var a = 6;
            var b = 0;
            var c = a / b;
            Console.WriteLine($"c = {c}");
        }
    }
}
</code></pre>
                    <!-- SECTION Effect of local scope -->
                    <h4 id="Effect_of_local_scope">Effect of local scope</h4>
                    <p>In the next example we'll first look at how the values of <a href="#Variables,_Constants,_Types_and_Literals">variables</a>,
                        <a href="#Parameters,_signatures_and_overloading">parameters</a> and type <a href="#Members">members</a> can only be observed when
                        <a href="#Program_execution">program execution</a> has entered the <a href="#Scope">local scope</a> in which they reside. For example, if MethodA
                        calls MethodB and the program is in break mode within MethodB, only the values of the variables and parameters in MethodB's code block can be
                        observed. Similarly, if the program is in break mode inside a <a href="#Methods">method</a> but outside of an
                        <span class="nowrap"><a href="#if_else_statements">if statement</a></span> it contains, the values of the variables
                        <a href="#Variable_declaration_and_assignment">declared</a> within the <code>if</code> statement's code block can't be observed until program
                        execution enters it.</p>
                    <p>In the example, press <code>F11</code> which will <a href="#Controlling_the_debugger">start the debugger</a> and <a href="#Step_into">step into</a>
                        to the opening brace of the <code>Main</code> method. As program execution is within the <code>Main</code> method, the variables, parameters and
                        type members within the other methods can't be observed. Step through the code until you reach
                        <span class="nowrap"><code>if (b != 0)</code></span> in <code>Method1.</code> If you now attempt to observe all variables and parameters anywhere
                        in the code, only <code>a</code> and <code>b</code> produce a popup dialog indicating their current values of 4 and 2 respectively. Step through
                        to <span class="nowrap"><code>var c = a / b</code></span> and now <code>c</code> can also be observed as program execution has entered the code
                        block of <span class="nowrap"><code>if (b != 0).</code></span> The value of <code>c</code> which is 0, changes to 2 when stepping into to the next
                        line. Stepping once more exits the <code>if (b != 0)</code> code block and having left its local scope, <code>c</code> is no longer observable.
                    </p>
                    <p>Step through until you are at <span class="nowrap"><code>var sum = x + y</code></span> in <code>Method2.</code> Only parameters <code>x,</code>
                        <code>y</code> and variable <code>sum</code> can be observed which are 3, 5 and 0 respectively. As you hover over the
                        <a href="#Expressions_and_Operators">expression</a> <code>x + y</code>, if the mouse is not exactly over the <code>x</code> and <code>y</code>
                        variables, the result of the expression will be shown instead. Stepping once <a href="#Variable_declaration_and_assignment">assigns</a> the result
                        to <code>sum,</code> changing to 8.</p>
                    <p>Step though until you get to <span class="nowrap"><code>MyClass myClass = new MyClass()</code></span> in <code>Method3</code> and only
                        <code>myClass</code> and its <a href="#Properties">property</a> <code>Number</code> can be observed. Examining these reveals that the value of
                        <code>myClass</code> is <a href="#null">null</a>, the default value for a <a href="#Variables,_Constants,_Types_and_Literals">reference type</a>
                        that has not been <a href="#Code_syntax">instantiated</a> and due to this, attempting to view <code>myClass.Number</code> produces a message that
                        suggests an <a href="#Exceptions">exception</a> has been thrown. This not an actual exception and is only due to the current state of
                        <code>myClass</code> which changes when stepping to the next line and <code>myClass</code> is created. Observing it now shows an additional
                        dropdown list in the dialog that allows you to examine the members it contains, which in this case, is only the property <code>Number</code> with
                        a value of 0. Stepping forward once more assigns 10 to <code>Number</code> as now observed. You can now stop the debugger an close the console.
                    </p>
<pre><code>namespace Debugger2
{
    class Program
    {
        static void Main(string[] args)
        {
            Method1();
            Method2(3, 5);
            Method3();
        }

        static void Method1()
        {
            var a = 4;
            var b = 2;
            if (b != 0)
            {
                var c = a / b;
            }
        }

        static void Method2(int x, int y)
        {
            var sum = x + y;
        }

        static void Method3()
        {
            MyClass myClass = new MyClass();
            myClass.Number = 10;
        }
    }

    public class MyClass
    {
        public int Number { get; set; }
    }
}
</code></pre>
                    <!-- !SECTION Effect of local scope -->
                    <p>In the last example we'll look at the behavior of <span class="nowrap"><i>Step over</i>,</span> <span><i>Step out</i>,</span>
                        <span class="nowrap"><i>Run to cursor</i></span> and <span class="nowrap"><i>Run to</i></span>. These each provide different ways to execute
                        sections of code without having to step through individual lines, so that you can quickly get to locations of interest. Note though that when
                        using these, if a breakpoint is present, it will take priority and the program will break at the breakpoint.</p>
                     <!-- SECTION Step over -->
                     <h4 id="Step_over">Step over</h4>
                     <p><i>Step over</i> allows you to skip over methods. When you are at a method call, pressing <b>F10</b> will execute the statements it contains but
                        without stepping through them individually and the program is advanced to the line after the method call. Pressing <b>F10</b> on any statement,
                        other than a method call, will step into it. In the example, set an additional breakpoint on
                        <span class="nowrap"><code>var cube = y * y * y</code></span> and start the debugger. The program breaks at the first breakpoint and nothing has
                        been written to the console. Press <b>F10</b> to step over the method call to <code>PrintSquare</code>. The program advances to
                        <code>var b = 2</code> and looking at the console, we can see that 'The square of 4 is 16' has been written, indicating that the code within
                        <code>PrintSquare</code> was executed without stepping through it. Pressing <b>F10</b> twice more first advances to the <code>PrintCube</code>
                        method call then, instead of stepping over the method, the program breaks at the breakpoint within it. Pressing <b>F10</b> three more times
                        steps through the statements in the <code>PrintCube</code> method one at a time, writing 'The cube of 2 is 8' to the console, then returns to the
                        method call. Press <span class="nowrap"><b>Shift + F5</b></span> to stop debugging and then close the console.</p>
                     <!-- !SECTION Step over -->
                    <!-- SECTION Step out -->
                    <h4 id="Step_out">Step out</h4>
                    <p><i>Step out</i> allows you to skip the remaining statements in a method. When in break mode at a line within a method, pressing
                        <span class="nowrap"><b>Shift + F11</b></span> will advance the program back to the method call. In the example, remove the first breakpoint and
                        start the debugger so that the program in break mode at <span class="nowrap"><code>var cube = y * y * y</code></span>. At this point only
                        'The square of 4 is 16' has been written to the console. Press <span class="nowrap"><b>Shift + F11</b></span> The remaining statements are
                        executed without being stepped through, writing 'The cube of 2 is 8' to the console and program execution returns to the method call. Stop the
                        debugger and close the console.</p>
                    <!-- !SECTION Step out -->
                    <!-- SECTION Run to cursor -->
                    <h4 id="Run_to_cursor">Run to cursor</h4>
                    <p><i>Run to cursor</i> will execute all code, up to but not including, the line at the current cursor position in the code and is achieved by
                        pressing <span class="nowrap"><b>Ctrl + F10.</b></span> It doesn't matter where in the line of code the cursor is positioned and can be used
                        whether or not the program is already running and whether or not the program is in break mode. In the example, with the program stopped, place the
                        cursor anywhere on the <code>PrintSquare</code> method call and press <span class="nowrap"><b>Ctrl + F10.</b></span> The program runs and breaks
                        at the <code>PrintSquare</code> method call. As it has not yet been executed, nothing is written to the console but observing variable
                        <code>a</code> we can see its value has changed to 4. Now position the cursor on the <code>PrintCube</code> method call and again press
                        <span class="nowrap"><b>Ctrl + F10.</b></span> The program advances to the method call and 'The square of 4 is 16' is written to the console.
                        Place the cursor on <code>if (b != 0)</code> and press <span class="nowrap"><b>Ctrl + F10.</b></span> The program breaks at the breakpoint in the
                        PrintCube method. Again place the cursor on <code>if (b != 0)</code> and press <span class="nowrap"><b>Ctrl + F10.</b></span>
                        'The cube of 2 is 8' is written to the console and the program advances to the <code>if</code> statement. Place the cursor on the closing brace of
                        the <code>Main</code> method and press <span class="nowrap"><b>Ctrl + F10.</b></span> <span class="nowrap">'4 / 2 = 2'</span> is written to the
                        console and the program advances to the brace. Stop the debugger and close the console.</p>
                    <!-- !SECTION Run to cursor -->
                    <!-- SECTION Run to -->
                    <h4 id="Run_to">Run to</h4>
                    <p><i>Run to</i> allows you to advance the program to a specific line of code, but unlike run to cursor, Run to is only available while the program is
                        running or in break mode. To use Run to, when the mouse is hovered over a line of code, the
                        <span class="nowrap">Run to button <span class="next-button"></span></span> will appear to the left. Clicking it will advance the program to that
                        point. In the example, press <b>F11</b> to start the debugger and place the program in break mode at the opening brace of the <code>Main</code>
                        method. With the mouse hovering over the <code>PrintCube</code> method call, click the
                        <span class="nowrap">Run to button <span class="next-button"></span></span> that appears to the left. The program advances to
                        <code>PrintCube</code>, with all code between it and the previous position executed without being stepped through, resulting in 'The square of 4
                        is 16' being written to the console. Hover over <code>if (b != 0)</code> and click the
                        <span class="nowrap">Run to button <span class="next-button"></span></span>. The program enters the <code>PrintCube</code> method and breaks at
                        the breakpoint. Now hover over the closing brace of the <code>Main</code> method and again click the
                        <span class="nowrap">Run to button <span class="next-button"></span></span>. The remaining code between the breakpoint and the end of the program
                        is executed resulting in both 'The cube of 2 is 8' and <span class="nowrap">'4 / 2 = 2'</span> being written to the console. Stop the debugger and
                        close the console.</p>
                    <!-- !SECTION Run to -->
<pre><code>namespace Debugger3
{
    class Program
    {
        static void Main(string[] args)
        {
            var a = 4;
            PrintSquare(a);
            var b = 2;
            PrintCube(b);
            if (b != 0)
            {
                var c = a / b;
                Console.WriteLine($"{a} / {b} = {c}");
            }
        }

        static void PrintSquare(int x)
        {
            var square = x * x;
            Console.WriteLine($"The square of {x} is {square}");
        }

        static void PrintCube(int y)
        {
            var cube = y * y * y;
            Console.WriteLine($"The cube of {y} is {cube}");
        }
    }
}

// This example writes the following to the console
// The square of 4 is 16
// The cube of 2 is 8
// 4 / 2 = 2
</code></pre>
                    <p>The program can also be run normally by clicking the
                        <span class="nowrap"><i>Start without debugging</i> button <span class="play-button"><span class="play-button-light-fill"></span></span></span>
                        or by pressing <span class="nowrap"><b>Ctrl + F5.</b></span> The program will then run and any breakpoints are ignored.</p>
                    <p>When a program is built with the release configuration, the optimizations used by the compiler to improve performance, can on occasion produce
                        problems. It is important that, once you have completed debugging the program, you should build and test the program in release configuration to
                        ensure it is functioning correctly, prior to deployment. To do this, change the configuration in the
                        <a href="#Debugger_and_breakpoints">Solution Configurations</a> dropdown list in the toolbar to <i>Release</i> and click on the
                        <span class="nowrap">Start Debugging button <span class="play-button"></span></span> or press <b>F5.</b> A release version of the program will be
                        built and run, which you can then test as you did with the debug version.</p>
                    <p>By default, Visual Studio creates the following folders to store the two program versions when they are built.</p>
                    <p>SolutionFolder\ProjectFolder\bin\Debug</p>
                    <p>SolutionFolder\ProjectFolder\bin\Release</p>
                    <!-- !SECTION Debugger and breakpoints -->
                    <!-- SECTION Immediate window -->
                    <h3 id="Immediate_window">Immediate window</h3>
                    <p>The <i>Immediate window</i> allows you to read and change the value of a <a href="#Variables,_Constants,_Types_and_Literals">variable</a> when the
                        <a href="#Debugger_and_breakpoints">debugger</a> is running. It also allows you to call any <a href="#Methods">method</a>
                        allowing you to evaluate it, even if the debugger is not running. If not visible, the immediate window can be opened by selecting
                        <span class="nowrap"><b>Debug</b> &gt; <b>Windows</b> &gt; <b>Immediate</b></span> in the main menu or by pressing
                        <span class="nowrap"><b>Ctrl + Alt + I.</b></span></p>
                    <p>To see how the immediate window works, paste the following code into a <a href="#Create_a_Hello_World_Project">Console App.</a></p>
<pre><code>namespace ImmediateWindow
{
    class Program
    {
        static void Main(string[] args)
        {
            var a = 4;
            PrintSquare(a);
        }

        static void PrintSquare(int x)
        {
            var square = x * x;
            Console.WriteLine($"The square of {x} is {square}");
        }
    }
}
</code></pre>
                    <p>Now start the debugger by pressing <b>F5.</b> The program runs and 'The square of 4 is 16' is written to the console. Set a
                        <a href="#Debugger_and_breakpoints">breakpoint</a> on the <code>PrintSquare</code>
                        <a href="#Program_structure">method call</a> and press <span class="nowrap"><b>Ctrl + Shift + F5</b></span> to restart the debugger and break at
                        <code>PrintSquare.</code> In the immediate window type <code>?a</code> then press <b>Enter</b> and the value of <code>a</code> will be displayed
                        as follows.</p>
                        <p><em>Note:</em> <i>If IntelliSense opens a list after typing <code>a</code> press the <b>Esc</b> key to close it, then press
                            <b>Enter.</b></i></p></p>
<pre><code>?a
5
</code></pre>
                    <p>Now type <code>a=5</code> in the immediate window and press return. The following will be displayed indicating that the value of the variable has
                        changed. Hovering over <code>a</code> in the code editor, you can see that its value has changed to 5 there also. Press <b>F5</b> to allow the
                        program to continue and 'The square of 5 is 25' is written to the console. Stop the debugger and close the console.</p>
                    <p><em>Note:</em> <i>It can take several seconds for the console to close when using the immediate window giving the impression it is not
                        responding.</i></p>
<pre><code>?a
4
a=5
5
</code></pre>
                    <p>Now type <code>PrintSquare</code>. As you start typing IntelliSense should display a list that includes <code>PrintSquare</code> for you to select
                        if you wish. Finish the entry by typing <code>PrintSquare(6)</code> then press <b>Enter.</b> The debugger will start and 'The square of 6 is 36'
                        will be written to the console. The immediate window will appear as follows with the last statement indicating there was no return value from the
                        method. Stop the debugger and close the console. To clear the immediate window, right click it and click
                        <span class="nowrap"><b>Clear All</b></span> in the context menu that appears.</p>
<pre><code>?a
4
a=5
5
PrintSquare(6)
Expression has been evaluated and has no value
</code></pre>
                    <!-- !SECTION Immediate window -->
                    <!-- SECTION Locals window -->
                    <h4 id="Locals_window">Locals window</h4>
                    <p>The <i>Locals window</i> is only available while the <a href="#Debugger_and_breakpoints">debugger</a> is running. It provides a list of all
                        <a href="#Variables,_Constants,_Types_and_Literals">variables</a>, <a href="#Parameters,_signatures_and_overloading">parameters</a> and
                        <a href="#Properties">properties</a> that are within the <a href="#Scope">local scope</a> of the current program execution location, along with
                        their names, values and types. As with the immediate window, it also allows you to change the values. To view the Locals window, while the
                        debugger is running select <span class="nowrap"><b>Debug</b> &gt; <b>Windows</b> &gt; <b>Locals</b></span> in the main menu.</p>
                    <p>To see how the locals window works, create a <a href="#Create_a_Hello_World_Project">Console App</a> and replace the code with the following.</p>
<pre><code>namespace LocalsWindow
{
    class Program
    {
        static void Main(string[] args)
        {
            var a = 4;
            PrintSquare(a);
            var b = 2;
            if (b != 0)
            {
                var c = a / b;
                Console.WriteLine($"{a} / {b} = {c}");
            }
            int[] arr = { 1, 2, 3, 4 };
            MyClass myClass = new();
            myClass.Property1 = 10;
        }

        static void PrintSquare(int x)
        {
            var square = x * x;
            Console.WriteLine($"The square of {x} is {square}");
        }
    }

    class MyClass
    {
        public int Property1 { get; set; }

        public double Property2 { get; set; }
    }
}
</code></pre>
                    <p>Place a breakpoint on the <code>PrintSquare</code> method call and start the debugger. The program starts and breaks at the method call. If the
                        locals window is not in view, open it now. It lists all variables that are in the current scope, along with their types and values as follows.</p>
<pre><code> Name        Value           Type
 args        {string[0]}     string[]
 a           4               int
 b           0               int
 arr         null            int[]
 myClass     null            LocalsWindow.MyClass
</code></pre>
                    <p>Press <b>F11</b> twice to step through to <code>var square = x * x</code> in the <code>PrintSquare</code> method. As program execution has left the
                        local scope of the <code>Main</code> method and entered that of <code>PrintSquare,</code> only the parameter <code>x</code> and variable
                        <code>square</code> are listed.</p>
<pre><code> Name        Value           Type
 x           4               int
 square      0               int
</code></pre>
                    <p>Step into <code>var square = x * x</code> to execute it. The value of <code>square</code> has changed from 0 to 16 and its color
                        has changed from black to red to indicate that the value has changed since it was last checked.</p>
<pre><code> Name        Value           Type
 x           4               int
 square      <span class="value-changed">16</span>              int
</code></pre>
                    <p>Step through again so that the program is located at the closing brace of <code>PrintSquare.</code> 'The square of 4 is 16' has been written to the
                        console and the color of the <code>square</code> value has reverted back to black, indicating that it hasn't changed since last checked. Step
                        though until you get to <code>var c = a / b</code> and the following is listed.</p>
<pre><code> Name        Value           Type
 args        {string[0]}     string[]
 a           4               int
 b           0               int
 arr         null            int[]
 myClass     null            LocalsWindow.MyClass
 c           0               int
</code></pre>
                    <p>As program execution has now entered the local scope of the if statement code block, in addition to the variables that were initially listed at the
                        start of the exercise, variable <code>c</code> has also been included. Inspecting the locals window, the values for <code>a</code> and
                        <code>b</code> are 4 and 2 respectively and hovering over the expression <code>a / b</code> shows it equates to 2. As the statement has not been
                        executed, the value of <code>c</code> is 0. You can change the value of a variable in the locals window by double clicking on the value displayed,
                        then enter the new value. In the example, double click <code>a's</code> value in the locals window and change it to 16, then click away from it to
                        accept the change. Its color will change to red to indicate that it has changed since it was last checked and hovering over <code>a / b</code>
                        shows that the expression now equates to 8. Stepping into <code>var c = a / b</code> executes the statement, the value of <code>c</code> changes
                        to 8, its color to red and the color of <code>a</code> back to black. Stepping into the next statement writes '16 / 2 = 8' to the console and the
                        color of <code>c</code> changes back to black.</p>
                    <p>Stepping though to <code>myClass.Property1 = 10,</code> variable <code>c</code> is no longer listed as it is no longer in scope. Variables
                        <code>arr</code> and <code>myClass</code> have been assigned values, so these appear in the list and are {int[4]} and {LocalsWindows.MyClass}
                        respectively. As <code>arr</code> is an array with multiple elements and <code>myClass</code> is a class with multiple properties, each have an
                        arrow to the left that when clicked, expands the nodes in the locals window to reveal them. Step into <code>myClass.Property1 = 10</code> to
                        execute it. The value of <code>Property1</code> in the locals window changes from 0 to 10 and its color changes to red. Pressing <b>F11</b> once
                        more exits the program and the locals window closes. You can now close the console.</p>
                    <!-- !SECTION Locals window -->
                    <!-- TODO complete Watch window -->
                    <!-- SECTION Watch window -->
                    <h4 id="Watch_window">Watch window</h4>
                    <p>The <i>Watch window</i>, like the locals window, is only available while you are debugging. It allows you to create a list of variables, parameters
                        and properties you are interested in observing, displaying their names, values and types. It also allows you to enter expressions. You can
                        have up to four watch windows labelled Watch 1 through Watch 4, each with their own list of items. For example, to open Watch 1, with the debugger
                        running, select <span class="nowrap"><b>Debug</b> &gt; <b>Windows</b> &gt; <b>Watch</b> &gt; <b>Watch1</b></span> from the main menu.</p>
                    <p>To see how the watch window works, paste the following code into a <a href="#Create_a_Hello_World_Project">Console App.</a></p>
<pre><code>namespace Namespace
{
    class Program
    {
        static void Main()
        {

        }
    }
}
</code></pre>
                    <p>To enter an item, click on <i>Add item to watch</i> on an empty row and enter its name or the expression you wish to examine. As with the code editor, the
                        syntax of an expression is evaluated and if an error has occurred, this will be displayed in the <i>Value</i> column.  As with the locals window, as
                        you step through the program, the items will update to show the current values, with the last item change colored red. </p>


                    <p>Place a breakpoint on the <code>PrintSquare</code> method call and start the debugger. To enter an item, click on <i>Add item to watch</i> on an
                        empty row and enter its name or the expression you wish to examine. As you start to type, IntelliSense displays a list that includes the objects
                        that are within the local scope of the current execution. You can still enter an item outside the current local scope, however it won't be listed
                        in the list and an error <span class="error-circle"></span>  may be displayed   In the example,



                        The program starts and breaks at the method call. If the
                        Watch1 window is not in view, open it now. It lists all variables that are in the current scope, along with their types and values as follows.</p>
    <pre><code> Name        Value           Type
     args        {string[0]}     string[]
     a           4               int
     b           0               int
     arr         null            int[]
     myClass     null            LocalsWindow.MyClass
    </code></pre>


















                    <!-- !SECTION Watch window -->
                    <!-- TODO complete Call stack window -->
                    <!-- SECTION Call stack window -->
                    <h4 id="Call_stack_window">Call stack window</h4>
                    <p>Description</p>
                    <p>CodeExample</p>
<pre><code>namespace Namespace
{
    class Program
    {
        static void Main()
        {

        }
    }
}
</code></pre>
                    <!-- !SECTION Call stack window -->
                </article>
            </section>
            <!-- !SECTION Code Writing and Debugging -->
<!-- TODO Add custom exceptions and using in built preferred. Custom exceptions should end with exception -->
<!-- TODO add info about source of exception, .NET, runtime, third-party -->
            <!-- SECTION Errors and Exception Handling -->
            <section class="main-section" id="Errors_and_Exception_Handling">
                <header><h2>Errors and Exception Handling</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article class="main-article">
                    <p>As the program code grows the likelihood that an error will be introduced grows with it. C# provides tools for handling these depending on the kind
                        of error that is encountered.</p>
                    <!-- SECTION Error types -->
                    <h3 id="Error_types">Error types</h3>
                    <p>There are three different kinds of errors, syntax errors, runtime errors and logical errors.</p>
                    <!-- SECTION Syntax errors -->
                    <h4 id="Syntax_errors">Syntax errors</h4>
                    <p>As the title suggests, syntax errors occur when the <a href="#Code_syntax">syntax</a> is wrong and this will prevent the code from being
                        <a href="#Integrated_Development_Environment">compiled</a>. This could be caused by a
                        spelling mistake, a missing semi colon, an incorrect use of a language element, etc. These are the easiest errors to fix as the
                        <a href="#Code_editor">code editor</a>, much like a word processor, identifies such errors with a <u class="error">red wavy underline</u>. Syntax
                        errors are also sometimes called compile errors or compile-time errors. Additionally, the code editor will provide warnings with a
                        <u class="warning">green wavy underline</u>. Whilst these won't prevent the program from compiling, they indicate problems that most likely will
                        result in issues when the program is run and should be addressed. As well as highlighting errors and warnings, the code editor provides a number
                        of other tools to assist the developer in debugging.</p>
                    <p>The following example demonstrates a syntax error.</p>
<pre><code>namespace SyntaxError
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // The following results in the compiler error.
            // CS0103: The name 'number' does not exist in the current context
            var x = <u class="error">number</u>;
        }
    }
}
</code></pre>
                    <!-- !SECTION Syntax errors -->
                    <!-- SECTION Runtime errors -->
                    <h4 id="Runtime_errors">Runtime error</h4>
                    <p>A runtime error occurs after the program has been compiled and is running. Whilst syntactically correct, when the code is executed, it will result
                        in an error that can't be resolved and stops the program from functioning. The <a href="#dot_NET">CLR</a> then looks for the reason the error
                        occurred and reports it in the form of an <a href="#Exceptions">exception.</a> As such errors are at a fixed point in the code, these can usually
                        be fixed fairly easily by either correcting the error through <a href="#Debugging">debugging</a> or by providing appropriate
                        <a href="#try-catch">exception handling.</a> See <a href="#Exceptions">Exceptions</a> for an example of a runtime error.</p>
                    <!-- !SECTION Runtime errors -->
                    <!-- SECTION Logical errors -->
                    <h4 id="Logical_errors">Logical error</h4>
                    <p>These are errors that occur while the program is running but don't cause the program to crash. Instead, the program will produce an unexpected
                        result. For example, the sum of a list of numbers may be far more than expected because an expression may mistakenly multiply instead of adding
                        the values. These are often the hardest errors to debug as they most often they result from incorrect assumptions on what the program is doing
                        and could be buried deep within thousands or even millions of lines of code. As with runtime errors, a number of
                        <a href="#Debugging">debugging</a> techniques can be used to correct the issues.</p>
                    <p>The following is an example of a logical error. The numbers are multiplied when they should be added. The expected result from adding 3 + 5 is 7,
                        but the program produces 15, the result of multiplication.</p>
<pre><code>namespace LogicalErrors
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // The literals are multiplied when they should be added
            Console.WriteLine($"3 + 5 = {3 * 5}");
        }
    }
}

// The example writes the following to the console
// 3 + 5 = 15
</code></pre>
                    <!-- !SECTION Logical errors -->
                    <!-- !SECTION Error types -->
                    <!-- SECTION Exceptions -->
                    <h3 id="Exceptions">Exceptions</h3>
                    <p>When an error that is caused by and cannot be resolved by the current executing statement occurs, an exception is thrown. This could be due to code
                        in the CLR, a third-party library or the current application. At this point the CLR searches back up the stack until either exception handling, in
                        the form of a <a href="#try-catch">try-catch</a> statement is reached, or the program exits in which case the operating system may report the
                        program has exited with an unhandled exception. C# has a number of built-in exceptions that are thrown for various error conditions. You can also
                        create your own custom exceptions though the built-in types should be used where possible. Following is an example that shows the result of
                        attempting to divide by zero. By clicking on the <i>Start Debugging</i> button <span class="play-button"></span> in the toolbar or by pressing
                        <b>F5</b> the program will run with the debugger attached and then stop and highlight the statement
                        <code>var z = x / y;</code> and display an <i>Exception Unhandled</i> dialog box with the message <i>System.DivideByZeroException: 'Attempted to
                        divide by zero.'</i> of which <code>DivideByZeroException</code> is the exception. To stop the program and clear the exception click the
                        <i>Stop Debugging</i> <span class="stop-button"></span> button in the toolbar or press <span class="nowrap"><b>Shift + F5</b></span></p>
<pre><code>namespace Exception
{
    class Program
    {
        static void Main(string[] args)
        {
            var x = 1;
            var y = 0;
            var z = x / y;
        }
    }
}

// When run, the example results in a DivideByZeroException
</code></pre>
                    <!-- !SECTION Exceptions -->
                    <!-- SECTION throw -->
                    <h3 id="throw">throw</h3>
                    <p>Sometimes you may wish to check for invalid conditions specific to your own program. When these occur, you can respond by throwing an exception of
                    your own choice using the <code>throw</code> keyword. You can also include a custom message with the exception. The following throws an
                    <code>ArgumentException</code> with the message <i>y cannot be zero</i>.</p>
<pre><code>namespace Throw
{
    class Program
    {
        static void Main(string[] args)
        {
            int y = 0;
            throw new ArgumentException("y cannot be zero");
        }
    }
}

// When run, the example results in
// System.ArgumentException: 'y cannot be zero'
</code></pre>
                    <p> As the name suggests, an exception should only be used for exceptional circumstances and should not be used to control program execution. Instead,
                        conditional statements should always be employed to look for potential errors.</p>
                    <!-- !SECTION throw -->
                    <!-- SECTION try-catch -->
                    <h3 id="try-catch">try-catch</h3>
                    <p>The try-catch provides a mechanism to safely handle exceptions and consists of a <code>try</code> code block followed by a <code>catch</code>
                        code block. Code that has the possibility of resulting in an exception is placed within the <code>try</code> block and if an exception occurs
                        program execution stops before any further code within the <code>try</code> block is run. Program execution then passes to a catch block that
                        targets the exception. If none is found, program execution passes back to the calling code until an appropriate catch block is found. If a
                        <code>catch</code> block is not found then the program ends with an <i>unhandled exception</i></p>.
                    <p>Following shows how the <code>DivideByZeroException</code> in the previous example could be handled. When run, instead of resulting in an unhandled
                        exception dialog box, <i>'Attempted to divide by zero.'</i> is written to the console.</p>
<pre><code>namespace TryCatch
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 1;
            int y = 0;
            try
            {
                int z = x / y;
            }
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}

// The example writes the following to the console
// Attempted to divide by zero.
</code></pre>
                    <p>It is important to note that catching exceptions should not be used just to control program flow. In the previous example an
                        <a href="#if_statement">if statement</a> could be used to test the value of <code>y</code> and only allow the division to take place if it is not
                        zero. An example of where a try-catch could be employed is writing to a file as is not possible to test prior whether the action will succeed.</p>
                    <!-- !SECTION try-catch -->
                    <!-- SECTION multiple catch blocks -->
                    <h3 id="multiple_catch_blocks">multiple catch blocks</h3>
                    <p>It is possible to have multiple catch blocks so as to catch different exceptions. An exception is only caught by the first catch block that
                        can handle it. If there is the possibility that the exception could be caught by more than one, the catch blocks should be ordered most to least
                        specific. In the following example the first block catches the <code>DivideByZeroException</code> and the second <code>Exception</code>
                        catches all exceptions. This means that if <code>DivideByZeroException</code> code block had not been present then the divide by zero exception
                        would have been caught by the <code>Exception</code> code block.</p>
<pre><code>namespace MultipleCatchBlocks
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 1;
            int y = 2;
            try
            {
                int z = x / y;
                throw new Exception("A second exception");
            }
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}

// The example writes the following to the console
// A second exception
</code></pre>
                    <!-- !SECTION multiple catch blocks -->
                    <!-- TODO complete Filtered_exceptions -->
                    <!-- SECTION Filtered_exceptions -->
                    <h3 id="Filtered_exceptions">Filtered_exceptions</h3>
                    <p>The <code>when</code> keyword can be used to filter exceptions to give a more fine-grained response.</p>
                    <p>In the following example all catch blocks catch Exception but each use <code>when</code> to catch a specific condition based on the exception's
                        message.</p>
<pre><code>namespace CatchWhen
{
    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                throw new Exception("Second exception");
            }
            catch (Exception ex) when (ex.Message.Contains("First"))
            {
                Console.WriteLine(ex.Message);
            }
            catch (Exception ex) when (ex.Message.Contains("Second"))
            {
                Console.WriteLine(ex.Message);
            }
            catch (Exception ex) when (ex.Message.Contains("Third"))
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}

// The example writes the following to the console
// A second exception
</code></pre>
                    <!-- !SECTION Filtered_exceptions -->
                </article>
            </section>
            <!-- !SECTION Errors and Exception Handling -->
            <!-- TODO complete variable lifetime -->
            <!-- TODO add something about generics -->
            <!-- SECTION Variables, Constants, Types and Literals -->
            <section class="main-section" id="Variables,_Constants,_Types_and_Literals">
                <header><h2>Variables, Constants, Types and Literals</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Variables are used to represent data in memory using a symbolic name. Every variable has a <i>type</i> that determines what type of data can be
                        stored and a <i>value</i> which is the actual data. C# is a strongly typed language which means the variable's type must be declared before it can
                        be used and cannot be changed later. When an attempt is made to store a value in a variable the compiler will check if it is of the correct type
                        and if not, indicate this as a <a href="#Syntax_errors">syntax error</a> and prevent the program from being compiled. Storing a value is said to
                        be assigning a value and a variable that has been assigned a value is said to be initialized. A <i>constant</i> is similar to a variable, except
                        it must be initialized when it is declared and that value cannot be changed. A <i>literal</i> is the representation in code of the data that is
                        assigned to a variable. Variables and constants can only be declared once within the same <a href="#Scope">scope.</a> Throughout much of
                        <a href="#References">Microsoft C# reference documentation</a>, generically types may be referred to with a single <code>T</code> and where
                        appropriate, the same will be done within this document.</p>
                    <p>C# has two basic categories of variables, the <i>value type</i> and the <i>reference type</i>, into which all variable types are grouped. A value
                        type stores its own data where as a reference type stores the address to where its data is located. You can think of these as a person and a
                        contact in an address book. The value type is like the person that has a name and physical body whereas the reference type is like the contact
                        that only stores the name of the person and the address to where they live.</p>
                    <p>C# has a number of built-in types within these two categories of which each has a dedicated <a href="#C_Sharp_Specifications">keyword</a> and you
                        can also create your own <a href="#User_defined_types">user defined types.</a></p>
                    <p>C# allocates memory based on the smallest size unit of an 8-bit byte. For efficiency reasons, each value type uses a fixed number of bytes. For an
                        integer, C# provides a number of options based on size and whether negative values are allowed. The most commonly used is the <i>int</i> which has
                        a memory allocation of 4 bytes, or 32 bits, and can have negative values. It has a range from -2147483648 to 2147483647. When you write
                        <code>int i = 1;</code> this declares an <code>int</code> type variable with the identifier <code>i</code> and assigns the value <code>1</code> to
                        it. In essence you are telling the compiler to reserve a 4-byte section of memory, that its address will be referred to by the variable with the
                        identifier <code>i</code> and to store the value <code>1</code> in it. But for a few exceptions, operations on one value type variable cannot
                        affect the data of another. A value type variable cannot be changed to refer to data in another memory location.</p>
                    <p>Providing it is of the same type a reference type can be changed to refer to a different location in memory and its size in memory can change. A
                        reference type can only refer to one location at a time but two reference type variables can refer to the same location. The result is that
                        changing the contents of one will affect the contents of the other.</p>
                    <p>Variables can be compared for equality and depending on the type, various <a href="#Equality_operators">equality operators</a> can be applied. When
                        two variables are compared, how value and reference types are evaluated differs. In most cases if the two are value types, then they will be equal
                        if the values they contain are the same, whereas two reference types will be the same if they both refer to the same location in memory. A notable
                        exception is the <a href="#record">record</a> which is a reference type with value type equality.</p>
                    <p><em>Note:</em><i> Various type's <a href="#Members">members</a> allow the <a href="#Parameters,_signatures_and_overloading">passing in</a> of
                        variables as arguments. When this occurs, how the variable is affected depends on whether it is a value or reference type and whether any
                        <a href="#Modifiers">modifiers</a> have been applied.</i></p>
                    <!-- SECTION null -->
                    <h3 id="null">null</h3>
                    <p>In C#, when a reference type variable has been declared but does not refer to an object, its value will be <i>null</i>. Using the previous analogy,
                        this is like a contact in an address book which only has the person's name but without any address information. Within the context of nullability,
                        a type that can be assigned null is said to be nullable and one that isn't, non-nullable. A nullable type can also be assigned null through use of
                        the <code>null</code> keyword. If an attempt is made to access a <a href="#Members">member</a> of a nullable type, known as <i>dereferencing</i>,
                        or an element of an array where either has a value of null, a <a href="#Errors_and_Exception_Handling">NullReferenceException</a> will be thrown.
                        A normal value type can't be assigned null and attempting to do so will result in a <a href="#Syntax_errors">syntax error.</a> Normal value types
                        have a default value when declared which for the built-in types is <code>false</code> for a <code>bool</code> and <code>0</code> for all numeric
                        types. A value type can be made nullable when declared by using the <code>?</code> suffix in the
                        <span class="nowrap">form <code>T? a;</code>.</span> It can then be assigned null with the null value being in addition to the type's existing
                        range of possible values.</p>
                    <p>More recently C# introduced <i>nullable aware context</i> and <i>nullable reference types</i> to help in avoiding null reference exceptions.
                        Similarly, as with value types, in a nullable aware context a reference type declared in the form <code>T a;</code> is non-nullable and
                        <code>T? a;</code> is nullable. Unlike the value type however, both the nullable and non-nullable types can still be assigned null but in a
                        nullable aware context, assigning a non-nullable type null will result in a warning in the code editor. The nullable aware context
                        also produces other warnings such as 'dereferencing of a possibly null reference'. It should be noted that there are situations, even within the
                        nullable aware context, in which the compiler is unable to determine that a non-nullable type has been initialized null and will be unable to
                        produce a warning. There may also be occasions where the compiler is unable to determine that a variable or expression that is being assigned to a
                        non-nullable type variable can't be null. In this case you can apply the <a href="#Null-forgiving_operator">null-forgiving operator</a>
                        <code>!</code> in the form of <code>T!</code> to suppress the warning.</p>
                        <p>Some restrictions apply to a nullable type.</p>
                        <ul>
                            <li>It must be checked and confirmed not to be null before dereferencing.</li>
                            <li>It can't be used as a <a href="#Inheriting_types">base type</a> or implemented as an <a href="#interface">interface.</a></li>
                            <li>It can't be used as an object's initialization.</li>
                            <li>It can't be used as part of type testing or be the type of a member access expression.</li>
                        </ul>

                        <p>Nullable aware context can be applied to each code file as required through use of nullable annotation or globally to the project as a whole in
                            the project's properties. There are four levels nullable aware context, <code>disable</code>, <code>enable</code>, <code>warnings</code> and
                            <code>annotations</code>, details of which are in the <a href="#References">Microsoft C# reference documentation</a> along with examples of
                            the various null reference warnings and  how code can be corrected to prevent the errors they pose. Starting with Visual Studio 2022 and
                            .NET 6.0, most of the <i>new project</i> templates set nullable aware context to <code>enabled</code> at the project level when a new project
                            is created.</p>
                        <p><em>Note:</em><i> Declaring a variable as nullable when the nullable aware context is disabled will result in a warning.</i></p>
                    <!-- !SECTION null -->

                    <!-- SECTION Variable lifetime -->
                    <h3 id="Variable_lifetime">Variable lifetime</h3>
                    <p>Every computer has a finite amount of memory and when an object is no longer in use, it is essential to reclaim the memory it occupies or the
                        memory will become filled with unused objects. This must be done while a variable is still in <a href="#Scope">scope</a> otherwise it will become
                        unreachable and without a reference to it the memory, can no longer be reclaimed resulting in a <i>memory leak</i>. With an unmanaged programming
                        language, you are required to explicitly keep track of unreferenced objects and free up memory yourself but with a managed language, much of this
                        work is automatically done for you. C#, being a managed language, provides a memory management system called the <i>garbage collector</i> that
                        automatically tracks objects and when they are no longer referenced, marks them for garbage collection. When the memory is actually reclaimed is
                        completely under the control of the garbage collector.</p>
                    <p><em>Note:</em><i>C# also provides a WeakReference type that can still be garbage collected under certain conditions, even though there is a
                    reference to it.</i></p>
                    <p> While this takes care of most of the unmanaged side of memory management there are still
                        situations where memory leaks can occur even in a managed environment. It is up to the developer to put in place practices that prevent
                            this from happening.</p>



                    <p>The lifetime of a variable is the part of the program execution in which the variable is guaranteed to be stored in memory. For a
                        <a href="#Scope">local variable</a> this is at least for the time in which the execution enters and until it leaves its <a href="#Scope">scope</a>
                        within which the variable is contained. The lifetime can become extended if the variable is used as part of an
                        <a href="#Anonymous_functions">anonymous function.</a> In which case it remains in use until the <a href="#delegate">delegate</a> created by the
                        anonymous function and other objects that reference the variable are themselves, eligible for garbage collection. If a scope containing a local
                        variable is entered iteratively a new instance of the variable is created each time and lasts for a single iteration. The same applies for the
                        <i>iteration variable</i> in a <a href="#foreach_statement">foreach statement.</a> The lifetime of an instance field is the same as that of its
                        type's container and for a static variable is that of the application.
                        </p>
                    <!-- !SECTION Variable lifetime -->

                    <!-- SECTION Variable declaration and assignment -->
                    <h3 id="Variable_declaration_and_assignment">Variable declaration and assignment</h3>
                    <p>The following applies to variables</p>
                    <ul>
                        <li>A variable must be declared with a type before it can be used</li>
                        <li>A <a href="#Scope">local variable</a> can only be declared once within the same scope</li>
                        <li>A <a href="#Scope">local variable</a> must be assigned a value before it can be used</li>
                        <li>A variable's type cannot be changed</li>
                        <li>A constant must be assigned a value when declared</li>
                        <li>A constant's type and value cannot be changed</li>
                        <li>A <a href="#Scope">local variable</a> can be implicitly or explicitly declared</li>
                        <li>A <a href="#Access_modifiers">local variable's accessibility</a> cannot be changed with an <a href="#Access_modifiers">access modifier
                        </a></li>
                        <li>A value type and value cannot be assigned <a href="#null">null</a></li>
                    </ul>
                    <!-- TODO complete Variable lifetime -->

                    <p>In the following the first few examples demonstrate explicit declaration where you tell the editor what the variable's type is before it is used.
                        The first statement <code>int i;</code> declares the variable <code>i</code> to be a type of integer and then in <code>i = 1;</code> the
                        <code>=</code> <a href="#Assignment_operator">operator</a> assigns the literal value 1 to it. In <code>double j = 2.4</code> both the floating
                        point type <code>double j</code> is declared and the value 2.4 is assigned to it. In <code>int k = i + 3;</code> first the
                        <a href="#Expressions_and_Operators">expression</a> <code>i + 3</code> is evaluated then the resultant value 4 is assigned
                        <span>to <code>k</code>.</span> In <code>const double pi = 3.1415;</code> the constant <code>pi</code> is declared as a type <code>double</code>
                        and is assigned the value 3.1415.</p>
                    <p>C# also allows for <i>implicit</i> declaration through the use of the <code>var</code> keyword. This tells the compiler to determine the type of
                        variable to store based on the expression on the right side of the <code>=</code> operator. In the statement <code>var n = 3;</code> the compiler
                        interprets the 3 as an integer and based on its size assigns <code>n</code> a type of <code>int</code> and the value 3. In
                        <code>var d = 3.0</code> 3.0 is interpreted as a floating-point number and <code>d</code> is assigned a type of <code>double</code> with a value
                        <code>3.0</code> . With <code>var x = i + n;</code> summing an <code>int</code> with an <code>int</code> results in an <code>int</code> so
                        <code>x</code> will be an <span class="nowrap"><code>int</code>.</span> In <code>var y = i + d;</code>summing an <code>int</code> with a
                        <code>double</code> will result in a <code>double</code> so <code>y</code> is a <span class="nowrap"><code>double</code>.</span> As can be seen
                        care must be taken when using <code>var</code> as it is easy to end up with a type that was not expected. It should also be mentioned that there
                        is much debate as to the use of the <code>var</code> keyword which will be left for the reader to research.</p>
                    <p>The next eight <code>Console.WriteLine</code> statements write the values of i, j, k, pi, n, d, x and y to the console. Note that the default
                        behavior of <code>Console.WriteLine</code> is to truncate a number if the fractional part is zero so <code>d</code> and <code>y</code> are written
                        as 3 and 4 respectively. The four statements that follow introduce the <code>GetType()</code> <a href="#Methods">method.</a> As the name suggests
                        this method gets the type of the variable supplied. <code>Console.WriteLine</code> then writes these to the console. When run, the program will
                        write the result as shown in the example to the console. For <code>n</code> and <code>x</code> this will be <code>System.Int32</code> and for
                        <code>d</code> and <code>y</code> <code>System.Double</code> where <code>System</code> is a <a href="#Namespaces">namespace.</a> C# has a number
                        of <a href="#Keywords_and_Specifications">keywords</a> for commonly used types. In this example <code>int</code> is the keyword for
                        <code>System.Int32</code> and <code>double</code> the keyword <code>System.Double</code> (note the capital 'D'). Both can be used in code but in
                        general the keyword is favoured by most.</p>
<pre><code>namespace Variables
{
    class Program
    {
        static void Main(string[] args)
        {
            // First declare an integer i then assign the value 1 to it
            int i;
            i = 1;

            // Both declare and assign 2.4 to double variable j
            double j = 2.4;

            // Evaluate the expression i + 3 right and assign it to k
            int k = i + 3;

            // Declare a double type constant pi
            // and assigns it the value 3.1415
            const double pi = 3.1415;

            // In the following the 'var' keyword tells the compiler to
            // select the type dependent on the operand being assigned

            // 3 is interpreted as an integer and assigned to integer variable n
            var n = 3;

            // 3.0 is interpreted as a double and assigned to double variable d
            var d = 3.0;

            // The sum of the two integers i and n is evaluated
            // and the resultant integer 4 is assigned to x
            var x = i + n;

            // The sum of the integer i and the double d is evaluated
            // and the resultant double 4.0 is assigned to y
            var y = i + d;

            // Writes the value of variables i, j and k to the console
            Console.WriteLine(i);
            Console.WriteLine(j);
            Console.WriteLine(k);

            // Writes the value of const double pi to the console
            Console.WriteLine(pi);

            // Writes the value of variables n, d, x and y to the console
            // Note - d and y will be written as 3 and 4 respectively as
            // Console.WriteLine does not include the fractional part
            // if it is zero
            Console.WriteLine(n);
            Console.WriteLine(d);
            Console.WriteLine(x);
            Console.WriteLine(y);

            // Determines the type of variables n, d, x and y
            // and writes it to the console
            Console.WriteLine(n.GetType());
            Console.WriteLine(d.GetType());
            Console.WriteLine(x.GetType());
            Console.WriteLine(y.GetType());
        }
    }
}
// The example writes the following to the console
// 1
// 2.4
// 4
// 3.1415
// 3
// 3
// 4
// 4
// System.Int32
// System.Double
// System.Int32
// System.Double
</code></pre>
                    <!-- !SECTION Variable declaration and assignment -->
                    <!-- SECTION Variable declaration and assignment syntax errors -->
                    <h3 id="Variable_declaration_and_assignment_syntax_errors">Variable declaration and assignment syntax errors</h3>
                    <p><a href="#Syntax_errors">Syntax errors</a> that occur when declaring and assigning variables will prevent the program from being compiled. The editor identifies these errors
                        and notifies you by placing a <u class="error">red wavy underline</u> under the part of the statement that is causing them. By moving the mouse
                        over the line, a message will popup detailing the error. Some errors can be quite cryptic so following are a few examples and an explanation of
                        what they mean.</p>
                    <p><i>The name 'p' does not exist in the current context</i> - Before a variable can be used, it must first be declared either explicitly with
                        the use of a type followed by an identifier <code>int p;</code> or implicitly by use of the <code>var</code> keyword <code>var p = 0;</code></p>
                    <p><i>A local variable or function 'i' is already defined in this scope</i> - Only one unique instance of a variable can exist within a
                        <a href="#Scope">scope.</a> As <code>int i = 1;</code> has already declared variable <code>i</code>, the next statement
                        <code>int <u class="error">i</u> = 2;</code> is evaluated by the editor as an attempt to declare a second
                        <span class="nowrap">variable <code>i</code>.</span></p>
                    <p><i>Cannot use variable 'b' before it is declared</i> - C# executes statements in the order they appear in the code from top down. In this case
                        <code><u class="error">b</u> = 1;</code> has been written above <span class="nowrap"><code>int b;</code>.</span> Reversing the order of these two
                        statements will resolve this error.</p>
                    <p><i>Use of unassigned local variable 'k'</i> - C# requires variables declared within a local <a href="#Scope">scope</a> to be assigned a value
                        before they can be used. Here <code>int k;</code> declares that a variable <code>k</code> of type <code>int</code> but does not assign it a value.
                        When declaring a variable a value can simultaneously be assigned to it through the use of the <code>=</code>
                        <a href="#Assignment_operator">operator</a> as in <span class="nowrap"><code>int k = 1;</code>.</span> Alternatively, a variable can be assigned a
                        value after being declared and before being used such as adding <code>k = 1;</code> after <code>int k;</code> and before
                        <span class="nowrap"><code>j = i + k;</code> .</span> Note that it is only variables on the right side of the <code>=</code> operator that need to
                        have a value assigned so the use of the <code>j</code> which is declared but not assigned a value on the left side is valid. C# also has the
                        <code>default</code> keyword which allows any variable to be assigned its default value such as
                        <span class="nowrap"><code>int k = default;</code> .</span> In this case <code>k</code>  would have a value of 0.</p>
                    <p><i>Cannot implicitly convert type 'double' to 'int'. An explicit conversion exists (Are you missing a cast?)</i> - In all the following cases
                        an attempt is being made to assign a variable of type <code>int</code> a value of type <span class="nowrap"><code>double</code>.</span> C# does
                        not allow the assignment of a value to a variable that could unwittingly result in a conversion that produces a loss of information. By assigning
                        a floating-point <code>double</code> to an <code>int</code>, the fractional part after the decimal point could be lost. As can be seen from the
                        examples it may not be obvious at first that a conversion is occurring.</p>
                    <p><code>i = <u class="error">d</u>;</code> an attempt is being made to assign the value in <code>d</code> which was declared a
                        <code>double</code> to <code>i</code> which was declared an <span class="nowrap"><code>int</code>.</span></p>
                    <p><code>i = <u class="error">3.0</u>;</code> the variable <code>i</code> which was declared as an <code>int</code> is being assigned the literal
                        <code>3.0</code> which is interpreted as a <code>double</code> by the editor.</p>
                    <p><code>b = <u class="error">i + d</u>;</code> as <code>i</code>is an <code>int</code> and <code>d</code> a <code>double</code> the result of
                     <code>i + d</code> is first evaluated by the editor to be a <code>double</code> so assigning this to <code>b</code> produces the error.</p>
                    <p><code>b = <u class="error">i + x</u>;</code> in the previous statement <code>var x = i + d;</code> <code>i + d</code> was evaluated by the editor
                        to be a <code>double</code> and is allowed to be assigned to <code>x</code> through the use of the <code>var</code> keyword. This results in
                        <code>i + x</code> also being interpreted as a <code>double</code> so assigning it to the int <code>b</code> produces the error.</p>
                    <p><code>d = i;</code> there is no possibility of information loss from an <code>int</code> to a <code>double</code> so this is allowed.</p>
                    <p><em>Note:</em> <i>C# has a number of explicit methods that allow for a <a href="#Type_conversion">conversion</a> that results in information loss
                        without resulting in an error.</i></p>
                    <p><i>The left-hand side of an assignment must be a variable, property or indexer</i> - Here <code>pi</code> is a constant and as its value can't be
                        changed so attempting to results in this error.</p>
                    <p><i>The expression assigned to 'area' must be constant</i> - As <code>area</code> has been declared a <code>const</code> the use of the variable
                        <code>i</code> in <code>i * 3 * 3</code> produces this error.</p>
                    <p><i>Operator '+' cannot be applied to operands of type 'int' and 'bool'</i> - C# does not allow the conversion of a boolean value to a number so
                        attempting a numeric addition between an <code>int</code> and a <code>bool</code> produces this error.</p>
<pre><code>namespace VariableSyntaxErrors
{
    class Program
    {
        static void Main(string[] args)
        {
            // A red wavy line under parts of the following statements
            // indicate that a syntax error is present. When the mouse
            // is placed over the line a message will pop up with
            // details of the error. The message has been included
            // as a comment above each example

            // The name 'p' does not exist in the current context
            <u class="error">p</u> = 1;

            int i = 1;

            // A local variable or function 'i' is already defined in this scope
            int <u class="error">i</u> = 2;

            // Cannot use variable 'b' before it is declared
            <u class="error">b</u> = 1;
            int b;

            int j;
            int k;

            // Use of unassigned local variable 'k'
            j = i + <u class="error">k</u>;

            // The next four statements would create an implicit conversion
            // that would result in the fractional part of the double
            // being lost which is not allowed and so produce a syntax error

            double d = 0;

            // Cannot implicitly convert type 'double' to 'int'.
            // An explicit conversion exists (Are you missing a cast?)
            i = <u class="error">d</u>;

            // Cannot implicitly convert type 'double' to 'int'.
            // An explicit conversion exists (Are you missing a cast?)
            i = <u class="error">3.0</u>;

            d = i + 3;

            // Cannot implicitly convert type 'double' to 'int'.
            // An explicit conversion exists (Are you missing a cast?)
            b = <u class="error">i + d</u>;

            var x = i + d;

            // Cannot implicitly convert type 'double' to 'int'.
            // An explicit conversion exists (Are you missing a cast?)
            b = <u class="error">i + x</u>;

            // This is allowed as there is no loss of information
            d = i;

            const double pi = 3.1415;

            // The left-hand side of an assignment must be a variable, property or indexer
            <u class="error">pi</u> = 4;

            // The expression assigned to 'area' must be constant
            const double area = <u class="error">i * 3 * 3</u>;

            bool t = true;

            // Operator '+' cannot be applied to operands of type 'int' and 'bool'
            b = <u class="error">i + t</u>;
        }
    }
}
</code></pre>
                    <!-- !SECTION Variable declaration and assignment syntax errors -->
                    <!-- SECTION Type conversion -->
                    <h3 id="Type_conversion">Type conversion</h3>
                    <p>Following are examples of the different tools C# provides to convert built-in types.</p>
<pre><code>namespace CastingAndConversion
{
    class Program
    {
        static void Main(string[] args)
        {
            int i;
            double d = 3.9;

            // This casts the double d with a value of 3.9 to int i
            // The cast truncates the value so 3.9 becomes 3
            // The value in d remains unaffected
            i = (int)d;

            Console.WriteLine(i);
            Console.WriteLine(d);

            // This converts the double d with a value of 3.9 to int i
            // Here the value in i is rounded up to 4
            i = Convert.ToInt32(d);
            Console.WriteLine(i);

            // When the value is half way between to integers the
            // value is rounded to the nearest even integer so
            // 3.5 is rounded up to 4 and 4.5 down to 4
            // Here the value in i is rounded up to 4

            i = Convert.ToInt32(3.5);
            Console.WriteLine(i);

            i = Convert.ToInt32(4.5);
            Console.WriteLine(i);

            // The math class provides a number of math functions
            // one of which is Math.Round. The default rounding here
            // is the same as for Convert.ToInt32. The result is
            // a double so a cast to an int is also required

            i = (int)Math.Round(3.5);
            Console.WriteLine(i);

            i = (int)Math.Round(4.5);
            Console.WriteLine(i);

            // Math.Round with option to always round down
            // this time 3.5 becomes 3

            i = (int)Math.Round(3.5, MidpointRounding.ToZero);
            Console.WriteLine(i);
        }
    }
}

// The example writes the following to the console
// 3
// 3.9
// 4
// 4
// 4
// 4
// 4
// 3
</code></pre>
                    <p>To perform an explicit conversion between types, use the cast <span class="nowrap">expression <code>(T)E</code>.</span> If no conversion exists
                        from <code>E</code> to <code>T</code> a compile error will occur. It also may be possible that a conversion error is not detected until the code
                        containing it is executed during runtime in which case an <a href="#Exception">exception</a> will be thrown.</p>
<pre><code>namespace ExplicitConversion
{
    class Program
    {
        static void Main(string[] args)
        {
            // conversion from double to int results in truncation
            int number = (int)7 / 2; // number has value of 3

            Console.WriteLine(number);

            // Syntax error, cannot convert type 'int' to 'string'
            // string s = (string)number;
        }
    }
}

// The example writes the following to the console
// 3
</code></pre>
                    <!-- !SECTION Type conversion -->
                    <!-- SECTION Boxing and unboxing -->
                    <h3 id="#Boxing_and_unboxing">Boxing and unboxing</h3>
                    <p>Boxing is the converting of a value type to an <code>object</code> type and unboxing is the converting from an <code>object</code> type to a value
                        type. This is possible as <a href="#Polymorphism">polymorphism</a>, the ability to substitute any <a href="#Inheriting_types">inherited</a>
                        derived type with a base type, is a core principle of C# and the <code>object</code> type is the ultimate base type for all other types. Boxing is
                        an implicit operation whereas unboxing is explicit which means that the latter will require a cast. Boxing and unboxing have
                        mostly been replaced by generic types and should be avoided due to performance issues. Boxing requires a new
                        object to be created in memory and the combined boxing and unboxing operations can take up to 24 times longer than that of the equivalent
                        assignment of simple value and reference types. Additionally, due to the explicit cast when unboxing, knowledge is required of the type that was
                        originally boxed. The main use of boxing and unboxing now is when dealing with legacy code.</p>
                    <p> The following example demonstrate
                        boxing and unboxing a value type to and from an object.</p>
<pre><code>namespace BoxingUnboxing
{
    class Program
    {
        static void Main(string[] args)
        {
            int i = 1;

            // The value type 'i' is boxed into object 'o'.
            // This is an implicit operation so a cast is not required.
            object o = 1;

            // The previously boxed object 'o' is unboxed back into a
            // value type. Here the conversion is explicit requiring a cast.
            int j = (int)o;

            // Syntax error, cannot cast type 'int' to 'short'
            //short s = (short)o;

            Console.WriteLine($"i = {i}");
            Console.WriteLine($"o = {o}");

            i = 2;
            // When the value of 'i' is changed the value 'o' remains unchanged
            // demonstrating that 'o' is a copy of the original value of 'i'
            Console.WriteLine($"o = {o}");
        }
    }
}

// The example writes the following to the console
// i = 1
// o = 1
// o = 1
</code></pre>
                    <!-- !SECTION Boxing and unboxing -->
                    <!-- TODO complete Generics -->
                    <!-- SECTION Generics -->
                    <h3 id="Generics">Generics</h3>
                    <p>Description</p>
                    <p>CodeExample</p>
<pre><code>namespace Namespace
{
    class Program
    {
        static void Main()
        {

        }
    }
}
</code></pre>
                    <!-- !SECTION Generics -->
                </article>
            </section>
            <!-- !SECTION Variables, Constants, Types and Literals -->
            <!-- SECTION Characters and Strings -->
            <section class="main-section" id="Characters_and_Strings">
                <header><h2>Characters and Strings</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION character -->
                    <h3 id="character">character</h3>
                    <p>The <code>char</code> type represents a single Unicode UTF-16 character and can consists of one of:</p>
                    <ul>
                        <li>Single character literal</li>
                        <li>Simple escape sequence</li>
                        <li>Unicode character escape sequence</li>
                        <li>ASCII character escape sequence in octal notation</li>
                        <li>ASCII character escape sequence in hexadecimal notation</li>
                        <li>Unicode character escape sequence in hexadecimal notation</li>
                    </ul>
                    <p>Character literals consists of a single character in a pair of single quotes, such <span class="nowrap">as <code>'a'</code>.</span> Escape
                        sequences consist of a single backslash followed by a sequence of characters as defined in
                        <a href="#Character_specifications">Character specifications.</a></p>
                    <p>The following example demonstrates declaring and using a character</p>
<pre><code>namespace Characters
{
    class Program
    {
        static void Main(string[] args)
        {
            // character1 is declared and assigned the character 'a'
            char character1 = 'a';

            // tab is declared and assigned the simple escape
            // character for the horizontal tab character
            char tab = '\t';

            // character2 is declared and assigned the character 'b'
            // by using the Unicode escape sequence for 'b'
            char character2 = '\u0062';

            // Write all characters to the console
            Console.Write(character1);
            Console.Write(tab);
            Console.Write(character2);
        }
    }
}

// The example writes the following to the console
// a       b
</code></pre>
                    <!-- !SECTION character -->
                    <!-- SECTION string -->
                    <h3 id="string">string</h3>
                    <p>A string is a sequence of Unicode (UTF-16) characters that represent text. The maximum length of a string is based on a memory size of 2GB which
                        is approximately 1 billion characters. String literals can be regular or verbatim and/or interpolated. Each can contain zero or more characters
                        enclosed in a pair of double quotes.</p>
                    <p>Regular string literals can contain escaped characters. They can't span multiple lines so to split a statement with a long string literal across
                        two or more lines, each part of the string on each line must first be enclosed in a pair of double quotes. The <code>+</code> concatenation
                        operator is then placed between each string to join them together.</p>
                    <p>Verbatim string literals are prefixed with the verbatim <span class="nowrap">identifier <code>@</code>.</span> Any escaped character will be
                        interpreted verbatim except <code>'\"'</code> which will be interpreted as one double quote. Verbatim string literals can span multiple lines.
                        There must be no white space between the <code>@</code> character and the string.</p>
                    <p>Interpolated strings are prefixed with the interpolation identifier <code>$</code> which indicates that they may contain <i>interpolation
                        expressions</i>. These can contain variables and other special characters that instruct the compiler how to format the string at
                        <span class="nowrap">runtime</span>. Interpolation expressions are wrapped in a pair of braces. There must be no white space between the
                        <code>$</code> identifier and the string. To use a brace as a character in an interpolated string two braces <code>{{</code> or
                        <code>}}</code> must be used. Interpolation expressions include a vast range of options, information of which can be found in the
                        <a href="#References">Microsoft C# reference documentation</a></p>
                    <p>The interpolation identifier can be used in conjunction with the verbatim identifier and the order of the identifiers doesn't matter.</p>
                    <p>Following are examples of string usage.</p>
<pre><code>namespace Strings
{
    class Program
    {
        static void Main(string[] args)
        {
            // Get the current date and time
            var now = DateTime.Now;
            Console.WriteLine("Regular string");
            Console.WriteLine(@"Verbatim string");
            Console.WriteLine("Regular string with an escaped \t tab");
            Console.WriteLine(@"Verbatim string with an escaped \t tab");
            Console.WriteLine("Sally said to say \"Hi\" to you");
            Console.WriteLine(@"Sally said to say ""Hi"" to you");
            Console.WriteLine("\\\\server\\folder\\file.exe");
            Console.WriteLine(@"\\server\folder\file.exe");
            // The following three lines are concatenated
            // through use of the + operator
            Console.WriteLine("Regular string " +
                "Hello " +
                        "world");
            Console.WriteLine(@"The verbatim string
        will appear as it is
                    written in code");
            int number = 123;
            Console.WriteLine($"The number is {number}");
            Console.WriteLine($"Opening brace {{ closing brace }}");
            Console.WriteLine(@$"Today is {now.DayOfWeek}
its now {now:HH:mm}");

            //// Compile error: Can't split regular string across two lines
            //var k = "Hello
            //            world";

            // Create a variable that is set to Environment.NewLine
            // and use it in an interpolated string to write a
            // blank line before the next line of text
            string nl = Environment.NewLine;
            Console.WriteLine($"{nl}This sentence is written after a blank line");
        }
    }
}

// The example writes the following to the console
// Regular string
// Verbatim string
// Regular string with an escaped   tab
// Verbatim string with an escaped \t tab
// Sally said to say "Hi" to you
// Sally said to say "Hi" to you
// \\server\folder\file.exe
// \\server\folder\file.exe
// Regular string Hello world
// The verbatim string
//         will appear as it is
//                     written in code
// The number is 123
// Opening brace { closing brace }
// Today is Saturday
// its now 19:32

// This sentence is written after a blank line
</code></pre>
                    <!-- !SECTION string -->
                    <!-- SECTION String immutability and StringBuilder -->
                    <h3 id="String_immutability_and_StringBuilder">String immutability and StringBuilder</h3>
                    <p>Strings are immutable, that is once created they cannot be changed. C# operators that appear to change a string actually creates a new modified
                        copy of the original string. This means that the performance of a program can suffer when a string is repeatedly manipulated. In these cases,
                        C# provides StringBuilder which like a string, also represents a sequence of characters but unlike a string is mutable allowing changes to the
                        sequence. When the operations to the StringBuilder sequence have been completed it can be converted to a string.</p>
                    <p>The following example demonstrates how to use StringBuilder</p>
<pre><code>using System.Text;

namespace StringBuilderExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // Create a new instance of StringBuilder
            StringBuilder builder = new();
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");

            // Convert the StringBuilder sequence to a string
            String message = builder.ToString();

            // Write the string to the console;
            Console.WriteLine(message);
        }
    }
}

// The example writes the following to the console
// Hello World
// Hello World
// Hello World
// Hello World
</code></pre>
                    <!-- !SECTION String immutability and StringBuilder -->
                </article>
            </section>
            <!-- !SECTION Characters and Strings -->
            <!-- SECTION Expressions and Operators -->
            <section class="main-section" id="Expressions_and_Operators">
                <header><h2>Expressions and Operators</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>An expression is a collection of operands and operators that together can be evaluated and assigned to a variable. If the evaluation is invalid the
                        result won't be assigned and the variable's value will remain unchanged. This may also result in an exception that can end the program. Following
                        are examples of expressions and operators.</p>
                    <!-- SECTION Expression example -->
                    <h3 id="Expression_example">Expression example</h3>
                    <p>Here <code>1</code> and <code>2</code> are operands and <code>+</code> is the operator</p>
<pre><code>int i = 1 + 2;
</code></pre>
                    <p>Following is a list of expressions that demonstrates the result of the operators. The examples are shown in order of arithmetic precedence.
                        Round brackets <code>( )</code> can be used to change the order.</p>
                    <!-- !SECTION Expression example -->
                    <!-- SECTION Assignment operator -->
                    <h3 id="Assignment_operator">Assignment operator <code>=</code></h3>
                    <p>Assigns a value to a variable</p>
<pre><code>namespace AssignmentOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            // assigns literal value 1 to int type variable a
            int a = 1;
            Console.WriteLine($"a = {a}");
        }
    }
}

// The example prints the following to the console
// a = 1
</code></pre>
                    <!-- !SECTION Assignment operator -->
                    <!-- SECTION Equality operators -->
                    <h3 id="Equality_operators">Equality operators</h3>
                    <p>Evaluates whether two operands are equal</p>
<pre><code>namespace EqualityOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            int b = 1;

            // equality operator: ==
            // evaluates if two value types are equal
            bool x = a == b;
            Console.WriteLine($"x = {x}");

            // inequality operator: !=
            // evaluates if two value types are not equal
            bool y = a != b;
            Console.WriteLine($"y = {y}");
        }
    }
}

// The example prints the following to the console
// x = True
// y = False
</code></pre>
                    <!-- !SECTION Equality operators -->
                    <!-- SECTION Comparison operators -->
                    <h3 id="Comparison_operators">Comparison operators</h3>
                    <p>Compares the values of two operands</p>
<pre><code>namespace ComparisonOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            int b = 2;

            // less than operator: &lt;
            // evaluates if the left operand is less than the right
            bool w = a &lt; b;
            Console.WriteLine($"w = {w}");

            // greater than operator: &gt;
            // evaluates if the left operand is greater than right
            bool x = a &gt; b;
            Console.WriteLine($"x = {x}");

            // less than or equal to operator: &lt;=
            // evaluates if the left operand is less than or equal to the right
            bool y = a &lt;= b;
            Console.WriteLine($"y = {y}");

            // greater than or equal to operator: &gt;=
            // evaluates if the left operand is greater than or equal to the right
            bool z = a &gt;= b;
            Console.WriteLine($"z = {z}");
        }
    }
}

// The example prints the following to the console
// w = True
// x = False
// y = True
// z = False
</code></pre>
                    <!-- !SECTION Comparison operators -->
                    <!-- SECTION Arithmetic operators -->
                    <h3 id="Arithmetic_operators">Arithmetic operators</h3>
                    <p>Applies an arithmetical operation between two operands</p>
<pre><code>namespace ArithmeticOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 3;
            int b = 3;
            int c = 3;
            int d = 3;

            // postfix increment operator: x++
            // after assigning a's value to e adds 1 to a
            int e = a++;
            Console.WriteLine($"a = {a}, e = {e}");

            // postfix decrement operator: x--
            // after assigning b's value to f subtracts 1 from b
            int f = b--;
            Console.WriteLine($"b = {b}, f = {f}");

            // prefix increment operator: ++x
            // adds 1 to c then assigns c's value to g
            int g = ++c;
            Console.WriteLine($"c = {c}, g = {g}");

            // prefix decrement operator: --x
            // subtracts 1 from d then assigns d's value to h
            int h = --d;
            Console.WriteLine($"d = {d}, h = {h}");

            // unary minus operator: -
            // sign of -2 is changed and i has value 2
            int i = - -2;
            Console.WriteLine($"i = {i}");

            // multiplication operator: *
            // multiplies 3 by 2
            int j = 3 * 2;
            Console.WriteLine($"j = {j}");

            // The division operator rounds towards 0 when both operators are integers

            // division operator: /
            // divides 3 by 2
            double k = 3 / 2;
            Console.WriteLine($"k = {k}");

            // division operator: /
            // divides 3 by 2
            double l = -3 / 2;
            Console.WriteLine($"l = {l}");

            // division operator: /
            // divides 3 by double 2
            double m = 3 / 2d;
            Console.WriteLine($"m = {m}");

            // remainder operator, also called the modulus operator: %
            // returns the remainder after dividing 3 by 2
            int n = 3 % 2;
            Console.WriteLine($"n = {n}");

            // addition operator: +
            // adds 2 to 3
            int o = 3 + 2;
            Console.WriteLine($"o = {o}");

            // subtraction operator: -
            // subtracts 2 from 3
            int p = 3 - 2;
            Console.WriteLine($"p = {p}");
        }
    }
}

// The example prints the following to the console
// a = 4, e = 3
// b = 2, f = 3
// c = 4, g = 4
// d = 2, h = 2
// i = 2
// j = 6
// k = 1
// l = -1
// m = 1.5
// n = 1
// o = 5
// p = 1
</code></pre>
                    <!-- !SECTION Arithmetic operators -->
                    <!-- SECTION Boolean logic operators -->
                    <h3 id="Boolean_logic_operators">Boolean logic operators</h3>
                    <p>Applies a boolean logic operation between two operands</p>
<pre><code>namespace BooleanLogicOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            bool a = true;
            bool b = false;

            // negation operator: !
            // A variable prefixed with !
            // inverts the boolean value
            bool c = !a;
            Console.WriteLine($"c = {c}");
            bool d = !b;
            Console.WriteLine($"d = {d}");

            // and operator: &
            // returns true only if both operands are true
            bool e = a &amp; a;
            Console.WriteLine($"e = {e}");
            bool f = a &amp; b;
            Console.WriteLine($"f = {f}");
            bool g = b &amp; a;
            Console.WriteLine($"g = {g}");
            bool h = b &amp; b;
            Console.WriteLine($"h = {h}");

            // exclusive or operator: ^
            // returns true if only one operand is true
            bool i = a ^ a;
            Console.WriteLine($"i = {i}");
            bool j = a ^ b;
            Console.WriteLine($"j = {j}");
            bool k = b ^ a;
            Console.WriteLine($"k = {k}");
            bool l = b ^ b;
            Console.WriteLine($"l = {l}");

            // or operator: |
            // returns true if either operand is true
            bool m = a | a;
            Console.WriteLine($"m = {m}");
            bool n = a | b;
            Console.WriteLine($"n = {n}");
            bool o = b | a;
            Console.WriteLine($"o = {o}");
            bool p = b | b;
            Console.WriteLine($"p = {p}");
        }
    }
}

// The example prints the following to the console
// c = False
// d = True
// e = True
// f = False
// g = False
// h = False
// i = False
// j = True
// k = True
// l = False
// m = True
// n = True
// o = True
// p = False
</code></pre>
                    <!-- !SECTION Boolean logic operators -->
                    <!-- SECTION Bitwise and shift operators -->
                    <h3 id="Bitwise_and_shift_operators">Bitwise and shift operators</h3>
                    <p>Applies operations on the individual bits of an integral numeric or <a href="#Characters">character</a> type</p>
<pre><code>namespace BitwiseAndShiftOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            // Define variables with binary literals
            int a = 0b_0000_1111_0000_1111_0000_1111_0000_1111;

            // Bitwise complement operator ~ produces a bitwise complement.
            int b = ~a;
            Console.WriteLine($"before: {ConvertToString(a, 32)}");
            Console.WriteLine($"after:  {ConvertToString(b, 32)}\n");

            byte c = 0b_0000_0110;
            byte d = 0b_0000_1010;

            // Left-shift operator &lt;&lt; shifts the bits left by the specified amount.
            int e = c &lt;&lt; 2;
            Console.WriteLine($"before: {ConvertToString(c, 8)}");
            Console.WriteLine($"after:  {ConvertToString(e, 8)}\n");

            // Right-shift operator &gt;&gt; shifts the bits right by the specified amount.
            int f = c &gt;&gt; 2;
            Console.WriteLine($"before: {ConvertToString(c, 8)}");
            Console.WriteLine($"after:  {ConvertToString(f, 8)}\n");

            Console.WriteLine($"a:      {ConvertToString(c, 8)}");
            Console.WriteLine($"b:      {ConvertToString(d, 8)}\n");

            // Logical AND operator &amp; produces logical AND of 2 operands.
            int g = c &&amp; d;
            Console.WriteLine($"AND:    {ConvertToString(g, 8)}");

            // Logical OR operator | produces logical OR of 2 operands.
            int h = c | d;
            Console.WriteLine($"OR:     {ConvertToString(h, 8)}");

            // Logical exclusive OR operator ^ produces logical
            // exclusive OR, also known as XOR, of 2 operands.
            int i = c ^ d;
            Console.WriteLine($"XOR:    {ConvertToString(i, 8)}");
        }

        // Returns a string representation of the binary value
        // left padded with the specified number of zeros
        static string ConvertToString (int value, int padding)
        {
            var s = Convert.ToString(value, 2);
            return s.PadLeft(padding, '0');
        }
    }
}

// The example writes the following to the console
// before: 00001111000011110000111100001111
// after: 11110000111100001111000011110000

// before: 00000110
// after: 00011000

// before: 00000110
// after: 00000001

// a: 00000110
// b: 00001010

// AND: 00000010
// OR: 00001110
// XOR: 00001100
</code></pre>
                    <!-- !SECTION Bitwise and shift operators -->
                    <!-- SECTION Compound assignment operators -->
                    <h3 id="Compound_assignment_operators">Compound assignment operators</h3>
                    <p>An expression using an operator <code>op</code> in the form <code>x op= y</code> is equivalent to <code>x = x op y</code></p>
<pre><code>namespace CompoundAssignmentOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 6;
            int b = 6;
            int c = 6;
            int d = 6;

            // compound operator: +=
            // adds 1 to a's current value 6 and assigns it back to a
            a += 1;
            Console.WriteLine($"a = {a}");

            // compound operator: -=
            // subtracts 1 from b's current value 6 and assigns it back to b
            b -= 1;
            Console.WriteLine($"b = {b}");

            // compound operator: *=
            // multiplies c's current value 6 by 2 and assigns it back to c
            c *= 2;
            Console.WriteLine($"c = {c}");

            // compound operator: /=
            // divides d's current value 6 by 2 and assigns it back to d
            d /= 2;
            Console.WriteLine($"d = {d}");

            bool e = true;
            bool f = true;
            bool g = true;

            // compound operator: &=
            // evaluates a logical 'and' with r's current value assigns it back to b
            e &= false;
            Console.WriteLine($"e = {e}");

            // compound operator: |=
            // evaluates a logical 'or' with f's current value assigns it back to b
            f |= true;
            Console.WriteLine($"f = {f}");

            // compound operator: ^=
            g ^= false;
            Console.WriteLine($"g = {g}");
        }
    }
}

// The example prints the following to the console
// a = 7
// b = 5
// c = 12
// d = 3
// e = False
// f = True
// g = True
</code></pre>
                    <!-- !SECTION Compound assignment operators -->
                    <!-- SECTION Conditional operator ? -->
                    <h3 id="Conditional_operator">Conditional operator <code>?:</code></h3>
                    <p>The conditional operator <code>?:</code>, also known as the ternary conditional operator takes the form
                        <span><code class="nowrap">x = predicate ? a : b</code>.</span> If the predicate is true then the expression returns <code>a</code>, else it
                        returns <span class="nowrap"><code>b</code>.</span> Both <code>a</code> and <code>b</code> must be of the same type. The conditional operator can
                        also be used as a shorthand way to replace combined <code>if</code> and <code>else</code> statements. Conditional statements can be nested though
                        doing so can make the code hard to read.</p>
<pre><code>namespace ConditionalOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;

            string x = a == 1 ? "Yes" : "No";
            Console.WriteLine($"x = {x}");

            string y = a == 2 ? "Yes" : "No";
            Console.WriteLine($"y = {y}");
        }
    }
}

// The example prints the following to the console
// x = Yes
// y = No
</code></pre>
                    <!-- !SECTION Conditional operator ? -->
                    <!-- SECTION Conditional and operator -->
                    <h3 id="Conditional_and_operator">Conditional 'and' operator <code>&&</code></h3>
                    <p>In the expression <code>x = a && b</code> <code>x</code> is true if both <code>a</code> and <code>b</code> are true otherwise <code>x</code> is
                        false. If <code>a</code> is false <code>b</code> is not evaluated. This is useful in a situation where, if <code>a</code> is false evaluating
                        <code>b</code> would produce an invalid condition that could result in an exception.</p>
<pre><code>namespace ConditionalAndOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            int b = 1;
            int c = 0;

            // a == 1 is true so b == 1 is also evaluated
            bool x = a == 1 && b == 1;
            Console.WriteLine($"x = {x}");

            // c == 1 is true so b == 1 is not evaluated
            bool y = c == 1 && b == 1;
            Console.WriteLine($"y = {y}");

            // c != 0 is false so a == b / c is not evaluated
            // which prevents a divide by 0 exception
            bool z = c != 0 && a == b / c;
            Console.WriteLine($"z = {z}");
        }
    }
}

// The example prints the following to the console
// x = True
// y = False
// z = False
</code></pre>
                    <!-- !SECTION Conditional and operator -->
                    <!-- SECTION Conditional or operator -->
                    <h3 id="Conditional_or_operator">Conditional 'or' operator <code>||</code></h3>
                    <p>In the expression <code>x = a || b</code>, <code>x</code> is true if either <code>a</code> or <code>b</code> are true otherwise <code>x</code> is
                        false. If <code>a</code> is true <code>b</code> is not evaluated. This is useful in a situation where, if <code>a</code> is true evaluating
                        <code>b</code> would produce an invalid condition that could result in an exception.</p>
<pre><code>namespace ConditionalOrOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            int b = 1;
            int c = 0;

            // a == 1 is true so b == 1 is not evaluated
            bool x = a == 1 || b == 0;
            Console.WriteLine($"x = {x}");

            // c == 1 is false so b == 1 is evaluated
            bool y = c == 1 || c == 1;
            Console.WriteLine($"y = {y}");

            // c == 0 is true so a == b / c is not evaluated
            // which prevents a divide by 0 exception
            bool z = c == 0 || a == b / c;
            Console.WriteLine($"z = {z}");
        }
    }
}

// The example prints the following to the console
// x = True
// y = False
// z = True
</code></pre>
                    <!-- !SECTION Conditional or operator -->
                    <!-- SECTION Member access operator . -->
                    <h3 id="Member_access_operator">Member access operator .</h3>
                    <p>The member access <span class="nowrap">operator <code>.</code></span> is used to access a<a href="#Namespaces">namespace</a> member or
                        <a href="#User_defined_types">type</a> <a href="#Memebers">member.</a></p>
<pre><code>namespace MemberAccessOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            // The first '.' accesses nested namespace MyInnerNameSpace
            // The second '.' accesses the class MyClass
            MyNameSpace.MyInnerNameSpace.MyClass myClass = new();

            // Here '.' accesses myClass's member PrintHelloWorld
            myClass.PrintHelloWorld();
        }
    }
}

namespace MyNameSpace
{
    namespace MyInnerNameSpace
    {
        class MyClass
        {
            public void PrintHelloWorld()
            {
                Console.WriteLine("Hello World!");
            }
        }
    }
}

// The example writes the following to the console
// Hello World!
</code></pre>
                    <!-- !SECTION Member access operator . -->
                    <!-- SECTION Index operator [] -->
                    <h3 id="Index_operator">Index operator []</h3>
                    <p>The index operator <code>[]</code> is used to access the element of an <a href="#Array">array</a>, <a href="#Indexers">indexer</a> or pointer.
                        Array indices must be of type <code>int</code>and are zero based. Attempting to access an array with an index that is not within the bounds of the
                        array's indices will result in an <a href="#Exception_handling">IndexOutOfRangeException</a> being thrown. Indexer indices can be any user defined
                        type.</p>
                    <p>In this example, as a <a href="#Dictionary_TKey_TValue">dictionary</a> type uses a <a href="#string">string</a> as its key, it can be used as
                        the index to access the value of each <code>KeyValue</code> pair.</p>
<pre><code>namespace IndexerOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] animals = { "dog", "cat", "mouse" };

            // As array indices are zero based to access
            // the second element, 1 is supplied as the index.
            Console.WriteLine($"The second animal is a {animals[1]}");

            Dictionary&lt;string, int&gt; person = new();
            person.Add("Andrew", 38);
            person.Add("Betty", 27);

            // An indexer can use a user defined type.
            Console.WriteLine($"Andrew is {person["Andrew"]} years old");
            Console.WriteLine($"Betty is {person["Betty"]} years old");
        }
    }
}

// The example writes the following to the console
// The second animal is a cat
// Andrew is 38 years old
// Betty is 27 years old
</code></pre>
                    <!-- !SECTION Index operator [] -->
                    <!-- TODO complete Null-conditional operators ?. and ?[] -->
                    <!-- SECTION Null-conditional operators ?. and ?[] -->
                    <h3 id="Null-conditional_operators">Null-conditional operators ?. and ?[]</h3>
                    <p>The null-conditional operator <code>?.</code> is used to access a <a href="#User_defined_types">type</a> <a href="#Memebers">member</a> and
                        <code>?[]</code> to access an element of an <a href="#Array">array</a> or <a href="#Indexers">indexer.</a> Providing the operand to which they
                        are applied is not <a href="#null">null</a> the member or element is returned otherwise the operator returns null.</p>
<pre><code>namespace NullConditionalOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            int[]? array = { 0, 1, 2 };

            // array is NOT null so the length property is returned
            Console.WriteLine($"array length: {array?.Length}");

            // array is NOT null so the element at index 1 is returned
            Console.WriteLine($"array[0]: {array?[1]}");

            array = null;

            // array is null so null is returned
            Console.WriteLine($"array length: {array?.Length}");

            // array is null so null is returned
            Console.WriteLine($"array[0]: {array?[1]}");
        }
    }
}

// The example writes the following to the console
// array length: 3
// array[0]: 1
// array length:
// array[0]:
</code></pre>
                    <!-- !SECTION Null-conditional operators ?. and ?[] -->
                    <!-- SECTION Null-coalescing operator -->
                    <h3 id="Null-coalescing_operator">Null-coalescing operator <code>??</code></h3>
                    <p>The null-coalescing operator <code>??</code> returns the left-hand operand if it not <a href="#null">null</a> otherwise it evaluates the
                        right-hand expression and returns the result.</p>
<pre><code>namespace NullCoalescingOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int? a = null;
            int x = a ?? 2;
            Console.WriteLine($"x = {x}");

            int? b = 1;
            int y = b ?? 2;
            Console.WriteLine($"y = {y}");
        }
    }
}

// The example prints the following to the console
// x = 2
// y = 1
</code></pre>
                    <!-- !SECTION Null-coalescing operator -->
                    <!-- SECTION Null-coalescing assignment operator -->
                    <h3 id="Null-coalescing_assignment_operator">Null-coalescing assignment operator <code>??=</code></h3>
                    <p>The null-coalescing assignment operator <code>??=</code> evaluates and assigns the-right hand expression to the left-hand variable only if the
                        variable is <a href="#null">null.</a></p>
<pre><code>namespace NullCoalescingAssignmentOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int? a = null;
            a ??= 2;
            Console.WriteLine($"a = {a}");

            int? b = 1;
            b ??= 2;
            Console.WriteLine($"b = {b}");
        }
    }
}

// The example prints the following to the console
// a = 2
// b = 1
</code></pre>
                    <!-- !SECTION Null-coalescing assignment operator -->
                    <!-- TODO complete Null-forgiving operator -->
                    <!-- SECTION Null-forgiving operator -->
                    <h3 id="Null-forgiving_operator">Null-forgiving operator <code>!</code></h3>
                    <p>The null-forgiving operator allows you to inform the compiler that a variable or expression that is being assigned to a non-nullable type variable
                        can't be <a href="#null">null.</a> This suppresses the warning that would otherwise be produced.</p>
                    <p>In the example the FormatConverter.Convert takes in an int which is boxed and passed into a nullable reference object type ConvertEventArgs.Value.
                        In the FormatConverter -------------------------------------------

                    </p>
<pre><code>namespace NullForgivingOperator
{
    public class ConvertEventArgs : EventArgs
    {
        // The Value property is a nullable reference object type
        public object? Value { get; set; }
    }

    public class FormatConverter
    {
        public event EventHandler&lt;ConvertEventArgs&gt;? Format;

        public string Convert(int value)
        {
            ConvertEventArgs args = new() { Value = value};
            Format?.Invoke(this, args);
            // If the event handler returns null Convert returns an empty string
            return args.Value?.ToString() ?? "";
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            FormatConverter converter = new();

            // The compiler cannot resolve that the e.Value passed in is
            // not null so it is suffixed with the null-forgiving operator
            converter.Format += (s, e) =&gt; { e.Value = ((int)e.Value!).ToString("n0"); };

            Console.WriteLine($"Found {converter.Convert(1999)} files");
        }
    }
}

// This example writes the following to the console
// Found 1,999 files
</code></pre>
                    <!-- !SECTION Null-forgiving operator -->
                    <!-- SECTION The Lambda and expression body definition operator -->
                    <h3 id="The_lambda_and_expression-body_definition_operator">The lambda and expression-body definition operator <code>=&gt;</code></h3>
                    <p>The <code>=&gt;</code> operator has two uses, as part of a <i>lambda expression</i> or an <i>expression-bodied member</i> definition.</p>
                    <p>A lambda expression is comprised of a set of input parameters on the left which are then passed into the body on the right which are separated
                        using the <code>=&gt;</code> operator. They are used to create <a href="#Anonymous_functions">anonymous functions.</a></p>
                    <p>An expression-bodied member definition provides a shorthand way of writing the body of a member. In this case the <code>=&gt;</code> operator is
                        used to separate the header of the member and its body which can only contain a single expression. Supported members are:</p>
                    <ul>
                        <li><a href="#Constructors">Constructors</a></li>
                        <li><a href="#Properties">Read-only Properties</a></li>
                        <li><a href="#Properties">Property accessors</a></li>
                        <li><a href="#Indexers">Indexers</a></li>
                        <li><a href="#Methods">Methods</a></li>
                        <li><a href="#Finalizers">Finalizers</a></li>
                    </ul>
                    <!-- !SECTION The Lambda and expression body definition operator -->
                    <!-- SECTION Namespace alias qualifier operator -->
                    <h3 id="Namespace_alias_qualifier_operator">Namespace alias qualifier operator <code>::</code></h3>
                    <p>The namespace alias qualifier operator is used to access members in an aliased namespace. These could be a user defined alias, an extern alias or
                        the <code>global</code> alias. It takes the form of <span class="nowrap"><code>alias::Member</code>.</span></p>
                    <p>The following example demonstrates use of the namespace alias qualifier operator</p>
<pre><code>using lists = System.Collections.Generic;

namespace AliasQualifier
{
    class Program
    {
        static void Main(string[] args)
        {
            // Use Namespace alias qualifier operator to
            // access System.Collections.Generic namespace
            lists::List&lt;string&gt; trees = new();
            trees.AddRange(new string[] { "Pine", "Birch", "Oak" });

            // Use Namespace alias qualifier operator and
            // global keyword to access System namespace
            foreach (string tree in trees)
                global::System.Console.WriteLine(tree);
        }
    }
}

// The example writes the following to the console
// Pine
// Birch
// Oak
</code></pre>
                    <!-- !SECTION Namespace alias qualifier operator -->
                </article>
            </section>
            <!-- !SECTION Expressions and Operators -->
            <!-- SECTION Conditional Statements -->
            <section class="main-section" id="Conditional_Statements">
                <header><h2>Conditional Statements</h2></header>
                <p>Conditional statements change program execution by providing alternate paths, one of which will be chosen dependent on a condition.</p>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION if else statements -->
                    <h3 id="if_else_statements">if else statements</h3>
                    <p>The <code>if</code> and <code>else</code> statements allow the program execution to branch in one of two directions based on a condition.</p>
<pre><code>namespace IfElse
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            if (a == 1)
            {
                Console.WriteLine("a equals 1");
            }
            else
            {
                Console.WriteLine("a does not equal 1");
            }
        }
    }
}

// The example prints the following to the console
// a equals 1
</code></pre>
                    <!-- !SECTION if else statements -->
                    <!-- SECTION switch statement -->
                    <h3 id="switch_statement">switch statement</h3>
                    <p>The <code>switch</code> statement allows for program execution to branch in one of multiple directions based on a condition.</p>
<pre><code>namespace Switch
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 5;
            switch (a)
            {
                case 0:
                    Console.WriteLine("none");
                    break;
                case 1:
                    Console.WriteLine("one");
                    break;
                default:
                    Console.WriteLine("many");
                    break;
            }
        }
    }
}

// The example prints the following to the console
// many
</code></pre>
                    <!-- !SECTION switch statement -->
                </article>
            </section>
            <!-- !SECTION Conditional Statements -->
<!-- TODO Add yield statement -->
<!-- TODO Add infinite while loop -->
            <!-- SECTION Iteration Statements -->
            <section class="main-section" id="Iteration_Statements">
                <header><h2>Iteration Statements</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Iteration statements, also known as loop statements, allow the execution of a code block to be repeated until an exit condition is met.</p>
                    <!-- SECTION while statement -->
                    <h3 id="while_statement">while statement</h3>
                    <p>The <code>while</code> statement iterates until a condition is met. If the condition already exists, program execution won't enter the
                        <code>while</code> loop.</p>
<pre><code>namespace WhileLoop
{
    class Program
    {
        static void Main(string[] args)
        {
            int i = 0;
            while (i &lt; 10)
            {
                Console.Write(i);
                i++;
            }
            // i is already more than 5 so
            // this loop is not entered
            while (i &lt; 5)
            {
                Console.Write(i);
                i++;
            }
        }
    }
}

// The example prints the following to the console
// 0123456789
</code></pre>
                    <!-- !SECTION while statement -->
                    <!-- SECTION do statement -->
                    <h3 id="do_statement">do statement</h3>
                    <p>The <code>do</code> statement iterates until a condition is met. At least one iteration of the <code>do</code> loop is guaranteed to be executed
                        before testing for the condition.</p>
<pre><code>namespace DoWhileLoop
{
    class Program
    {
        static void Main(string[] args)
        {
            int i = 10;
            // The loop is iterated once before exiting
            do
            {
                Console.WriteLine(i);
                i++;
            } while ( i &lt; 1);
        }
    }
}

// The example writes the following to the console
// 10
</code></pre>
                    <!-- !SECTION do statement -->
                    <!-- SECTION for statement -->
                    <h3 id="for_statement">for statement</h3>
                    <p>The <code>for</code> statement iterates a set number of times based on an exit condition.</p>
<pre><code>namespace ForLoop
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i &lt; 10; i++)
            {
                Console.Write(i);
            }
        }
    }
}

// The example prints the following to the console
// 0123456789
</code></pre>
                    <!-- !SECTION for statement -->
                    <!-- SECTION foreach statement -->
                    <h3 id="foreach_statement">foreach statement</h3>
                    <p>The <code>foreach</code> statement iterates through all members of a collection.</p>
<pre><code>namespace ForEachLoop
{
    class Program
    {
        static void Main(string[] args)
        {
            string s = "Hello world!";
            foreach (char c in s)
            {
                Console.Write(c + " ");
            }
        }
    }
}

// The example prints the following to the console
// H e l l o   w o r l d !
</code></pre>
                    <!-- !SECTION foreach statement -->
                    <!-- SECTION break -->
                    <h3 id="break">break</h3>
                    <p>The <code>break</code> keyword gives you a way of conditionally exiting a loop before completion.</p>
<pre><code>namespace Break
{
    class Program
    {
        static void Main(string[] args)
        {
            string s = "Hello world!";
            foreach (char c in s)
            {
                Console.Write(c + " ");
                if (c == ' ')
                    break;
            }
        }
    }
}

// The example prints the following to the console
// H e l l o
</code></pre>
                    <!-- !SECTION break -->
                    <!-- SECTION continue -->
                    <h3 id="continue">continue</h3>
                    <p>The <code>continue</code> keyword gives you a way of conditionally skipping an iteration. The following example uses the <code>%</code> operator in
                        conjunction with the <code>continue</code> keyword to skip all even numbers.</p>
<pre><code>namespace Continue
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 1; i &lt; 10; i++)
            {
                // for loop skips current iteration if i is even
                if (i % 2 == 0)
                    continue;
                Console.Write(i);
            }
        }
    }
}

// The example prints the following to the console
// 13579
</code></pre>
                    <!-- !SECTION continue -->
                </article>
            </section>
            <!-- !SECTION Iteration Statements -->
            <!-- SECTION Arrays and Data Structures -->
            <section class="main-section" id="Arrays_and_Data_Structures">
                <header><h2>Arrays and Data Structures</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Arrays and data structures store multiple variables together in ways that allows them to be handled and manipulated more efficiently.</p>
                    <!-- SECTION Array -->
                    <h3 id="Array">Array</h3>
                    <p>An array is like a box with separate compartments in which only one item called an <i>element</i> can be stored in each. They can be
                        single-dimensional,  multi-dimensional or jagged and all items must be of the same type. A single-dimensional array is like  one row  of
                        compartments. A multidimensional array can contain rows, columns or more up to a maximum of 32 dimensions. A jagged array is like storing a
                        separate box within each compartment of the first where each one could have its own set of dimensions with different sizes. A jagged array is
                        sometimes called an array of arrays. In addition to the examples shown here C# also provides the <i>Array</i> class which provides a set of
                        methods for manipulating arrays, information of which can be found in the <a href="#References">Microsoft C# reference documentation.</a></p>
                    <!-- !SECTION Array -->
                    <!-- SECTION Declaring, creating and initializing arrays -->
                    <h3 id="Declaring,_creating_and_initializing_arrays">Declaring, creating and initializing arrays</h3>
                    <p>An array is immutable which means that the number of dimensions and elements or <i>Length</i> of an array must be declared when the array is
                        created and can't be changed. An array can be recreated by using the <code>new</code> keyword which deletes and replaces the existing array
                        <em>and its data</em> with a new one. There are a number of different ways in which to create an array which can also include initializing the
                        element values. If not initialized the default value for the elements in a single-dimensional or multi-dimensional array will be 0 for numeric
                        types and <a href="#null">null</a> for reference types. As a jagged array stores other arrays, the default type is always null.</p>
                        <p>The following example demonstrates the declaration and initialization of an array.</p>
<pre><code>namespace Arrays
{
    class Program
    {
        static void Main(string[] args)
        {
            // Declare an array of type 'string' with the identifier stringArray
            // stringArray will be null
            string[] stringArray;

            // Declare an array of type 'int' with the identifier arr1
            // arr1 will be null
            int[] arr1;

            // Create a new array arr1 with 5 elements
            // Each element will have the default value 0
            arr1 = new int[5];

            // Create a new array arr1 of length 6
            // Each element will have the default value 0
            // The previous array with 5 elements and their
            // values are deleted from memory
            arr1 = new int[6];

            // Declare and create an array of length 7.
            // Each element will have the default value of 0
            int[] arr2 = new int[7];

            // Declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 3 and 4 respectively
            int[] arr3 = new int[2] { 3, 4 };

            // Another syntax to declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 8 and 9 respectively
            int[] arr4 = new[] { 8, 9 };

            // Yet another syntax to declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 10 and 11 respectively
            int[] arr5 = { 10, 11 };

            // var can be used in place of int[] in the syntax of
            // arr2, arr3 and arr4 but not arr5

            // Declare and create an array of length 7.
            // Each element will have the default value of 0
            var arr6 = new int[7];

            // Declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 3 and 4 respectively
            var arr7 = new int[2] { 3, 4 };

            // Another syntax to declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 8 and 9 respectively
            var arr8 = new[] { 8, 9 };

            // Syntax error, 'var' can't be used with an array initializer
            //var arr9 = { 11, 12 };

            // Declare, create and initialize an array of type 'string'
            // called with a length of 3
            string[] arr10 = new string[3] { "red", "green", "blue" };

            // Several ways to declare an empty array. The array will not be null
            // but will not be able to store any elements. An empty array has
            // few uses and most can now be replaced by newer data structure types
            int[] emptyArray1 = { };
            int[] emptyArray2 = new int[] { };
            int[] emptyArray3 = new int[0];
            int[] emptyArray4 = Array.Empty&lt;int&gt;();

            // Declare a multi-dimensional array with 2 dimensions
            int[,] arr11;

            // Create a 2-dimensional array of length 4 in the first
            // and length 2 in the second. You can think of this as having
            // 4 rows and 2 columns
            arr11 = new int[4, 2];

            // Create and initialize a 2-dimensional array
            arr11 = new int[4, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };

            // Create and initialize a 2-dimensional array
            // Here the lengths are inferred from
            // from the block inside the braces
            arr11 = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };

            // Declare, create and initialize a 2-dimensional string array
            string[,] arr12 = new string[3, 2] { { "red", "cyan" }, { "green", "magenta" }, { "blue", "yellow" } };

            // Declare, create and initialize a 3 dimensional 'int' array
            // This will create an array with dimensions [2, 2, 3]
            int[,,] arr13 = new int[,,] { { { 1, 2, 3 }, { 4, 5, 6 } }, { { 7, 8, 9 }, { 10, 11, 12 } } };

            // Declares and creates a jagged array. The first array
            // is a single-dimensional array with 3 elements
            // each of which is a 2-dimensional array
            int[][,] arr14 = new int[3][,];

            // Each single-dimensional element of arr13 must also
            // be created before it can be used
            arr14[0] = new int[1, 2];
            arr14[1] = new int[2, 3];
            arr14[2] = new int[4, 5];

            // An array within a jagged array can also be initialized
            arr14[1] = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } };

            // Yet another syntax for initializing a jagged array
            int[][] arr16 =
            {
                new int[] { 1, 2, 3, 4 },
                new int[] { 5, 6, 7 },
                new int[] { 8, 9 }
            };
        }
    }
}
</code></pre>
                    <!-- !SECTION Declaring, creating and initializing arrays -->
                    <!-- SECTION Accessing arrays -->
                    <h3 id="Accessing_arrays">Accessing arrays</h3>
                    <p>Arrays are normally zero index based so the elements in a dimension of length n will be accessed by index values of 0 through n-1. Whilst it is
                        possible to create an array that is not zero based its use is rare.</p>
                    <p>The following example demonstrates how to access an array.</p>
<pre><code>namespace ArrayAccess
{
    class Program
    {
        static void Main(string[] args)
        {
            // Each element in array is accessed using an 'int' type
            // index which is zero based. For an array of length 3
            // the index values for the elements are 0, 1 and 2.
            // To obtain and element specify the index within
            // square brackets
            string[] colors = { "red", "green", "blue" };
            Console.WriteLine($"{colors[0]}, {colors[1]}, {colors[2]}");

            // To assign a value to an element use the assignment operator '='
            colors[0] = "cyan";
            colors[1] = "magenta";
            colors[2] = "yellow";

            // The total number of elements of an array can be found by using
            // the Length property 'array.Length'.
            Console.WriteLine($"The array 'colors' has {colors.Length} elements");

            // Attempting to access an array with an index value less than 0
            // or more than the length - 1 will result in an
            // IndexOutOfRange exception and the program will stop
            // Uncomment the following line will demonstrate this error
            // Console.WriteLine(colors[3]);

            // As the array indexes
            // are 0 based the elements can be accessed using a 'for' loop
            for (int i = 0; i &lt; colors.Length; i++)
            {
                Console.Write($"{colors[i]} ");
            }
            Console.WriteLine();

            // Additionally, the elements can be accessed using a 'foreach' loop
            foreach (var color in colors)
            {
                Console.Write($"{color} ");
            }
            Console.WriteLine();

            // Accessing the elements within a multi-dimensional array
            // is similar to a single-dimensional array using one
            // 'int' type index for each dimension
            int[,] numbers = new int[3, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 } };
            Console.WriteLine($"{numbers[0, 0]} {numbers[0, 1]} {numbers[1, 0]} " +
                                $"{numbers[1, 1]} {numbers[2, 0]} {numbers[2, 1]}");

            // Assigning values to elements in a multi-dimensional
            // is also similar to a single-dimensional array using one
            // 'int' type index for each dimension
            numbers[0, 0] = 6;
            numbers[0, 1] = 5;
            numbers[1, 0] = 4;
            numbers[1, 1] = 3;
            numbers[2, 0] = 2;
            numbers[2, 1] = 1;

            // Looping through a multi-dimensional array can be
            // done using nested for loops, one for each dimension
            // To obtain the length for a given dimension the
            // GetLength() is used 'array.GetLength(dimensionIndex)'
            for (int i = 0; i &lt; numbers.GetLength(0); i++)
            {
                for (int j = 0; j &lt; numbers.GetLength(1); j++)
                {
                    Console.Write($"{numbers[i, j]} ");
                }
            }
            Console.WriteLine();

            // The foreach loop can also be used for multi-dimensional arrays
            // however nested for loops allow you traverse an array in any
            // order you require
            foreach (var number in numbers)
            {
                Console.Write($"{number} ");
            }
            Console.WriteLine();

            // The number of dimensions of an array
            // can be found using the Rank property 'array.Rank'.
            Console.WriteLine($"numbers has {numbers.Rank} dimensions");
            var total = 1;
            for (int i = 0; i &lt; numbers.Rank; i++)
            {
                Console.WriteLine($"numbers[{i}] has {numbers.GetLength(i)} elements");
                total *= numbers.GetLength(i);
            }
            Console.WriteLine($"Numbers has a total {total} of elements which is the same as Numbers.Length: {numbers.Length}");

            // Accessing a jagged array is similar to a multi-dimensional
            // This prints 7 to the console which is the third element [2]
            // of the second array [1] of jaggedArray
            int[][] jaggedArray =
            {
                new int[] {1, 2, 3, 4},
                new int[] {5, 6, 7},
                new int[] {8, 9}
            };
            Console.WriteLine($"{jaggedArray[1][2]}");

            // Assigning values is also similar to multi-dimensional arrays
            // This assigns 42 to the third element [2] of the second array [1]
            // then prints it to the console
            jaggedArray[1][2] = 42;
            Console.WriteLine($"{jaggedArray[1][2]}");

            // This demonstrates looping though a jagged array with for loops
            for (int i = 0; i &lt; jaggedArray.Length; i++)
            {
                Console.Write($"The values in jaggedArray[{i}] are: ");
                for (int j = 0; j &lt; jaggedArray[i].Length; j++)
                {
                    Console.Write($" {jaggedArray[i][j]}");
                }
                Console.WriteLine();
            }

            // Looping through a jagged array with a foreach loop is a bit more
            // complicated as an outer loop is required to get the arrays and an
            // inner loop to get the actual values
            foreach (var arr in jaggedArray)
            {
                foreach (var i in arr)
                {
                    Console.Write($"{i} ");
                }
            }
            Console.WriteLine();
            // This demonstrates the types that are stored in a jagged array
            // The first line prints Int32[] where the square brackets indicate
            // that it is an array of type 'int' whereas the second prints
            // Int32 without square brackets indicating the actual type stored in
            // each array is an 'int'
            Console.WriteLine(jaggedArray[0].GetType().Name);
            Console.WriteLine(jaggedArray[0][0].GetType().Name);
        }
    }
}

// The example prints the following to the console
// red, green, blue
// The array 'colors' has 3 elements
// cyan magenta yellow
// cyan magenta yellow
// 1 2 3 4 5 6
// 6 5 4 3 2 1
// 6 5 4 3 2 1
// numbers has 2 dimensions
// numbers[0] has 3 elements
// numbers[1] has 2 elements
// Numbers has a total 6 of elements which is the same as Numbers.Length: 6
// 7
// 42
// The values in jaggedArray[0] are: 1 2 3 4
// The values in jaggedArray[1] are: 5 6 42
// The values in jaggedArray[2] are: 8 9
// 1 2 3 4 5 6 42 8 9
// Int32[]
// Int32
</code></pre>
                    <!-- !SECTION Accessing arrays -->
                    <!-- SECTION Collections -->
                    <h3 id="Collections">Collections</h3>
                    <p>.NET provides a number of data structures grouped under the category of collections. They provide common functionality such as to add, remove and
                        modify either individual elements or a range of elements.</p>
                    <p>There are two main types of collections, generic and non-generic. Generic collections take in a type parameter making them type safe at compile time
                        which allows IntelliSense to indicate <a href="#Syntax_errors">syntax errors.</a> Non-generic collections store items as type <i>object</i> which
                        requires casting when accessing the data within them. Because of this, non-generic collections are less commonly used today and are mostly found
                        in legacy code.</p>
                    <p>Following is a list of some common collection types but only examples of <i>List&lt;T&gt;</i> and <i>Dictionary&lt;TKey, TValue&gt;</i>
                        will be discussed in this article.</p>
                    <ul>
                        <li><i>List&lt;T&gt;</i> - A collection of items stored by index</li>
                        <li><i>Dictionary&lt;TKey, TValue&gt;</i> - Used to store items as key/value pairs</li>
                        <li><i>Queue&lt;T&gt;</i> - Items are accessed first in first out (FIFO)</li>
                        <li><i>Stack&lt;T&gt;</i> - Items are accessed last in first out (LIFO)</li>
                        <li><i>LinkedList&lt;T&gt;</i> - Items are accessed sequentially</li>
                        <li><i>ObservableCollection&lt;T&gt;</i> - Provides notification through events when items are added or removed</li>
                        <li><i>SortedList&lt;TKey, TValue&gt;</i> - A sorted collection</li>
                        <li><i>HashSet&lt;T&gt;</i> - A set for mathematical functions</li>
                        <li><i>SortedSet&lt;T&gt;</i> - A sorted set for mathematical functions</li>
                    </ul>
                    <!-- !SECTION Collections -->
                    <!-- SECTION List<T> -->
                    <h4 id="List_T">List&lt;T&gt;</h4>
                    <p>A <i>List&lt;T&gt;</i> is a strongly typed generic collection of objects accessed by an int type <i>index</i>. Unlike an array, a list does
                        not have a fixed size and as such does not have to be declared. It provides a number of useful methods for manipulating its data such as add,
                        remove, sort, find and clear.</p>
                    <p><em>Note:</em> <i>The Find method uses a <a href="#Lambda_expressions">lambda expression</a></i></p>
                    <p>The following example demonstrates List declaration and use </p>
<pre><code>using System.Collections.Generic;

namespace Lists
{
    class Program
    {
        static void Main(string[] args)
        {
            // Create a list of integers
            List&lt;int&gt; integers = new();

            // Add items to the list
            integers.Add(1);
            integers.Add(2);
            integers.Add(3);

            // A range of items can be added by passing in an enumerable type
            integers.AddRange(new int[] { 4, 5, 6 });

            // Use a foreach loop to print the items to the console
            foreach (int item in integers) { Console.Write($"{item} "); }

            // A list can be initialized when declared
            List&lt;string&gt; animals = new() { "dog", "cat", "lizard", "ball", "emu", "emu", "boat", "salmon"};

            // The 'Find' method returns the first item that
            // matches the conditions specified by the
            // predicate in the anonymous expression.
            // (See Anonymous function expressions)
            // If not the default value for type T is returned.
            // 'Remove' removes the specified item
            // This searches for 'boat' and if found removes it
            // from the list
            string? notAnAnimal = animals.Find(item =&gt; item == "boat");
            if (notAnAnimal != null)
                animals.Remove(notAnAnimal);
            Console.WriteLine($"\n\nFind 'boat' then remove it");
            foreach (string item in animals) { Console.Write(item + " "); }

            // Create a variable to store the index value
            int index = 0;

            // 'Contains' returns true is the list contains the item
            // 'IndexOf' returns the index of an item if found
            // or -1 if not. This first confirms the list has 'lizard'
            // then changes 'lizard' to 'duck'
            if (animals.Contains("lizard"))
            {
                index = animals.IndexOf("lizard");
                animals[index] = "duck";
            }
            Console.WriteLine($"\n\nIf list has 'lizard' replace it with 'duck'");
            foreach (string item in animals) { Console.Write(item + " "); }

            // 'Insert' inserts an item at a specific index
            // This inserts 'shark' at the current index of 'duck'
            // as found from the previous example. All items after
            // and including 'duck' are moved after 'shark'
            animals.Insert(index, "shark");
            Console.WriteLine($"\n\nInsert 'shark' before 'duck'");
            foreach (string item in animals) { Console.Write(item + " "); }

            // 'RemoveAt' removes an at a specified index
            // The following removes 'ball'
            index = animals.IndexOf("ball");
            if (index != 0)
                animals.RemoveAt(index);
            Console.WriteLine($"\n\nRemove 'ball'");
            foreach (string item in animals) { Console.Write(item + " "); }

            // 'Remove' removes the first occurrence of a specific item
            // It returns false if the removal was unsuccessful or the
            // item wasn't found. The following removes the first 'emu'
            // then prints the updated list to the console
            var removed = animals.Remove("emu") ? "'emu' was removed" : "'emu' was NOT removed";
            Console.WriteLine($"\n\n{removed}");
            foreach (string item in animals) { Console.Write(item + " "); }

            // 'Sort' sorts the list based on the comparer argument
            // passed in. If none is supplied then the default
            // comparer is used. The following alphabetically sorts the list
            animals.Sort();
            Console.WriteLine($"\n\nSort the list");
            foreach (string item in animals) { Console.Write(item + " "); }

            // 'Reverse' reverses the order of the list
            animals.Reverse();
            Console.WriteLine($"\n\nThe list has been reversed");
            foreach (string item in animals) { Console.Write(item + " "); }

            // 'Clear' removes all items from the list
            // The 'Count' property is the number of items the list.
            animals.Clear();
            Console.WriteLine($"\n\nClear the list");
            Console.WriteLine($"There are {animals.Count} items in the list");
            Console.WriteLine();
        }
    }
}

// The example writes the following to the console
// 1 2 3 4 5 6

// Find 'boat' then remove it
// dog cat lizard ball emu emu salmon

// If list has 'lizard' replace it with 'duck'
// dog cat duck ball emu emu salmon

// Insert 'shark' before 'duck'
// dog cat shark duck ball emu emu salmon

// Remove 'ball'
// dog cat shark duck emu emu salmon

// 'emu' was removed
// dog cat shark duck emu salmon

// Sort the list
// cat dog duck emu salmon shark

// The list has been reversed
// shark salmon emu duck dog cat

// Clear the list
// There are 0 items in the list
</code></pre>
                    <!-- !SECTION List<T> -->
                    <!-- SECTION Dictionary<TKey, TValue> -->
                    <h4 id="Dictionary_TKey_TValue">Dictionary&lt;TKey, TValue&gt;</h4>
                    <p>A <i>Dictionary&lt;TKey, TValue&gt;</i> is a strongly typed generic collection of <i>KeyValuePair&lt;TKey, TValue&gt;</i> accessed by a <i>key</i>
                        index.  Like a List, a Dictionary does not have a fixed size and as such does not have to be declared. Methods include add, remove, contains,
                        clear.</p>
                    <p>The following example demonstrates Dictionary declaration and use</p>
<pre><code>using System.Collections.Generic;

namespace Dictionaries
{
    class Program
    {
        static void Main(string[] args)
        {
            string nl = Environment.NewLine;

            // Create a list of strings
            Dictionary&lt;string, int&gt; fruit = new();

            // Add some items
            fruit.Add("Oranges", 6);
            fruit.Add("Pears", 4);
            fruit.Add("Apples", 8);
            fruit.Add("Bananas", 7);
            fruit.Add("Lemons", 3);
            fruit.Add("Peaches", 6);
            fruit.Add("Plums", 6);

            // 'Count' returns the number of items in a Dictionary
            Console.WriteLine($"There are {fruit.Count} fruit items");

            // To use a Dictionary in a foreach loop use
            // KeyValuePair&lt;TKey, TValue&gt;. The types must be the same
            // as that used in the declaration of the dictionary
            foreach (KeyValuePair&lt;string, int&gt; item in fruit)
                Console.Write($"{item.Key}: {item.Value}{nl}");

            // Syntax error, each item must have a unique 'key'
            //fruit.Add("Plums", 3);

            // 'TryAdd', unlike 'Add', won't result in an
            // exception but will return false if the
            // item could not be added.
            var added = fruit.TryAdd("Plums", 3) ?
                "'Another Plums entry' was added" :
                "'Another Plums entry' could NOT be added";
            Console.WriteLine($"{added}");

            // 'Keys' returns a 'KeyCollection' of all the keys
            // in the Dictionary and will have the same type that
            // was used when declaring it
            var keys = fruit.Keys;
            foreach (var key in keys)
                Console.Write($"{key} ");

            // 'Values' returns a 'ValueCollection' of all the values
            // in the Dictionary and will have the same type that
            // was used when declaring it
            var values = fruit.Values;

            int total = 0;
            foreach (var value in values)
                total += value;
            Console.WriteLine($"{nl}There is a total of {total} fruit");

            // Individual items can be accessed using the 'Key' index
            Console.WriteLine($"There are {fruit["Pears"]} 'Pears'");
            fruit["Pears"] = 3;
            Console.WriteLine($"There are now {fruit["Pears"]} 'Pears'");

            // Syntax error, the 'Key' index must exist to access an item.
            // var mangoes = fruit["Mangoes"];

            // 'TryAdd', unlike accessing a Dictionary with the 'Key' index,
            // won't result in an exception but will return false if the
            // Key does not exist. If found result will be the value for
            // the item. If not found result will be the type's default value
            if (fruit.TryGetValue("Mangoes", out var result))
            {
                Console.WriteLine($"There are {result} 'Mangoes'");
            }
            else
            {
                Console.WriteLine($"There is no 'Mangoes' item in 'fruit'");
            }

            // 'ContainsKey' returns true if the Dictionary contains
            // the specified 'Key'
            if (fruit.ContainsKey("Bananas"))
            {
                Console.WriteLine($"There are {fruit["Bananas"]} 'Bananas'");
            }
            else
            {
                Console.WriteLine($"There are no 'Bananas' item in fruit");
            }

            // 'ContainsValue' returns true if the Dictionary contains
            // the specified 'Value'
            if (fruit.ContainsValue(6))
            {
                Console.WriteLine($"There is at least 1 item with the value '6'");
            }
            else
            {
                Console.WriteLine($"There are no items with the value '6'");
            }

            // 'Remove' removes the specified 'Key' from the Dictionary
            fruit.Remove("Oranges");
            if (fruit.ContainsKey("Oranges"))
            {
                Console.WriteLine($"There are {fruit["Oranges"]} 'Oranges'");
            }
            else
            {
                Console.WriteLine($"There is no longer an 'Oranges' item in fruit");
            }

            // 'Clear' removes all KeyValuePair&lt;TKey, TValue&gt; items from
            // the Dictionary
            fruit.Clear();
            Console.WriteLine($"There are {fruit.Count} fruit items");
        }
    }
}

// The example writes the following to the console
// There are 7 fruit items
// Oranges: 6
// Pears: 4
// Apples: 8
// Bananas: 7
// Lemons: 3
// Peaches: 6
// Plums: 6
// 'Another Plums entry' could NOT be added
// Oranges Pears Apples Bananas Lemons Peaches Plums
// There is a total of 40 fruit
// There are 4 'Pears'
// There are now 3 'Pears'
// There is no 'Mangoes' item in 'fruit'
// There are 7 'Bananas'
// There is at least 1 item with the value '6'
// There is no longer an 'Oranges' item in fruit
// There are 0 fruit items
</code></pre>
                    <!-- !SECTION Dictionary<TKey, TValue> -->
                </article>
            </section>
            <!-- !SECTION Arrays and Data Structures -->
            <!-- SECTION Enumerators and Tuples -->
            <section class="main-section" id="Enumerators_and_Tuples">
                <header><h2>Enumerators and Tuples</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION Enumerators -->
                    <h3 id="Enumerators">Enumerators</h3>
                    <p>The <code>enum</code> keyword is used to declare an enumerator which provides a list of named constants. The code editor allows you to use these
                        names to assign the underlying constant values to variables. You can declare the type and value of each constant or allow the editor to declare
                        them for you. The default type for the value is an integer and the list is zero based. A value in an enum is accessed through the enum's
                        identifier, followed by a period, followed by the identifier of one of the constants. An enum is a value type.</p>
                    <p>The following example demonstrates enumerator declaration and use.</p>
<pre><code>namespace Enumerators
{
    class Program
    {
        // The default underlying type is an 'int'
        enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat }

        // This declares that the underlying month type is declared as 'long'
        enum Month : long { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }

        static void Main(string[] args)
        {
            var day = Day.Tue;
            var dayType = day.GetType();
            var underlyingDayType = Enum.GetUnderlyingType(dayType);
            Console.WriteLine($"Day is {day}, value is {(int)day}," +
                $" Type is {dayType.Name}, underlying type is {underlyingDayType}");
            var month = Month.Nov;
            var monthType = month.GetType();
            var underlyingMonthType = Enum.GetUnderlyingType(monthType);
            Console.WriteLine($"Month is {month}, value is {(long)month}," +
                $" Type is {monthType.Name}, underlying type is {underlyingMonthType}");
        }
    }
}

// The example prints the following to the console
// Day is Tue, value is 2, Type is Day, underlying type is System.Int32
// Month is Nov, value is 10, Type is Month, underlying type is System.Int64
</code></pre>
                    <!-- !SECTION Enumerators -->
                    <!-- SECTION Tuple -->
                    <h3 id="Tuple">Tuple</h3>
                    <p>A <code>ValueTuple</code> type, commonly called a <i>tuple</i>, is a mutable value type that provides a concise syntax for creating a structure
                        that groups multiple different types together. It does this by creating a <a href="#Access_modifiers">public</a> <a href="#Fields">field</a>
                        element for each type.</p>
                    <p>The tuple syntax is in the form of a set of round brackets containing a comma separated list of at least two <i>elements</i>, with optional
                        identifiers. The compiler provides each element with a default identifier in the form <code>Itemn</code> where n is the position of the element in
                        the list. Optional identifiers are in addition to default identifiers such that an element of a tuple called <code>t</code> can be accessed in the
                        form of either <code>t.Itemn</code> or <span class="nowrap"><code>t.OptionalName</code>.</span> An element can't be optionally named  with a
                        default identifier that is normally used for another element, i.e., naming the first element <code>Item2</code> results in a
                        <a href="#Syntax_errors">syntax error.</a> Additionally, tuples contain a number of <a href="#Members">members</a> and the use of their
                        identifiers will also result in an error. By convention, as the elements are public, they are normally named using <i>PascalCase</i>. Elements can
                        also be assigned values when being declared. A common use for a tuple is the return type for a
                        <a href="#Methods">method</a> where only a single type is allowed, as multiple types can be returned wrapped in the one
                        <code>ValueTuple</code> type.</p>
                    <p><em>Note:</em><i> If an optional identifier is provided IntelliSense won't provide an option for the default identifier but it can still be entered
                        manually.</i></p>
                    <p>There are a number of different ways to declare and assign values to a tuple as demonstrated in the following example.</p>
<pre><code>namespace TupleDeclaration
{
    class Program
    {
        static void Main(string[] args)
        {
            // Explicitly declare a tuple with
            // 2 elements of type string and int.
            (string, int) t1;

            // Assign values to t1.
            t1 = ("Some text", 1);
            Console.WriteLine($"Item1: {t1.Item1}, Item2: {t1.Item2}");

            // Implicitly declare a tuple with 2 elements of
            // type string and int and assign values to it.
            var t2 = ("My dog has fleas", true);
            Console.WriteLine($"{t2.Item1}: {t2.Item2}");

            // Explicitly declare a tuple with named elements and assign values to them
            (string Name, int Age) person1 = ("Andrew", 21);
            Console.WriteLine($"Person name: {person1.Name}, Age: {person1.Age}");

            // The default element name can also be used
            Console.WriteLine($"Person name: {person1.Item1}, Age: {person1.Item2}");

            // Both names and values can be implicitly assigned in the definition
            var vehicle = (Color: "Red", Wheels: 3);
            Console.WriteLine($"Vehicle color: {vehicle.Color}, Wheels: {vehicle.Wheels}");

            var windows = 6;
            var doors = 2;

            // The types, values and names can be inferred from existing variables.
            var house = (windows, doors);
            Console.WriteLine($"My house has {house.windows} windows and {house.doors} doors");

            // A tuple can be assigned types and values from another provided that
            // both tuples have the same number of elements and for each element
            // the types are implicitly convertible. The names are not assigned.
            (string A, double B) person2 = person1;
            Console.WriteLine($"Person name: {person2.A}, Age: {person2.B}");
        }
    }
}

// The example writes the following to the console.
// Item1: Some text, Item2: 1
// My dog has fleas: True
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Vehicle color: Red, Wheels: 3
// My house has 6 windows and 2 doors
// Person name: Andrew, Age: 21
</code></pre>

                    <p>Deconstruction allows the elements of a tuple to be separated into separate variables through use of the
                        <span class="nowrap"><a href="#Assignmet_operator">assignment operator</a> <code>=</code>.</span></p>

<pre><code>namespace TupleDeconstruction
{
    class Program
    {
        static void Main(string[] args)
        {
            var person = ("Andrew", 21);

            // Deconstruction makes available for use
            // the individual elements of a tuple

            // The vales of each element can be individually extracted.
            // Note that the original element names are not available
            var name1 = person.Item1;
            var age1 = person.Item2;
            Console.WriteLine($"Person name: {name1}, Age: {age1}");

            // The types of each variable can be explicitly declared.
            (string name2, int age2) = person;
            Console.WriteLine($"Person name: {name2}, Age: {age2}");

            // The types can be implicitly inferred using var.
            var (name3, age3) = person;
            Console.WriteLine($"Person name: {name3}, Age: {age3}");

            // Individual elements can be implicitly inferred using var.
            (string name4, var age4) = person;
            Console.WriteLine($"Person name: {name4}, Age: {age4}");

            var name5 = string.Empty;
            var age5 = 0;

            // Existing variables of the correct type can be used.
            (name5, age5) = person;
            Console.WriteLine($"Person name: {name5}, Age: {age5}");

            // Discards can be used for elements that are not required
            var (name6, _) = person;
            Console.WriteLine($"Person name: {name6}");
        }
    }
}

// The example writes the following to the console
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Person name: Andrew
</code></pre>
                    <p><a href="#Equality_operators">Equality operators</a> can be used to compare two tuples provided that both tuples have the same number of elements
                        and the type of each element in each corresponding position is the same.</p>
<pre><code>namespace TupleEquality
{
    class Program
    {
        static void Main(string[] args)
        {
            (string Name, int Age) person1 = ("Andrew", 21);

            (string Name, int Age) person2 = ("Andrew", 21);
            Console.WriteLine($"person1 == person2: {person1 == person2}");
            Console.WriteLine($"person1 != person2: {person1 != person2}");

            (string Name, int Age) person3 = ("John", 33);
            Console.WriteLine($"person1 == person 3: {person1 == person3}");
            Console.WriteLine($"person1 != person 3: {person1 != person3}");

            (int id, string Name, int Age) person4 = (1, "Andrew", 21);
            // Syntax error, the number of elements is different
            //Console.WriteLine($"person1 == person4: {person1 == person4}");
            //Console.WriteLine($"person1 == person4: {person1 != person4}");

            (string Name, string Age) person5 = ("Andrew", "21");
            // Syntax error, person1.Item2 is an int and person5.Item is a string
            //Console.WriteLine($"person1 == person5: {person1 == person5}");
            //Console.WriteLine($"person1 == person5: {person1 != person5}");
        }
    }
}

// The example writes the following to the console
// person1 == person2: True
// person1 != person2: False
// person1 == person 3: False
// person1 != person 3: True
</code></pre>

                    <!-- !SECTION Tuple -->
                </article>
            </section>
            <!-- !SECTION Enumerators and Tuples -->
            <!-- SECTION Classes and Other User Defined Types -->
            <section class="main-section" id="Classes_and_Other_User_Defined_Types">
                <header><h2>Classes and Other User Defined Types</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION User defined types -->
                    <h3 id="User_defined_types">User defined types</h3>
                    <p>C# is an <a href="#Object-oriented_Programming">Object-oriented programming language (OOP)</a> and objects can be created using types. A type is a
                        kind of template and when a program runs, objects, also called instances, can be created based on a type. This allows multiple instances to be
                        created each with their own state. Within a C# project, types can be combined with other resources such as media and text files, which are then
                        compiled to create an <a href="#Dependencies_and_Namespaces"><i>assembly</i></a> in the form of either an executable(.exe) or library(.dll) file.
                    </p>
                    <p>The types that can be used to define an object with a state include</p>
                    <ul>
                        <li><a href="#class">classes</a> are reference types used to define complex objects and usually account for the majority of types in an
                            assembly</li>
                        <li><a href="#struct">struct (structures)</a> are value types used to define simple data focused objects with little behavior
                        </li>
                        <li><a href="#record">records</a> are reference types that can behave like a value type and are used mostly with immutable data</li>
                        <li><a href="#delegate">delegates</a> are a type used to represent a reference to a method that can be passed as an argument to another method
                        </li>
                        <li><a href="#interface">interfaces</a> can't be instantiated but instead are used to define behaviors that can be implemented by other types
                        </li>
                    </ul>
                    <p>A type can contain <a href="#Members">members</a> which include <a href="#Methods">methods</a>, <a href="#Constructors">constructors</a>,
                        <a href="#Fields">fields</a>, <a href="#Constant_fields">constant fields</a>, <a href="#Properties">properties</a>,
                        <a href="#Indexers">indexers</a>, <a href="#Events">events</a>, <a href="#Finalizers">finalizers</a> and other
                        nested types. Combined these are used to define an object through encapsulation and storage of its data and by providing the object's behavior. A
                        type can contain multiple members with the same identifier, known as <a href="#Parameters,_signatures_and_overloading">overloading</a>, provided
                        that each has a unique <a href="#Parameters,_signatures_and_overloading">signature.</a> Accessibility to a type from code outside of the assembly,
                        and to members both from outside the assembly and from other types within the assembly, is controlled through the use of
                        <a href="#Access_Modifiers">access modifier</a> keywords.</p>
                    <p></p>
                    <p>Classes, structs and records can be instantiated with use of the <code>new</code> keyword. That is multiple instances of these types can be
                        created, each with its own state. A class can also be made <a href="#static">static</a> in which case it cannot be instantiated using the
                        <code>new</code> keyword but instead a single instance of the class is automatically created at runtime and is shared throughout the assembly. A
                        child class, record or interface can <a href="#Inheriting_types">inherit</a> from a parent class, record or interface respectively. In
                        C# a parent type is called a base type and a child a derived type. Classes and records can be marked as <a href="#abstract">abstract</a> requiring
                        a derived class for instantiation or <a href="#sealed">sealed</a> to prevent inheritance. Use of the static, abstract and sealed keywords is
                        mutually exclusive. As well as inheritance a class, struct or record can implement an interface.</p>
                    <!-- !SECTION User defined types -->
<!-- TODO finish the following -->
<!-- TODO add brief about overriding and virtual -->
<!-- TODO add brief about polymorphism -->
                    <!-- SECTION class -->
                    <h3 id="class">class</h3>
                    <p>A class is a used to define a type that can be instantiated into an <a href="#Object-oriented_Programming">object.</a> It does this by acting as a
                        container to encapsulate <a href="#Members">members</a> that define its state and behavior. It is a <a href="#Reference_type">reference type</a>
                        which when declared at run-time contains <a href="#null">null</a> until an instance is created using the <code>new</code> keyword. At this time
                        its members can be called to define its initial state. <a href="#Modifiers">Modifier keywords</a> can be applied to a class and its members to
                        alter its behavior and accessibility.</p>
                    <p>A class within a namespace is declared by specifying an optional <a href="#Access_Modifiers">access modifier</a> keyword, followed by the
                        <code>class</code> keyword, followed by an identifier that is unique within the same <a href="#Dependencies_and_Namespaces">namespace</a>,
                        followed by a code block defined by a pair of braces. If the access modifier keyword is omitted the default access is internal. Whilst multiple
                        classes can be added to a single file, unless a class is nested, the convention is that each should occupy its own file.</p>
                    <p>To add a class file in Visual Studio</p>
                    <ol>
                        <li>In the <b>Solution Explorer</b> right click the project or a folder within it that you wish to add the class to.</li>
                        <li>In the context menu hover the mouse over <b>Add</b> then in the new context menu that opens, click <b>Class</b> and the <b>Add New Item</b>
                            dialog will open.</li>
                        <li><b>Class</b> should be selected at the top of the list but if it isn't, type <i>class</i> in the search bar in the top right of the dialog and
                            then select <i>class</i> in the list.</li>
                        <li>At the bottom of the dialog in the name text box type the name of the class then click <b>Add</b> and the new class file will be added to the
                            project and then opened in the code editor.</li>
                    </ol>
                    <p></p>
                    <p><em>Note:</em><i> The Class template provided by Visual Studio in the Add New Item dialog creates a file with a class without an access modifier.
                        The file will also include using directives for various namespaces dependent on the project's type. Adding a class to a folder will result in a
                        <a href="#Dependencies_and_Namespaces">namespace</a> of the form
                        <span class="nowrap"><code>namespace ProjectName.FolderName</code>.</span></i></p>
                    <p>The following example demonstrates ways in which a class can be declared. </p>
<pre><code>namespace ClassDeclaration
{
    // The syntax for declaring a class is first
    // an optional access modifier followed by
    // the keyword class then a unique identifier
    // followed by a pair of braces within
    // which are the classes members

    // Public class declaration. This class can be
    // accessed both by the assembly that
    // contains it and any assembly that references it
    public class PublicClass
    {

    }

    // internal class declaration.  This class can
    // only be accessed both by the assembly that
    // contains it
    internal class InternalClass
    {

    }

    // Without the optional access modifier this
    // class is internal by default
    class DefaultClass
    {
        // Without an access modifier this
        // class is private by default
        class NestedClass
        {

        }
    }
}
</code></pre>
                    <p>The following example defines a <code>Square</code> class with <a href="#Constructors">constructors</a>, <a href="#Methods">methods</a>,
                        <a href="#Fields">fields</a>,
                        <a href="#Properties">properties</a> and <a href="#Events">events.</a> There are two constructors, the first has a
                        <a href="#Parameters_signatures_and_overloading">signature</a> with one parameter and the second with three in which the third parameter is
                        optional. The <code>Program</code> class creates three instances of the <code>Square</code> class. The first uses the first constructor, the
                        second the second constructor without passing an argument to the third parameter. The third also uses the second constructor but does pass an
                        argument. It also adds the <code>Square_AreaChanged</code> event handler to handle the <code>AreaChanged</code> event of both the
                        <code>square2</code> and <code>square3</code> instances. When the program is run, after writing the initial area values to the console it then
                        changes the <code>Width</code> property directly on the <code>square2</code> instance and <code>Height</code> on <code>square3</code> through the
                        <code>SetHeight</code> method. This triggers the <code>AreaChanged</code> event in each which then calls the <code>Square_AreaChanged</code> event
                        handler which in turn writes the updated values to the console.</p>
<pre><code>namespace ClassExample
{
    class Square
    {
        // Declare 2 fields a constant to initialize the width and a
        // variable to use as a backing field for the Width property
        const int DEFAULT_VALUE = 1;
        private int _Width;

        // A constructor that sets the Height
        // and Width to the default value internally
        // The name and height must be set
        public Square(string name)
        {
            Name = name;
            Height = DEFAULT_VALUE;
            Width = DEFAULT_VALUE;
        }

        // A constructor that allows the Width to optionally be set
        // if a value is not provided it is set to the default value
        // The name and height must be set
        public Square(string name, int height, int width = DEFAULT_VALUE)
        {
            Name = name;
            Height = height;
            Width = width;
        }

        // An event that fires when there are changes
        // This uses the Expression-bodied member syntax
        public event EventHandler AreaChanged = (sender, e) =&gt; { };

        // The name property has a private setter
        // It can only be set from within the class
        // This is an Auto Property as the compiler
        // automatically creates a hidden private
        // backing field
        public string Name { get; private set; }

        // The Height property can be set both from inside
        // and from outside the class but does not trigger
        // the AreaChanged event. This is also an
        // Auto Property
        public int Height { get; set; }

        // The Width property can be set both from inside
        // and from outside the class and triggers
        // the AreaChanged event by calling the
        // OnAreaChanged method
        public int Width
        {
            get =&gt; _Width;
            set
            {
                if (_Width == value)
                    return;
                _Width = value;
                OnAreaChanged();
            }
        }

        // The SetHeight method changes the height and
        // triggers the area changed event by calling the
        // OnAreaChanged method. This method's return
        // type is set to void which means that it does
        // not return a value. It accepts a parameter
        // of type int called height
        public void SetHeight(int height)
        {
            Height = height;
            OnAreaChanged();
        }

        // The GetArea method calculates the area from the
        // Height and Width values and returns the result
        // as an int
        public int GetArea()
        {
            return Height * Width;
        }

        // This is the expression-bodied member syntax for the GetArea method
        // and performs the same function. It is useful when only one line
        // of code is to be entered within the braces
        public int GetArea2() =&gt; Height * Width;

        // An overloaded GetArea2 method. When selecting this method
        // IntelliSense will show there are two versions of this
        // method to choose from
        public int GetArea2(int doesNothing) =&gt; Height * Width;

        // The OnAreaChanged method first checks if an event handler exists
        // and if so calls the event through the invoke command passing on
        // the arguments in this case this class instance by using the this
        // keyword and an empty EventArgs
        // This method also uses Expression-bodied member syntax
        private void OnAreaChanged() =&gt; AreaChanged?.Invoke(this, EventArgs.Empty);
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Three squares are created using the new keyword and alternative
            // constructors
            Square square1 = new("Square 1");
            Square square2 = new("Square 2", 5);
            Square square3 = new("Square 3", 5, 10);
            // The Square_AreaChanged event handler is added to both the
            // square2 and square3 AreaChanged events
            square2.AreaChanged += Square_AreaChanged;
            square3.AreaChanged += Square_AreaChanged;
            // The initial area values are written to the console
            Console.WriteLine($"{square1.Name} area is {square1.GetArea().ToString()}");
            Console.WriteLine($"{square2.Name} area is {square2.GetArea().ToString()}");
            Console.WriteLine($"{square3.Name} area is {square3.GetArea().ToString()}");
            // Changing the width triggers the square2 AreaChanged event
            square2.Width = 3;
            // Changing the height triggers the square3 AreaChanged event
            square3.SetHeight(10);

        }

        // This is the Square_AreaChanged event handler which has been added to both the
        // square1 and square2 AreaChanged events
        private static void Square_AreaChanged(object sender, EventArgs e)
        {
            var square = sender as Square;
            Console.WriteLine($"{square.Name} area changed and is now {square.GetArea().ToString()}");
        }
    }
}

// The example writes the following to the console
// Square 1 area is 1
// Square 2 area is 5
// Square 3 area is 50
// Square 2 area changed and is now 15
// Square 3 area changed and is now 100
</code></pre>
                    <!-- !SECTION class -->
                    <!-- SECTION Members -->
                    <h3 id="Members">Members</h3>
                    <p>The state of an object is held by the members it contains. These provide <a href="#Encapsulation">encapsulation</a> and storage of its data,
                        as well as the object's behavior.</p>
                    <p>Following is a list of all possible members</p>
                    <ul>
                        <li><a href="#Methods">methods</a> that provide the behavior of the object</li>
                        <li><a href="#Constructors">constructors</a> which initialize the state of an object</li>
                        <li><a href="#Fields">fields</a> that store data about the object and can be changed at runtime</li>
                        <li><a href="#Constant_fields">constant fields</a> that store data when declared, cannot be changed at runtime and are inherently
                            <a href="#static">static</a></li>
                        <li><a href="#Properties">properties</a> that provide controlled access to an object's data</li>
                        <li><a href="#Indexers">indexers</a> that allow an object to be indexed like an array</li>
                        <li><a href="#Events">events</a> that communicate changes in the object's state to other objects or to itself</li>
                        <li><a href="#Operators">operators</a> that when overloaded are considered a type member</li>
                        <li><a href="#Finalizers">finalizers</a> that perform clean up of an object when it is no longer in use </li>
                        <li>nested type which is the declaration of another type within the containing type</li>
                    </ul>
                    <p>Members are declared within the type that defines the object. All members within an object can access each other irrespective of the location at
                        which they are declared. Access to members external to the object is controlled through the use of
                        <a href="#Access_Modifiers">access modifier</a> keywords and the access level of the object that contains them. If omitted a member's
                        access level will be private by default. Members can also be marked with the <a href="#static">static</a>,
                        <a href="#abstract">abstract</a> or <a href="#sealed">sealed</a> keywords which are mutually exclusive. A calling object accesses the member of
                        another in the same <a href="#namespace">namespace</a> through the object's identifier if it is an instance, or the type's identifier if it is
                        static, followed by a period, followed by the member's identifier such as <code>object.Member</code> or <code>Type.Member</code> respectively. If
                        an object needs to access a static member of an object in another namespace then the fully qualified name is required in the form of
                        <span class="nowrap"><code>Namespace.Type.Member</code>.</span> This can be negated through the use of a
                        <a href="#using_and_importing_types">using</a> directive. Some members also require the passing in of arguments to parameters contained in round
                        brackets that follow the member identifier. Visual Studio's IntelliSense can assist you as it will display a suggestion box that lists the
                        namespaces, types and members to choose from as you enter them.</p>
                    <p>All members except fields, constant fields and events that have a single expression support implementation through the use of
                        <a href="#The_lambda_and_expression-body_definition_operator">expression-bodied members which makes for a much more concise code.</a>
                        Constructors, indexers and methods can be <a href="#Parameters,_signatures_and_overloading">overloaded.</a> That is a type can contain multiple
                        versions with the same identifier provided that they overload a member of the same type and each overload has a unique signature.</p>
                    <p>Properties, indexers, methods and events in a <a href="#Inheriting_types">base</a> type can be marked <a href="#abstract">abstract</a>
                        or <a href="#virtualo">virtual</a> though marking an event a virtual is not recommended as the C# compiler does not handle them correctly
                        producing unpredictable results. In a <a href="#Inheriting_types">derived</a> type a virtual base member can optionally be
                        <a href="#override">overridden</a> where as an abstract base member <em>must</em> be overridden by a member with the same signature that is marked
                        with the <code>override</code> keyword. A type that contains an abstract member must also be marked abstract. A member marked as
                        <code>override</code> can also be marked with the <code>sealed</code> keyword preventing it from being overridden in any further derived type.
                        Where members in both a base and derived type have the same identifier under certain conditions the derived member may hide the base member,
                        please see <a href="#Inheriting_types">Inheriting types.</a>
                    </p>
                    <!-- !SECTION Members -->
                    <!-- SECTION Methods -->
                    <h3 id="Methods">Methods</h3>
                    <p>Methods provide the behavior of an object and are the basis for all <a href="#Program_execution">program execution</a> in C#. This could be reading
                        a file, calculating a value, writing to the screen, etc. It does this by acting as a container for one or more
                        <a href="#Code_Syntax">statements.</a></p>
                    <p>A statement in a method can pass program execution on to another method known as <i>calling</i> or <i>invoking</i>, with the method that
                        contains the statement known as the <code>caller</code>. In normal circumstances, execution is returned to the caller through a return statement
                        or, if the invoked method returns <code>void</code>, the end of the method is reached. Invoking a method is in the form of
                        <code>instance.Method(parameters)</code> for an instance of a type and <code>TypeName.Method(parameters)</code> for a
                        <a href="#static">static</a> type. To call an instance method an object must first be instantiated from the type that contains it.</p>
                    <p>A method declaration consists of two parts, the <i>header</i> and the <i>body</i>. The header must have a return type, an identifier and a pair of
                        round brackets that can optionally enclose values, known as <a href="#Parameters,_signatures_and_overloading">parameters</a>, that can be
                        <i>passed in</i> to the method for use by the statements it contains. The identifier, parameters and, depending on the context, the return type
                        define the <a href="#Parameters,_signatures_and_overloading">signature</a> of the method which is used in determining the
                        <a href="#Parameters,_signatures_and_overloading">overloading</a> of a method and its use with a <a href="#delegate">delegate.</a> A class can
                        contain multiple <a href="#Parameters,_signatures_and_overloading">overloads</a> of a method. If no value is to be returned then the return type
                        must be declared as <code>void</code> otherwise the method must return a value of the type declared in the header. Optional attributes and
                        <a href="#Modifiers">modifiers</a> can be applied to a method and its parameters that can change accessibility and behavior. The body contains the
                        implementation of the method and can consist of either a code block or when marked with either the <a href="#abstract">abstract</a> or
                        <a href="#extern">extern</a> modifier, a semicolon indicating that the method implementation is to be declared in a
                        <a href="#Inheriting_types">derived</a> class or an external library respectively. Methods with a single expression can be implemented in the form
                        of an <a href="#The_lambda_and_expression-body_definition_operator">expression-bodied member.</a></p>
                    <p>The following shows examples of method declaration and use.</p>
<pre><code>namespace Methods
{
    public class MyClass
    {
        // A method that takes in an argument
        // through a string parameter which it
        // then writes to the console. As the
        // return type is void it does not
        // return a value
        public void PrintMessage(string value)
        {
            Console.WriteLine(value);
        }

        // A method that calls another method
        // from within the class and then
        // prints the returned value
        public void PrintProduct(int a, int b)
        {
            var product = Multiply(a, b);
            Console.WriteLine(product);
        }

        // A public method that returns an int
        // value of the sum of the parameters
        public int Add(int x, int y)
        {
            return x + y;
        }

        // A method that uses an expression body
        public int Subtract(int x, int y) =&gt; x - y;

        // A private method that can only
        // that can only be accessed from
        // within the enclosing type
        private int Multiply(int x, int y)
        {
            return x * y;
        }

        // Syntax error, a method with a return type must have a return statement
        //public int Sum(int a, int b, int c, int d)
        //{
        //    var result = a + b + c + d;
        //}

        // Syntax error, the if statement does not return a value if x == 0
        //public int Sum(int a, int b, int c, int d)
        //{
        //    if (x != 0)
        //     return  a + b + c + d;
        //}
    }

    class Program
    {
        static void Main(string[] args)
        {
            MyClass myClass = new MyClass();
            var sum = myClass.Add(2, 3);
            var difference = myClass.Subtract(7, 4);
            Console.WriteLine($"2 + 3 = {sum}");
            Console.WriteLine($"7 - 4 = {difference}");
            Console.Write("5 x 6 = ");
            myClass.PrintProduct(5, 6);
        }
    }
}

// The example writes the following to the console
// 2 + 3 = 5
// 7 - 4 = 3
// 5 x 6 = 30
</code></pre>
                    <!-- !SECTION Methods -->
                    <!-- SECTION Constructors -->
                    <h3 id="Constructors">Constructors</h3>
                    <p>When an object is created a constructor is called that can be used to set its data and provide other actions that initialize the object's
                        state. The syntax for a constructor is similar to that of a <a href="#Methods">method</a> in that it has a
                        <a href="#Parameters,_signatures_and_overloading">signature</a> that can take in parameters and is a container for one or more
                        <a href="#Code_Syntax">statements.</a> Unlike a method it cannot return a value, its identifier is always that of the type that contains it and
                        it can only be called once when the object is created.</p>
                    <p>A constructor can be marked with various <a href="#Modifiers">modifiers</a> that change its behavior and an instance constructor can be
                        <a href="#Parameters,_signatures_and_overloading">overloaded.</a> By using the <code>this</code> keyword, a constructor can call another
                        overloaded constructor when an object is created. In an instance type, if no constructors are declared the compiler will provide a default
                        parameterless constructor with an empty code block. If constructors are declared then the compiler will not declare the default constructor, so in
                        this case if a parameterless constructor is required it will need to be explicitly declared. To create an instance of a type the <code>new</code>
                        keyword is used to call an instance constructor. Constructors with a single expression can be implemented in the form of an
                        <a href="#The_lambda_and_expression-body_definition_operator">expression-bodied member</a></p>
                    <p>Both instance and static constructors can be declared in <a href="#class">classes</a>, <a href="#struct">structs</a> and
                        <a href="#record">records</a> whereas only static constructors can be declared in an <a href="#interface">interface.</a> A class or record can
                        declare both parameterless and parameterized constructors whereas a struct can only declare parameterized constructors (<em>Note:</em> <i>
                        parameterized constructors will be allowed in structs beginning with C# 10.0</i>). An instance constructor cannot access a field marked static
                        readonly and a static class cannot contain an instance constructor. An instance type can contain a static constructor but a static constructor
                        cannot be used to create an instance of a type.</p>
                    <p>The following example demonstrates the declaration and usage of constructors. The first class called <code>DefaultClass</code> does not explicitly
                        declare a constructor so the compiler declares a default parameterless constructor that can be called to instantiate it.
                        <code>ParameterizedClass</code> explicitly declares a single parameterized constructor. As this prevents the compiler from implicitly declaring a
                        parameterless constructor, when an attempt is made to instantiate the class using one, it results in a <a href="#Syntax_errors">syntax error.</a>
                        The <code>Person</code> class has four explicitly declared overloaded constructors. The first is parameterless so creating an instance of
                        <code>Person</code> using a parameterless constructor is permitted and it sets the values of the two <a href="#Fields">fields</a>
                        <code>_firstName</code> and <code>_lastName</code> to <i>First name</i> and <i>Last name</i> respectively. The second constructor has two
                        parameters and sets <code>_firstName</code> and <code>_lastName</code> to the values passed in. The third constructor has one parameter and makes
                        use of the expression-bodied member syntax setting only the value of the <code>_firstName</code> field. The fourth constructor has three
                        parameters, <code>id</code>, <code>firstName</code> and <span class="nowrap"><code>lastName</code>.</span> Using the <code>this</code> keyword it
                        calls the second constructor, passing in <code>firstName</code> and <code>lastName</code> then uses <code>id</code> to set the <code>_id</code>
                        field using expression-bodied syntax.</p>
<pre><code>    namespace Constructors
    {
        // If no constructors are declared the compiler
        // implicitly declares a default parameterless constructor
        public class DefaultClass { }

        // If a constructor is explicitly declared the
        // compiler won't declare a default constructor
        public class ParameterizedClass
        {
            public ParameterizedClass(int value) { }
        }

        // The 'Person' class declares three overloaded constructors
        public class Person
        {
            private string _firstName;
            private string _lastName;
            private int _id;

            // An explicitly declared parameterless
            // constructor that initializes both fields
            public Person()
            {
                _firstName = "First name";
                _lastName = "Last name";
            }

            // A constructor with two parameters that initializes
            // both fields using the arguments passed in
            public Person(string firstName, string lastName)
            {
                _firstName = firstName;
                _lastName = lastName;
            }

            // A constructor that uses expression-bodied syntax which
            // initializes one field only using the argument passed in
            public Person(string firstName) =&gt; _firstName = firstName;

            // Calls the constructor with two parameters and then
            // sets the '_id' field using expression-bodied syntax
            public Person(int id, string firstName, string lastName)
                : this(firstName, lastName) =&gt; _id = id;
        }

        class Program
        {
            static void Main(string[] args)
            {
                // This object is instantiated using
                // the default parameterless constructor
                DefaultClass defaultClass = new();

                // Syntax error, this class has only one
                // constructor that requires a constructor
                //ParameterizedClass parameterizedClass = new();

                // Instantiated using the explicitly
                // declared parameterless constructor
                Person person1 = new();

                // A second instance using the overloaded
                // constructor with two parameters
                Person person2 = new("John", "Smith");

                // A third instance using the overloaded
                // constructor with one parameter
                Person person3 = new("Susan");

                // A fourth instance using the overloaded
                // constructor with four parameters
                Person person4 = new(1, "Susan", "Smith");
            }
        }
    }

    // This example does not write anything to the console
</code></pre>
                    <!-- !SECTION Constructors -->
                    <!-- SECTION Fields -->
                    <h3 id="Fields">Fields</h3>
                    <p>A variable declared inside a type but outside any other member is called a field and is used to store data about an object. They are declared using
                        an optional <a href="#Access_modifiers">access modifier</a>, followed by the field's type, followed by an identifier that is unique within the
                        field's containing type. Fields are normally declared either private or protected. This provides <a href="#Encapsulation">encapsulation</a> and
                        access to a field is achieved through other members within the type including <a href="#Properties">properties</a>,
                        <a href="#Methods">methods</a>, <a href="#Indexers">indexers</a> and <a href="#Constructors">constructors.</a> This has the advantage of allowing
                        for data validation and performing other tasks before or after changing its value. Most commonly, external access to a field is through a property
                        and when this is done the field is called a <i>backing field</i>.</p>
                    <p>A variable field does not have to be initialized with a value and if not, will be initialized by the compiler to the default value for its type.
                        When the program is run, field initialization occurs in the order of</p>
                    <p><i>declaration &gt; constructor &gt; object initializer</i>.</p>
                    <p>This means that setting a field's value in a constructor will overwrite a value set in the declaration and setting its value in an
                        object-initializer will overwrite the value set both in the field declaration, a constructor or an init accessor of a property.</p>
                    <p>A variable field can be made readonly through the use of the <code>readonly</code> keyword in which case it can only be initialized either by
                        declaration or in a constructor. How this effects a variable though depends on whether it is a value or a reference type. As a value type contains
                        its data it can't be changed after being initialized. As a reference type only stores the address in memory of the data, it is only this reference
                        that can't be changed and not the data itself. For example, if a <code>List&lt;T&gt;</code> is declared as a public read-only field, code outside
                        the class can still add and remove items from the list.</p>
                    <p><em>Note:</em><i> Whilst a <a href="#string">string</a> is a reference type as it is immutable declaring it <code>readonly</code> prevents it from
                        being assigned to after initialization.</i></p>
                    <p>By convention fields are normally declared at the top of a class before any other code. Access to a field by code external to the type is in the
                        form of <span class="nowrap"><code>instance.Field</code>.</span></p>
                    <p>The following example demonstrates field declaration and use.</p>
<pre><code>namespace Fields
{
    public class Person
    {
        // NOTE: instance fields should never be declared public
        // and are only shown here for demonstrative purposes

        // This field has been declared public and can be accessed
        // from any code outside this class both in and outside the
        // assembly that contains it. It is a reference type and will
        // need a value assigned to it in this case an empty string
        public string ID = string.Empty;

        // A private field string that has been made nullable
        // and so does not have to be assigned a value
        private string? _name;

        // With no access modifier this field is private. It is a value type so
        // does not have to be initialized and will have the default value of 0
        int _age;

        // A private field of type double which is initialized to 55.4
        private double _weight = 55.4;

        // A public read only field of type string. Its
        // value can only be set through the constructor
        public readonly string Details;

        // A public read only field of type List &lt;T&gt;. As it is a mutable
        // reference type the data it contains can still be modified
        // from any code outside this class both in and outside
        // the assembly that contains it
        public readonly List&lt;string&gt; Skills;

        // A parameterless constructor that sets the Details field
        // using the default values of the other fields
        public Person()
        {
            Details = $"ID: {ID}, Name: {_name}, Age: {_age}, Weight: {_weight}kg";
            Skills = new();
        }

        // This constructor takes in arguments to set the
        // Id, _Name, _Age and _Weight fields. These values
        // are then used to set the value of the Details field
        public Person(string id, string name, int age, double weight)
        {
            ID = id;
            _name = name;
            _age = age;
            _weight = weight;
            Details = $"ID: {ID}, Name: {_name}, Age: {_age}, Weight: {_weight}kg";
            Skills = new();
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Person person1 = new();
            Person person2 = new("Person2", "John Smith", 23, 50);
            Person person3 = new("Person3", "Andrew Smith", 23, 50)
            {
                ID = "Other"
            };

            // Each instance contains its own copy of the fields
            Console.WriteLine($"person1 details - {person1.Details}");
            Console.WriteLine($"person2 details - {person2.Details}");
            Console.WriteLine($"person3 details - {person3.Details}");

            // person3.Id contains 'Other' as it was changed in the object initializer
            Console.WriteLine($"person3 ID: {person3.ID}");

            // As person3.Id is public direct access is allowed that cannot be
            // validated. Changes to person3.Id don't affect person3.Details
            person3.ID = "Invalid ID";
            Console.WriteLine($"person3 ID: {person3.ID}");
            Console.WriteLine($"person3 details - {person3.Details}");

            // Syntax error, a readonly field value type variable
            // can't be assigned to after initialization
            //person3.Details = "Change details";

            // As readonly Skills is a reference type its data can still be modified
            person3.Skills.Add("C# programming");
            Console.WriteLine($"person3 hobbies: {person3.Skills[0]}");
        }
    }
}

// The example writes the following to the console
// person1 details - ID: , Name: , Age: 0, Weight: 55.4kg
// person2 details - ID: Person2, Name: John Smith, Age: 23, Weight: 50kg
// person3 details - ID: Person3, Name: Andrew Smith, Age: 23, Weight: 50kg
// person3 ID: Other
// person3 ID: Invalid ID
// person3 details - ID: Person3, Name: Andrew Smith, Age: 23, Weight: 50kg
// person3 hobbies: C# programming
</code></pre>
                    <!-- !SECTION Fields -->
                    <!-- SECTION Constant fields -->
                    <h3 id="Constant_fields">Constant fields</h3>
                    <p>Like a variable field, a constant field is declared inside a type but outside any other member. They are declared using an optional
                        <a href="#Access_modifiers">access modifier</a>, followed by the <code>const</code> keyword, followed by the constant field's type, followed by an
                        identifier that is unique within the constant field's containing type. A constant field can only and <em>must have</em> its value initialized when
                        it is declared. As with variable fields, constant fields are normally declared at the top of the type. By convention a constant field's identifier
                        is written in all capitals such as <span class="nowrap"><code>CONSTANT</code>.</span></p>
                        <p>A constant field is already effectively <a href="#static">static</a> so the <code>static</code> keyword cannot be applied to it. Like static
                            members, a constant field cannot be accessed by code through an instance of the type but through the type itself.</p>
                        <p>Access to a property by code external to the type is in the form of <span class="nowrap"><code>Type.CONSTANT</code>.</span></p>
                        <p>The following example demonstrates constant field declaration and use.</p>
<pre><code>    namespace ConstantFields
    {
        public class MathConstants
        {
            // A public constant of type double. Its value must be
            // initialized within the declaration and cannot be changed
            // Convention for naming constants is to use all capitals
            public const double PI = 3.1415;

            // A member within an instance of MathConstants can access
            // constant field PI without the need for the Type identifier
            public double Area(double r)
            {
                return PI * r * r;
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                // A constant accessed using type's identifier 'MathConstants'
                var area1 = MathConstants.PI * 2 * 2;
                Console.WriteLine($"The area of circle 1 with a radius of 2 is {area1}");

                MathConstants mathConstants = new();

                // Syntax error, a constant field cannot be accessed through an instance
                //var pi = mathConstants.PI;

                var area2 = mathConstants.Area(3);
                Console.WriteLine($"The area of circle 2 with a radius of 3 is {area2}");
            }
        }
    }

    // The example writes the following to the console

    // The area of circle 1 with a radius of 2 is 12.566
    // The area of circle 2 with a radius of 3 is 28.2735
</code></pre>
                    <!-- !SECTION Constant fields -->
                    <!-- SECTION Properties -->
                    <h3 id="Properties">Properties</h3>
                    <p>A property is a way of allowing external code to have controlled access to data within an object. It does this by providing special methods that
                        can read from and write to the data, most often a single field which in this context is known as a <i>backing field</i>. The data the property
                        accesses must be of the same type as the property's declared type. Whilst the default access level for a property is private, an optional
                        <a href="#Access_modifiers">access modifier</a> is normally applied to allow for access outside its containing type. Declaration of a property can
                        take one of two forms, <i>manually-implemented</i> or <i>auto-implemented</i>.</p>
                    <p>Manually-implemented properties can be declared using an optional access modifier, followed by the property's type, followed by an identifier that
                        is unique within the property's containing type, followed by a pair of braces that define a code block which is the body of the property. This can
                        contain one or both of two special methods which include a <i>getter</i> declared using the <code>get</code> keyword to read data from the object
                        and a <i>setter</i> declared using either the <code>set</code> or <code>init</code> keywords to write data to the object. Collectively
                        <code>get</code>, <code>set</code> and <code>init</code> are called <i>accessors</i> with <code>set</code> and <code>init</code> being mutually
                        exclusive. A property can be made read/write by using both a getter and a setter, read-only by only using a getter or write-only by only using a
                        setter, though the latter is an extremely rare situation.</p>
                    <p>Both the getter and the setter each have their own code block. Within the setter code block the <code>value</code> keyword is used to hold the
                        value passed in to the property which is to be assigned to the data, in the form of <span class="nowrap"><code>data = value;</code>.</span> Other
                        statements can be placed in the setter to validate the value before it is written to the data or to perform an action before or after this is
                        done. This could include <a href="#Events">raising an event</a> to communicate to other objects that the property's value has changed. Within
                        getter code block this usually takes the form of <span class="nowrap"><code>return backingField</code>.</span> As with <code>set</code>, other
                        code can also be placed within the <code>get</code> code block. In both cases such code should be limited and where more complex procedures are
                        required a <a href="#Methods">method</a> should be utilized. An alternative to <code>set</code> is <code>init</code> which can only be called by
                        the constructor or an object-initializer, which makes the property read-only after it has been initialized during the object's instantiation. As
                        with <code>set</code> a property can be made write-only by only using <span class="nowrap"><code>init</code>.</span> The <code>set</code> and
                        <code>init</code> keywords are mutually exclusive. Collectively <code>set</code>, <code>init</code> and <code>get</code> are called
                        <i>accessors</i>. An accessor that has a single expression can be implemented in the form of an
                        <a href="#The_lambda_and_expression-body_definition_operator">expression-bodied member.</a></p>
                    <p>The default access for accessors is that of the property containing them, but can be changed through the use of access modifiers provided that</p>
                    <ul>
                        <li>the property is read/write</li>
                        <li>only one of the accessors has the access modifier applied</li>
                        <li>the access modifier is more restrictive than the property container</li>
                    </ul>
                    <p>This means for example, if a property is public and the <code>set</code> accessor is made private then the property can be read from outside the
                        class but only set by other members within it. </p>
                    <p><em>Note:</em><i> Applying an access modifier to a <code>get</code> accessor is not recommended and making an <code>init</code> accessor private
                         has the effect that the property can only be initialized in a constructor and <b>not</b> an object-initializer. </i></p>
                    <p>Auto-implemented properties have accessors that are declared without an implementation code block and without declaring a separate  backing field
                        allowing the property to be written with one line of code. During runtime the compiler creates a hidden private backing field that can only be
                        accessed through the property. An advantage of an auto-implemented property is that it can be initialized through the declaration. For a
                        read/write property either both accessors must be manually-implemented or auto-implemented. An auto-implemented property must always have a
                        <code>get</code> accessor so it cannot be write-only.</p>
                    <p>Whilst the order of getters and setters in both manually-implemented or auto-implemented properties doesn't matter, by convention getters are
                        normally declared first. Access to a property by code external to the type is in the form of <code>instance.Property</code> for an instance of a
                        type and <code>TypeName.Property</code> for a <a href="#static">static</a> type.</p>
                    <p>The following example demonstrates property declaration and use.</p>
<pre><code>namespace Properties
{
    public enum SkillLevel { None, Beginner, Intermediate, Expert }

    public class Student
    {
        private string? _firstName;
        private string? _lastName;
        private int _courseLength;
        private string? _password;
        private string? _courseName;
        private DateTime _created;

        public Student(long id, string courseName, int courseLength,  DateTime enrollmentDate, string password)
        {
            ID = id;
            CourseName = courseName;
            CourseLength = courseLength;
            EnrollmentDate = enrollmentDate;
            Password = password;
            Created = DateTime.Now;
            Modified = Created;
        }

        // A manually-implemented property with full accessor code blocks.
        public string? FirstName
        {
            get
            {
                return _firstName;
            }
            set
            {
                _firstName = value;
            }
        }

        // Accessors with a single expression
        // implemented as expression-bodied members
        // The get does not require the return
        // keyword and neither accessor
        // requires braces to define a code block.
        public string? LastName
        {
            get =&gt; _lastName;
            set =&gt; _lastName = value;
        }

        // A property with a expression-bodied get and
        // an inti accessor with a full code block accessor.
        public int CourseLength
        {
            get =&gt; _courseLength;
            init
            {
                if (value &lt;= 0)
                    throw new ArgumentOutOfRangeException(nameof(value), "Must be more than zero");
                _courseLength = value;
            }
        }

        // A read-only property can only be initialized in the constructor
        // but still allows code within the expression to be run.
        // This property does not use a backing field.
        public DateTime ExpectedCompletionDate =&gt; EnrollmentDate.AddYears(CourseLength);

        // A write only property is actively discouraged
        // within Microsoft's reference documentation.
        public string Password { set =&gt; _password = value; }

        // A read/write property with have an access modifier.
        // It can be read externally but only set within the class.
        public string? CourseName
        {
            get =&gt; _courseName;
            private set =&gt; _courseName = value;
        }

        // A manually-implemented property with an init accessor.
        public DateTime Created
        {
            get =&gt; _created;
            init =&gt; _created = value;
        }

        // An auto-implemented property has its own hidden backing
        // field and can be initialized as part of its declaration.
        public SkillLevel ProgrammingSkillLevel { get; set; } = SkillLevel.Beginner;

        // An auto-implemented read-only property.
        public long ID { get; }

        // An auto-implemented read/write property with an access modifier
        public DateTime Modified { get; private set; }

        // An auto-implemented read/write property with an init accessor
        public DateTime EnrollmentDate { get; init; }

        // Syntax error, an auto-implemented property must have a get
        //public string Password2 { set; }

        // Syntax error, only one accessor can have an access modifier
        //public string User { internal get; private set; }

        // Syntax error, an accessor access modifier must be
        // more restrictive than the property containing it
        //public string Password2 { public get; set; }

        public string LogIn(string password)
        {
            // Syntax error, can't read a write only property
            //if (password == Password)

            // This accesses the _password field so is OK
            if (password == _password)
                return ("login successful");
            return "login failed";
        }

        public void Update(string courseName)
        {
            CourseName = courseName;
            Modified = DateTime.Now;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            string nl = Environment.NewLine;

            Student student = new(1, "Programming in Java masters", 2, new DateTime(2021, 12, 5), "password")
            {
                // Assign values to properties in an object initializer
                FirstName = "Jane",
                LastName = "Robinson",
                ProgrammingSkillLevel = SkillLevel.Intermediate,
                Created = new DateTime(2021, 12, 4)
            };

            Console.WriteLine($"ID: {student.ID}, {student.FirstName} {student.LastName}");
            Console.WriteLine($"Course: {student.CourseName}, Length: {student.CourseLength} years");
            Console.WriteLine($"Enrolled: {student.EnrollmentDate:dd MMM yyyy}");
            Console.WriteLine($"Expected Finish Date: {student.ExpectedCompletionDate:dd MMM yyyy}");
            Console.WriteLine($"Current Skill Level {student.ProgrammingSkillLevel}");
            Console.WriteLine($"Record created: {student.Created:dd MMM yyyy}{nl}");

            student.Update("Programming in C# masters");
            Console.WriteLine($"ID: {student.ID}, {student.FirstName} {student.LastName}");
            Console.WriteLine($"Course: {student.CourseName}, Length: {student.CourseLength} years");
            Console.WriteLine($"Last updated: {student.Modified:dd MMM yyyy}{nl}");

            // Syntax error, can only assign a value to a property with an
            // init accessor in a constructor or an object initializer
            //student1.Created = DateTime.Now;

            Console.WriteLine($"Attempting student login before changing password, {student.LogIn("password")}");
            // Assign a value to a write only property
            student.Password = "NewPassword";
            Console.WriteLine($"Attempting student login after changing password, {student.LogIn("password")}");
        }
    }
}

// The example prints the following to the console
// ID: 1, Jane Robinson
// Course: Programming in Java masters, Length: 2 years
// Enrolled: 05 Dec 2021
// Expected Finish Date: 05 Dec 2023
// Current Skill Level Intermediate
// Record created: 04 Dec 2021

// ID: 1, Jane Robinson
// Course: Programming in C# masters, Length: 2 years
// Last updated: 09 Dec 2021

// Attempting student login before changing password, login successful
// Attempting student login after changing password, login failed
    </code></pre>
                    <!-- !SECTION Properties -->
                    <!-- SECTION Events -->
                    <h3 id="Events">Events</h3>
                    <p>An event is a way for a class to communicate with other objects that something within it has occurred. This could be a button click, completion of
                        a task, change of state, etc. The class that <i>raises</i> the event is known as a <i>publisher</i> and the objects receiving the event
                        are known as <i>subscribers</i>. When a publisher declares an event, it in turn allows the declaration of a special type of multicast
                        <a href="#delegate">delegate</a> and provides methods that a subscriber can use to add or remove instances of the delegate. When an event is
                        raised, the delegate is then used to invoke a method within the subscriber which in this case is known as an <i>event handler</i>. By being
                        multicast, the delegate allows multiple objects to subscribe to the same event or for a subscriber to use the same event handler to handle the same
                        type of event from multiple publishers.</p>
                    <p>Whilst a delegate can declare a signature that defines a return type, a multicast delegate only returns a value from the last event handler that
                        was invoked. For this reason, the standard event delegate signature is one that returns void and contains two parameters. The first parameter is
                        an object that refers to the instance that raised the event. The second is a type that can optionally contain event data including values that can
                        be changed in the event handler to effectively supply a return value. A common type for containing event data is one that is
                        <a href="#Inheriting_types">derived</a> from the <code>EventArgs</code> class.</p>
                    <p>C# .NET provides many built-in delegates for use with events which are suffixed with <i>EventHandler</i>. There two most common are
                        <code>EventHandler</code> and <span class="nowrap"><code>EventHandler&lt;TEventArgs&gt;</code>.</span></p>
                    <p><code>EventHandler</code> is used when the event does not include event data. It declares <code>EventArgs</code> as the second parameter which is
                        set to the <code>EventArg.Empty</code> field when invoking the event.</p>
                    <p><code>EventHandler&lt;TEventArgs&gt;</code> can be used to send event data. Originally it was required that the return data type be derived from
                        <code>EventArgs</code> which is why <i>TEventArgs</i> is still mentioned in much of the online documentation, but that constraint has been removed
                        and any type can now be specified. An <code>EventArgs</code> derived type is still advantageous, particularly where more complex types are
                        employed and for reasons of <a href="#Polymorphism_implementation">polymorphism.</a> If there is a requirement to return a value then a reference
                        type should be used.</p>
                    <p>An event can't be invoked from outside the class that contains it so an additional method is required to call the event. It is common that such a
                        method be marked <code>virtual</code> so they can be <a href="#override">overridden</a> if the class can be inherited. The
                        naming convention for such a method is the name of the event prefixed with <i>On</i> such as <span class="nowrap"><code>OnEvent</code>.</span> The
                        naming convention for subscriber event handlers is the instance or type identifier followed by an underscore followed by the event identifier such
                        as <span class="nowrap"><code>instance_SomeEvent</code>.</span> An event handler can also be in the form of a
                        <a href="#Lambda_expressions">lambda expression.</a></p>
                    <p><em>Note:</em> <i>When an event has multiple subscribers the order in which they receive the event is not always guarantied. A subscriber should
                        not rely on another having already handled the event.</i></p>
                    <p>In the following example the <code>Clock</code> class declares <code>Started</code>, <code>Stopped</code> and <code>Ticked</code> events and the
                        <code>Program</code> class subscribes and declares event handlers to all of them. The <code>Clock</code> class also declares a <code>Timer</code>
                        instance that provides a continuous <code>Timer.Elapsed</code> event at one second intervals which is handled by a <code>Timer_Elapsed</code>
                        event handler. This in turn calls the <code>OnTicked</code> method that then invokes the <code>Ticked</code> event. When the
                        <code>_clock_Tick</code> event handler in <code>Program</code> is invoked it writes the current time to the console. The
                        <code>Clock.Started</code> event takes a <code>DateTime</code> type which is used to pass the start time to the <code>_clock_Started</code> event
                        handler. The <code>Clock.Stopped</code> event takes a custom type <code>StoppedEventArgs</code> derived from <code>EventArgs</code> which is used
                        to pass the stop time to the <code>_clock_Stopped</code> event handler. <code>StoppedEventArgs</code> has a <code>DateTime</code> type
                        <code>Time</code> property that is set by the constructor. The example also employs <code>Console.ReadKey</code> to test whether the user has
                        pressed the <b>Enter</b> key to end the program.</p>
<pre><code>namespace Events
{
    public class Clock
    {
        // The fully qualified name is required as the implicit global using
        // 'global using global::System.Threading' also contains a type called Timer
        System.Timers.Timer _timer = new System.Timers.Timer();

        // An event that can be raised when the clock is started
        // EventHandler &lt;TEventArgs&gt; delegate type is declared
        // The EventArgs parameter is the DateTime type
        public event EventHandler&lt;DateTime&gt;? Started;

        // An event that can be raised when the clock is stopped
        // The EventArgs parameter is the custom StoppedEventArgs type
        public event EventHandler&lt;StoppedEventArgs&gt;? Stopped;

        // An event that can be raised when the clock ticked. It does
        // not have event data so EventHandler delegate is declared
        // as it declares dataless EventArgs for the second parameter
        public event EventHandler? Ticked;

        // A method to call to invoke the Started event
        protected virtual void OnStarted()
        {
            // Create a parameter to pass to the Started event
            DateTime args = DateTime.Now;
            // Raise the Started event
            Started?.Invoke(this, DateTime.Now);
        }

        // A method to call to invoke the Stopped event
        protected virtual void OnStopped()
        {
            // Create an instance of custom StoppedEventArgs
            // to pass as a parameter to pass to the Started event
            StoppedEventArgs stoppedEventArgs = new(DateTime.Now);
            // Raise the Stopped event
            Stopped?.Invoke(this, stoppedEventArgs);
        }

        // A method to call to invoke the Ticked event
        protected virtual void OnTicked()
        {
            // Raise the Ticked event, no EventArgs value is to be passed
            // so it is set to the static read-only EventArgs.Empty field
            Ticked?.Invoke(this, EventArgs.Empty);
        }

        // Event handler for Timer.Elapsed event
        private void Timer_Elapsed(object? sender, System.Timers.ElapsedEventArgs e)
        {
            OnTicked();
        }

        public void Start(double interval)
        {
            _timer = new(interval);
            // Subscribe to the Timer.Elapsed event and
            // declare Timer_Elapsed as the event handler
            _timer.Elapsed += Timer_Elapsed;
            _timer.AutoReset = true;
            _timer.Enabled = true;
            OnStarted();
        }

        public void Stop()
        {
            _timer.Stop();
            // The timer object is disposed so that the
            // garbage collector can remove it from memory
            _timer.Dispose();
            OnStopped();
        }
    }

    // Create a custom that inherits from EventArgs
    // to be passed by the Clock.Stopped event
    public class StoppedEventArgs : EventArgs
    {
        public StoppedEventArgs(DateTime time) =&gt; Time = time;
        public DateTime Time { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Clock _clock = new();
            // Subscribe to the Clock.Started event and
            // declare _clock_Started as the event handler
            _clock.Started += _clock_Started;

            // Subscribe to the Clock.Stopped event and declare
            // an event handler using a lambda expression
            _clock.Stopped += (s, e) =&gt;
            {
                Console.WriteLine($"\rThe clock was stopped at {e.Time:T}");
            };

            // Start the clock with a tick interval of 1 second (1000 ms)
            _clock.Start(1000);
            Console.WriteLine("Press enter to stop the clock");

            // Subscribe to the Clock.Ticked event and
            // declare _clock_Ticked as the event handler
            _clock.Ticked += _clock_Ticked;

            // Wait until the user presses the 'enter' key
            while (Console.ReadKey(true).Key != ConsoleKey.Enter) { }

            // Unsubscribe from the Clock.Ticked event
            _clock.Ticked -= _clock_Ticked;
            _clock.Stop();
        }

        // Event handler for Clock.Started event
        private static void _clock_Started(object? sender, DateTime e)
        {
            Console.WriteLine($"The clock started at {e:T}");
        }

        // Event handler for Clock.Ticked event
        private static void _clock_Ticked(object? sender, EventArgs e)
        {
            Console.Write($"\rCurrent time: {DateTime.Now:T}");
        }
    }
}

// The example writes the current time to the
// console until the user presses the enter key
</code></pre>
                    <p>There are situations where you may wish to cancel an event. One such scenario is when closing a program and you want to give the user the
                        opportunity to save unsaved data before this occurs. C# .NET provides the <code>CancelEventHandler</code> delegate to achieve this which passes
                        a <code>CancelEventArgs</code> parameter to the event handler. <code>CancelEventArgs</code> has a bool type property <code>Cancel</code> which can
                        be set in the event handler to indicate if the event should be cancelled.</p>
                    <p>In the following example the <code>ApplicationManager</code> class declares an <code>Exiting</code> event that in turn declares a
                        <code>CancelEventHandler</code> type delegate. The <code>Program</code> class subscribes to the <code>Exiting</code> event and declares an event
                        handler for this using a <a href="#Lambda_expressions">lambda expression.</a> Within the Main method are two while loops, one testing if the user
                        presses the <b>x</b> key, nested in another that tests if the <code>AllowExit</code> property is true. When the <b>x</b> key is pressed,
                        <code>Exit</code> is called which calls <code>OnExiting</code> which invokes the <code>Exiting</code> event. Within the <code>Exiting</code> event
                        handler in <code>Program</code>, the <code>CancelEventArgs.Cancel</code> property is set <code>true</code> or <code>false</code> depending if the
                        <b>y</b> key is pressed, then passed back to <code>OnExiting</code> then to <code>Exit</code> where it sets the <code>AllowExit</code> property.
                        Execution passes back to the while loops which it exits if <code>AllowExit</code> is true and the program then terminates.</p>
<pre><code>using System.ComponentModel;

namespace CancelEvent
{
    public class ApplicationManager
    {
        bool ExitingCalled;

        // An event with CancelEventArgs type parameter
        public event CancelEventHandler? Exiting;

        public bool AllowExit { get; set; }

        // The OnExiting method takes a CancelEventArgs parameter
        // so that its Cancel property can be passed back
        protected virtual void OnExiting(CancelEventArgs e)
        {
            Exiting?.Invoke(this, e);
        }

        public void Exit()
        {
            // We don't want to call an event while
            // we're still working on a previous one
            if (!ExitingCalled)
            {
                ExitingCalled = true;
                CancelEventArgs args = new();
                OnExiting(args);
                if (args.Cancel)
                {
                    ExitingCalled = false;
                    return;
                }
                // Use the CancelEventArgs.Cancel property set by the
                // Exiting event handler to set the AllowExit property
                AllowExit = true;
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ApplicationManager _applicationManager = new();
            // Subscribe to the _applicationManager.Exiting event and
            // declare _applicationManager_Exiting as the event handler
            _applicationManager.Exiting += (s, e) =&gt;
            {
                Console.WriteLine("Are you sure you want to exit the program");
                Console.WriteLine("Press y to confirm ending the program or any other key to cancel");
                // Set the CancelEventArgs.Cancel property true if user does not press 'y'
                e.Cancel = Console.ReadKey(true).Key != ConsoleKey.Y;
            };

            // Loop until the user presses the 'y' key which sets AllowExit to true
            // depending on the Exiting event CancelEventArgs.Cancel property
            while (!_applicationManager.AllowExit)
            {
                Console.Clear();
                Console.WriteLine("Press x to exit the program");
                // Wait until the user presses the 'x' key
                while (Console.ReadKey(true).Key != ConsoleKey.X) { }
                _applicationManager.Exit();
            }
            Console.WriteLine("You have exited the program");
        }
    }
}

// The example writes the following to the console
// Press x to exit the program
// Are you sure you want to exit the program
// Press y to confirm ending the program or any other key to cancel
// You have exited the program
</code></pre>

                    <!-- !SECTION Events -->
                    <!-- SECTION Indexers -->
                    <h3 id="Indexers">Indexers</h3>
                    <p>An indexer allows an object to be indexed like an array. It is similar to a <a href="#Properties">property</a> but also takes an index value to set
                        or get a specific instance. To declare an indexer first an array or collection backing field is declared to store the instances to be indexed. The
                        indexer is then declared using an optional <a href="#Access_modifiers">access modifier</a>, followed by the <code>this</code> keyword, followed by
                        the type of indexer, followed by square brackets that contain one or more indexes separated by commas, with each consisting of the type of index
                        and an index identifier. Accessors are then used to set and/or get the instances from the backing field using the indexes that are passed in. The
                        same rules as those for read/write and accessibility of properties and accessors also apply to indexers except that an indexer cannot be static
                        and an indexer cannot be auto-indexed. Indexers can be <a href="#Parameters,_signatures_and_overloading">overloaded.</a></p>
                    <p>Access to an indexer by code external to the type is in the form of <code>instance.Indexer[index]</code></p>
                    <p>The following example declares a string collection which uses an indexer to index instances of itself. The <code>Program</code> class creates a new
                        <code>StringCollection</code> instance, assigns the string "Hello World" to the instance at index 0 in the collection, then retrieves the same and
                        finally writes its value to the console.</p>
<pre><code>namespace Indexers
{
    class StringCollection
    {
        private string[] _strings = new string[10];

        public string this[int i]
        {
            get =&gt; _strings[i];
            set =&gt; _strings[i] = value;
        }
    }

    class Program
    {
        static void Main()
        {
            StringCollection stringCollection = new();
            stringCollection[0] = "Hello world";
            Console.WriteLine(stringCollection[0]);
        }
    }
}

// The example writes the following to the console
// Hello world
</code></pre>
                    <!-- !SECTION Indexers -->
                    <!-- SECTION Finalizers -->
                    <h3 id="Finalizers">Finalizers</h3>
                    <p>A finalizer is used to perform any clean-up of the class when it is no longer in use. The compiler adds a default finalizer to each instance of a
                        class that is created. As implementing a finalizer is a rare and complex subject it won't be discussed in this guide.</p>
                    <p><em>Note:</em> <i>In earlier versions of the C# standard a 'finalizer' was called a 'destructor'.</i></p>
                    <!-- !SECTION Finalizers -->
                    <!-- SECTION Local functions -->
                    <h3 id="Local_functions">Local functions</h3>
                    <p>A local function is a private <a href="#Methods">method</a> that can be nested and can only be called from within another member. They can be
                        declared in the following.</p>
                    <ul>
                        <li>Methods</li>
                        <li>Constructors</li>
                        <li>Property accessors</li>
                        <li>Event accessors</li>
                        <li>Anonymous methods</li>
                        <li>Lambda expressions</li>
                        <li>Finalizers</li>
                        <li>Other local functions</li>
                    </ul>
                    <p>A local function can't be declared inside an expression-bodied member.</p>
                    <p>The following example demonstrates declaration and usage of local functions.</p>
<pre><code>namespace LocalFunctions
{
    class Program
    {
        static void Main(string[] args)
        {
            // Declare a locale function
            int Square(int x) =&gt; x * x;

            Console.WriteLine($"The square of 2 is {Square(2)}");
            Console.WriteLine($"The square of 3 is {Square(3)}");
            Console.WriteLine($"The square of 4 is {Square(4)}");
        }
    }
}

// This example writes the following to the console
// The square of 2 is 4
// The square of 3 is 9
// The square of 4 is 16
</code></pre>
                    <!-- !SECTION Local functions -->
                    <!-- SECTION Parameters, signatures and overloading -->
                    <h3 id="Parameters,_signatures_and_overloading">Parameters, signatures and overloading</h3>
                    <p>A <a href="#class">class</a>, <a href="#struct">struct</a>, <a href="#record">record</a> or <a href="#interface">interface</a>, may contain
                        multiple versions, or <i>overloading</i>, of a method, instance constructor, indexer or operator, provided that each has a unique <i>signature</i>
                        defined in part by its <i>parameters</i>.</p>
                    <p><em>Note:</em> <i>unless otherwise stated, member will refer to a method, instance constructor, indexer or operator for the remainder of this
                        section.</i></p>
                    <!-- SECTION Parameters -->
                    <h4 id="Parameters">Parameters</h4>
                    <p>A parameter is a <a href="#Variables,_Constants,_Types_and_Literals">variable</a> declared as part of a member that allows a value from a calling
                        statement to be made available, or <i>passed in</i>, for use by the statements within the member. The corresponding value in the calling statement
                        is called an <i>argument</i>. Parameters are passed in, in the form of a comma separated list within a pair of round brackets that can contain
                        zero or more parameters. Arguments in the calling statement are also in the form of a comma separated list and must either be in the same order as
                        the list of parameters or in the form of named arguments. Parameters can be made optional in which case arguments can be omitted subject to
                        certain conditions. A parameter is defined by a type and an identifier and can be marked with a modifying keyword some of which are,
                        <code>ref</code>, <code>in</code>, <code>out</code> and <span class="nowrap"><code>params</code>.</span> Other than for a parameter marked
                        <code>out</code>, all arguments
                        passed in must be initialized first. A parameter marked <code>out</code> must be initialized before the called code returns.</p>
                    <p>With no modifier the default passing mode is to pass an argument into a parameter by value. If a value type is passed in by value, changing its
                        value within the called member will not affect the argument that was passed in. If a reference type is passed in by value, while it can't be
                        changed to refer to another object, the data it contains can still be changed.</p>
                    <p>A value type that is passed in by reference can be changed within the called member and a reference type passed in by reference can be changed to
                        refer to a different object. Both the argument in the calling code and the parameter in the called member must be marked with the <code>ref</code>
                        keyword.</p>
                    <p>If a parameter in the called member is marked with the <code>in</code> keyword, it becomes readonly and attempting to change a value type marked
                        this way or changing a reference type to refer to another object will result in a <a href="#Syntax_errors">syntax error.</a> The data of a
                        reference type can still be changed. Only the parameter in the called member is required to be marked in.</p>
                    <p>An argument marked with the <code>out</code> keyword causes a value to be passed by reference. It does not have to be initialized first but must be
                        assigned a value in the called member. Both the argument and the parameter must be marked with the <code>out</code> keyword. The variable for the
                        argument can either be declared before or within the calling statement and can be assigned a type either explicitly or implicitly using the
                        <code>var</code> keyword. If implicitly declared before the calling statement, it must be assigned a value.</p>
                    <p>A parameter can be made optional by assigning it a default value in the called member parameter list using the assignment
                        <span class="nowrap">operator <code>=</code>.</span> The calling statement can then optionally assign an argument for the value. If an argument is
                        omitted then the default value is used. The default value assigned must be a constant expression, an expression in the form new ValueType() or an
                        expression in the form default(ValueType). All optional parameters must come after all other parameters other than one marked with the
                        <code>params</code> keyword. If an optional argument in the calling statement is provided then all preceding optional arguments must also be
                        provided.</p>
                    <p>A parameter marked with the <code>params</code> keyword allows a single-dimensional array of arguments to be passed in. The parameter marked this
                        way must come after all other parameters in the list. Arguments passed in from the calling statement are optional and can be either in the form of
                        a comma separated list or an externally declared array of the parameter type.</p>
                    <p>Named arguments allows the calling statement to assign values in an order different to the called member's parameter list. This is done by using
                        the parameter's identifier followed by a colon, optional whitespace and then a literal or a variable of the correct type. Named arguments can be
                        combined with positional arguments provided they precede all positional arguments or are used in their correct positions.</p>
                    <p>The following example demonstrates the declaration and use of parameters and arguments.</p>
<pre><code>namespace Parameters
{
    public class Person
    {
        // By default, arguments are passed in by value.
        public void DisplayAge(int age)
        {
            Console.WriteLine($"Age: {age}");
            age = 0;
        }

        // The 'ref' keyword causes values to be passed in by reference.
        public void DisplaySalary(ref double salary)
        {
            Console.WriteLine($"Hourly rate: {salary}");
            salary = 0;
        }

        // A reference type passed by value can't be changed to refer
        // to another object but the data it contains can be changed
        public void DisplayHobbies(string[] hobbies)
        {
            hobbies[0] = "Gaming";
            hobbies = new string[2] { "Singing", "Writing" };
            Console.Write("Hobbies in method are: ");
            foreach (string hobby in hobbies)
                Console.Write($"{hobby} ");
        }

        // The 'in' keyword passes values by
        // reference but prevents them being changed.
        public void DisplayNameAndAge(string firstName, in int age)
        {
            Console.WriteLine($"Name: {firstName} Age: {age}");
            // Syntax error, 'in' keyword makes 'age' read-only
            //age = 0;
        }

        // The job parameter has a default value so is optional.
        public void DisplayJob(string firstName, string job = "Not specified")
        {
            Console.WriteLine($"Name: {firstName} Job: {job}");
        }

        // The 'params' keyword allows an array of parameters to be passed in.
        public void DisplayColors(string firstName, params string[] colors)
        {
            Console.Write($"Name: {firstName} Favorite colors are: ");
            foreach (string color in colors)
                Console.Write($"{color} ");
        }

        // Result is calculated and the method returns true only if y != 0.
        public bool Divide(double x, double y, out double result)
        {
            result = default;
            if (y == 0)
                return false;
            result = x / y;
            return true;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Person p = new();

            int age = 25;
            // Default passed by value, age is unchanged
            p.DisplayAge(age);
            Console.WriteLine($"age returned as: {age}");

            double salary = 30.5;
            // The 'ref' keyword is required to pass by reference.
            // Salary has changed.
            p.DisplaySalary(ref salary);
            Console.WriteLine($"salary returned as: {salary}");

            string[] hobbies = { "Music", "Sports", "Painting" };
            // A reference type passed by value still refers to the
            // local variable but the data it contains can be changed
            Console.Write($"Hobbies before are: ");
            foreach (string hobby in hobbies)
                Console.Write($"{hobby} ");
            Console.WriteLine();
            p.DisplayHobbies(hobbies);
            Console.WriteLine();
            Console.Write($"Hobbies returned are: ");
            foreach (string hobby in hobbies)
                Console.Write($"{hobby} ");
            Console.WriteLine();

            // The 'in' keyword is not required to pass
            // a value into a parameter marked with 'in'

            p.DisplayNameAndAge("Fred", 22);

            // Provide an argument for the optional parameter

            p.DisplayJob("Debbie", "Developer");

            // No argument provided for the optional parameter

            p.DisplayJob("Peter");

            // params allows optional arguments to
            // passed as a comma separated list
            p.DisplayColors("Jenny", "Red", "Green", "Blue");
            Console.WriteLine();

            string[] colors = { "Magenta", "Yellow", "Cyan" };
            // params also allows an array to be passed in
            p.DisplayColors("Rachel", colors);
            Console.WriteLine();

            // The return variable is declared in the calling statement.
            // This returns false so nothing is written to the console.
            if (p.Divide(3, 0, out var result1))
                Console.WriteLine($"3 divided by 0 = {result1}");

            // The return variable is declared outside the calling statement.
            // This uses named arguments so the order doesn't matter
            double result2;
            if (p.Divide(y: 3, x: 0, result: out result2))
                Console.WriteLine($"0 divided by 3 = {result2}");
        }
    }
}

// The example writes the following to the console
// Age: 25
// age returned as: 25
// Hourly rate: 30.5
// salary returned as: 0
// Hobbies before are: Music Sports Painting
// Hobbies in method are: Singing Writing
// Hobbies returned are: Gaming Sports Painting
// Name: Fred Age: 22
// Name: Debbie Job: Developer
// Name: Peter Job: Not specified
// Name: Jenny Favorite colors are: Red Green Blue
// Name: Rachel Favorite colors are: Magenta Yellow Cyan
// 0 divided by 3 = 0
</code></pre>
                    <!-- !SECTION Parameters -->
                    <!-- SECTION Signatures -->
                    <h4 id="Signatures">Signatures</h4>
                    <p>Multiple overloads of a member with the same identifier can exist within a type, provided that each has a unique signature defined by the
                        combination of certain elements in its declaration. These are as follows.</p>
                    <ul>
                        <li><a href="#Methods">Method</a> - identifier, the number, type and order of parameters, parameter passing mode(ref, value, in, out)</li>
                        <li><a href="#Methods">Instance constructor</a> - the number, type and order of parameters, parameter passing mode(ref, value, in, out)</li>
                        <li><a href="#Methods">Indexer</a> - the number, type and order of parameters</li>
                        <li><a href="#Methods">Operator</a> - identifier, the number, type and order of parameters</li>
                    </ul>
                    <p>Only one of <code>ref</code>, <code>in</code> or <code>out</code> modifiers can be used together with a parameter of the same identifier that has
                        no modifier.</p>
                    <p>Notably the signature does not include the parameter's identifier, the use of the <code>params</code> or <code>this</code> keywords, or whether the
                        parameter is optional. It also does not include the <a href="#access_modifiers">accessibility</a> of the member. A method's return type is not
                        part of its signature in the context of overloading but is in the context of use in <a href="#delegate">delegate</a>, in which case the method's
                        signature must match that of the delegate.</p>
                    <!-- !SECTION Signatures -->
                    <!-- SECTION Overloading -->
                    <h3 id="Overloading">Overloading</h3>
                    <p>Overloading allows multiple versions of a member with the same identifier but unique signatures to exist within the same type. You can then choose
                        which overload to call both internally or externally to the type.
                    </p>
                    <p>The following example demonstrates overloading of a method</p>
<pre><code>namespace OverloadingMethods
{
    public class Person
    {
        // GetDetails has four valid overloads.

        // Signature is the identifier GetDetails and
        // the single string type parameter.
        public string GetDetails(string firstName) =&gt; firstName;

        // Syntax error, parameter differs only by identifier to last example.
        //public string GetDetails(string lastName) =&gt; lastName;

        // An overload of GetDetails with two string parameters.
        public string GetDetails(string firstName, string lastName) =&gt; $"{firstName} {lastName}";

        // An overload of GetDetails with a single double parameter.
        public double GetDetails(double salary) =&gt; salary;

        // An overload of GetDetails with a single int parameter.
        public double GetDetails(int salary) =&gt; salary;

        // Syntax error, this differs from the
        // previous example only by return type
        //public int GetDetails(int age) =&gt; age;

        // Syntax error, the implementation code block is not part of the signature.
        //public string GetDetails(string firstName, string lastName) { }

        // Syntax error, making the lastName optional
        // does not make the signature unique.
        //public string GetDetails(string firstName, string lastName = "") =&gt; $"{firstName} {lastName}";

        public void DisplayDetails(string firstName, string[] hobbies) { }

        // Syntax error, the use of the params keyword on the
        // hobbies array does not make this signature unique
        //public void DisplayDetails(string firstName, params string[] hobbies) { }

        public void Method(int value) { }

        // Uncommenting only one of the following three
        // methods in addition to the previous is OK.
        // Uncommenting two or more whether the previous
        // method exists or not will result in a syntax error.

        //public void Method(ref int value) { }

        //public void Method(out int value) { value = default; }

        //public void Method(in int value) { }
    }

    public class AnotherPerson
    {
        public string? Name { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Person p = new();
            Console.WriteLine($"Name: {p.GetDetails("Tony")}");
            Console.WriteLine($"Name: {p.GetDetails("Tony", "Jones")}");
            int iSalary = 30;
            Console.WriteLine($"Hourly rate: {p.GetDetails(iSalary)}");
            double dSalary = 30.5;
            Console.WriteLine($"Hourly rate: {p.GetDetails(dSalary)}");
        }
    }
}

// The example writes the following to the console
// Name: Tony
// Name: Tony
// Name: Tony Jones
// Hourly rate: 30
// Hourly rate: 30.5
</code></pre>
                    <!-- !SECTION Overloading -->
                    <!-- !SECTION Parameters, signatures and overloading -->
                    <!-- SECTION struct -->
                    <h3 id="struct">struct</h3>
                    <p>A <i>structure</i> usually referred to by its keyword <code>struct</code> is similar to a class with the following main differences.</p>
                    <ul>
                        <li>A struct is a value type</li>
                        <li>The static, abstract and sealed modifiers cannot be applied to a struct</li>
                        <li>The readonly modifier can be applied to a struct</li>
                        <li>An instance field or property in a struct can't be initialized when a struct is declared.</li>
                        <li>A constructor in a struct must initialize all instance fields</li>
                        <li>A struct cannot have a parameterless constructor (<em>Note:</em> <i>will be allowed beginning with C# 10.0</i>) </li>
                        <li>A struct cannot have a finalizer</li>
                        <li>A struct cannot inherit or be inherited by another class or struct</li>
                    </ul>
                    <p>A struct is normally used to create a basic data type with little or no functionality. Within C# <code>int</code>, <code>double</code>,
                        <code>char</code> and <code>bool</code> are all examples of structs. As a struct is a value type so all instance fields it contains must be
                        assigned a value before it can be used. Although a parameterless constructor can't be declared in a struct, the compiler creates one which sets
                        all instance fields to their default values. This can then use this when instantiating a struct with the <code>new</code> keyword. If all instance
                        fields in a struct are accessible then a struct can be instantiated without using the <code>new</code> keyword. For example an integer can be
                        assigned the value 0 either by <code>int x = new();</code> or <span class="nowrap"><code>int x = 0;</code>.</span></p>
                    <p>The following example declares a struct called <code>Box</code> with <code>Width</code>, <code>Height</code> and <code>Depth</code> fields and a
                        method called <span class="nowrap"><code>GetVolume</code>.</span> It demonstrates several ways to declare and assign values to a struct and then
                        writes the values to the console.</p>
<pre><code>namespace Structs
{
    public struct Box
    {
        // As of .NET 6 a parameterless constructor is allowed in
        // structs provided all fields and properties are set within it
        public Box()
        {
            Width = 0;
            Height = 0;
            Depth = 0;
        }

        public Box(int width, int height, int depth)
        {
            Width = width;
            Height = height;
            Depth = depth;
        }

        // Syntax error, a structs constructor must assign values to all instance fields
        //public Box(double width)
        //{
        //    Width = width;
        //    Height = 1;
        //}

        // This is OK as all instance fields have been assigned a value
        public Box(int width)
        {
            Width = width;
            Height = 1;
            Depth = 1;
        }

        public int Width;

        public int Height;

        public int Depth;

        public int GetVolume()
        {
            return Width * Height * Depth;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Create a new box then set its field values
            Box box1 = new();
            box1.Width = 1;
            box1.Height = 2;
            box1.Depth = 3;

            // Create a box and set its field values in the constructor
            Box box2 = new(2, 3, 4);

            // Create a box using an alternate constructor
            Box box3 = new(2);

            // Create a box and set its field values with an object-initializer
            Box box4 = new()
            {
                Width = 4,
                Height = 5,
                Depth = 6
            };

            Console.WriteLine($"Box1 Width: { box1.Width}, Height: {box1.Height}, Length: {box1.Depth}, Volume: {box1.GetVolume()}");
            Console.WriteLine($"Box2 Width: { box2.Width}, Height: {box2.Height}, Length: {box2.Depth}, Volume: {box2.GetVolume()}");
            Console.WriteLine($"Box3 Width: { box3.Width}, Height: {box3.Height}, Length: {box3.Depth}, Volume: {box3.GetVolume()}");
            Console.WriteLine($"Box4 Width: { box4.Width}, Height: {box4.Height}, Length: {box4.Depth}, Volume: {box4.GetVolume()}");

            // If all instance fields are accessible a struct can be instantiated
            // without the new keyword but instance fields must be set before it can be used
            Box box5;

            // Syntax error, use of unassigned variable 'box5'
            //var v = box5.GetVolume();

            box5.Width = 5;
            box5.Height = 6;
            box5.Depth = 7;

            Console.WriteLine($"Box5 Width: { box5.Width}, Height: {box5.Height}, Length: {box5.Depth}, Volume: {box5.GetVolume()}");

            // Although you can't declare a parameterless constructor the compiler always creates one that assigns all instance
            // fields their default values. When displayed box6 will have all fields set to 0 resulting in a volume of 0
            Box box6 = new();

            Console.WriteLine($"Box6 Width: { box6.Width}, Height: {box6.Height}, Length: {box6.Depth}, Volume: {box6.GetVolume()}");
        }
    }
}

// The example writes the following to the console
// Box1 Width: 1, Height: 2, Length: 3, Volume: 6
// Box2 Width: 2, Height: 3, Length: 4, Volume: 24
// Box3 Width: 2, Height: 1, Length: 1, Volume: 2
// Box4 Width: 4, Height: 5, Length: 6, Volume: 120
// Box4 Width: 5, Height: 6, Length: 7, Volume: 210
// Box6 Width: 0, Height: 0, Length: 0, Volume: 0
</code></pre>
                    <!-- !SECTION struct -->
                    <!-- SECTION record -->
                    <h3 id="record">record</h3>
                    <p>A <code>record</code> provides all the same functionality of a class with some notable differences. It is a
                        <a href="#Reference_type">reference type</a> with <a href="#Value_type">value type</a> equality. Two record variables are equal if their
                        definitions are identical and all field and property values are the same. A record also provides <i>positional syntax</i> for declaring
                        <a href="#Properties">properties</a> through the use of <i>positional parameters</i>. The compiler then automatically creates a
                        <a href="#Access_modifiers">public</a> auto-implemented property with an <code>init</code> setter for each parameter and a prime
                        <a href="#Constructors">constructor</a> that sets the properties from those parameters. It provides nondestructive mutation through use of the
                        <code>with</code> keyword and a destructor method that makes available for use, all properties created using the positional parameters. It also
                        provides a <code>ToString</code> method that returns the identifier of the record type and all public properties and their values.</p>
                    <p>Whilst the main purpose of a record is to create immutable data, you can declare and provide your own implementation of the auto-implemented
                        by using the same identifiers as those of the positional parameters. This allows you to change accessibility, property accessor mutability or
                        provide your own accessor implementation. Additionally, the prime constructor can be overloaded using the <code>this</code>
                        keyword. In both of these cases you then need to set the property values using the values of the positional parameters.</p>
                    <p>The following example demonstrates how to declare and use records.</p>
<pre><code>    namespace Records
    {
        // Declare a record with four positional parameters. The compiler
        // creates auto-properties and a prime constructor to set them
        public record Person(string FirstName, string LastName, int ID, int Age)
        {
            // An overloaded constructor in a record with positional
            // parameters must use 'this' syntax to set the prime constructor.
            public Person(string FirstName, string LastName, int ID, int Age, string job)
                : this(FirstName, LastName, ID, Age) =&gt; Job = job;

            // Accessibility changed to 'internal'.
            internal int ID { get; init; } = ID;

            // Accessor changed from 'init' to 'set'.
            public int Age { get; set; } = Age;

            // A property declared with standard syntax
            public string Job { get; init; } = "None";

            // Declare a method
            public string GetFullName() =&gt; $"{FirstName} {LastName}";
        }

        class Program
        {
            static void Main(string[] args)
            {
                // person is created using the prime constructor.
                Person person = new("Harry", "Johnson", 1, 24);

                // person1 has same values as person so is equal.
                Person person1 = new("Harry", "Johnson", 1,  24);
                Console.WriteLine($"person1 == person = {person1 == person}");

                // person2 has different values as person so is not equal.
                Person person2 = new("Mary", "Johnson", 2, 32);
                Console.WriteLine($"person2 == person = {person2 == person}");

                // person3 is a copied from person2 using nondestructive
                // mutation. FirstName and ID are changed in person3.
                Person person3 = person2 with { FirstName = "Betty", ID = 3 };
                Console.WriteLine($"person3 == person2 = {person3 == person2}");

                // person4 is created using a combination of the
                // prime constructor and an object initializer.
                Person person4 = new("Andrew", "Adams", 4, 32) { Job = "Developer" };

                // person5 is created using the overloaded constructor
                // person5 has same values as person4 so is equal.
                Person person5 = new("Andrew", "Adams", 4, 32, "Developer");
                Console.WriteLine($"person4 == person5 = {person4 == person5}");

                // The Age property was made mutable
                person5.Age = 48;

                // Deconstruction makes available for use properties
                // set through positional parameters only.
                var (firstName, lastName, id, age) = person3;
                Console.WriteLine($"Name: {firstName} {lastName} Age: {age} ID: {id} Job: {person3.Job}");

                // An alternate syntax for deconstruction
                person5.Deconstruct(out firstName, out lastName, out id, out age);
                Console.WriteLine($"Name: {firstName} {lastName} Age: {age} ID: {id} Job: {person5.Job}");

                // The 'ToString' method returns the type and
                // all properties other than internal ID
                Console.WriteLine(person5.ToString());
            }
        }
    }

    // The example writes the following to the console
    // person1 == person = True
    // person2 == person = False
    // person3 == person2 = False
    // person4 == person5 = True
    // Name: Betty Johnson Age: 32 ID: 3 Job: None
    // Name: Andrew Adams Age: 48 ID: 4 Job: Developer
    // Person { FirstName = Andrew, LastName = Adams, Age = 48, Job = Developer }
</code></pre>
                    <!-- !SECTION record -->
                    <!-- SECTION delegate -->
                    <h3 id="delegate">delegate</h3>
                    <p>A delegate allows you to create a reference to a method that can then be passed as a parameter. It does this by declaring the
                        <a href="#Parameters,_signatures_and_overloading">signature</a> of the method which in this case includes the return type. It is declared using an
                        optional <a href="#Access_modifiers">access modifier</a>, followed by the <code>delegate</code> keyword, then the <i>return type</i>, then an
                        identifier that is unique within the <a href="#Dependencies_and_Namespaces">namespace</a>, followed by a pair of round brackets that can
                        optionally contain <a href="#Parameters,_signatures_and_overloading">parameters.</a> Delegates are created using the delegate's identifier,
                        followed by an identifier unique within the local scope and then assigning it a named method which can be either an instance or static. This can
                        then be used to invoke the method as if it was called directly. The <code>delegate</code> keyword can also be used as an operator to create
                        <a href="#Anonymous_functions">anonymous methods</a> that don't require the declaration of a named method for assignment.</p>
                    <p>A common use for delegates is in <a href="#Events">events</a> in which a method known as an <i>event handler</i> is invoked by a special kind of
                        multicast delegate that is declared by the event.</p>
                    <p>The following example demonstrates delegate declaration and use.</p>
<pre><code>namespace Delegates
{
    // A 'delegate' declares the method signature including return type
    // Delegate 'Calculate' takes in two int's and returns an int
    public delegate int Calculate(int value1, int value2);

    public class MathFunctions
    {
        // A static method 'Add' with the same return type
        // and signature as the delegate Calculate is declared
        public static int Add(int x, int y)
        {
            return x + y;
        }

        // An instance method 'Multiply' with the same return type
        // and signature as the delegate Calculate is declared
        public int Multiply(int x, int y)
        {
            return x * y;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Create an instance of 'Calculate' that assigns Add
            Calculate add = MathFunctions.Add;

            // Create an instance of 'Calculate' that assigns Multiply
            // As Multiply is an instance method an instance of
            // MathFunctions is required to access it
            Calculate multiply = new MathFunctions().Multiply;

            // Using the add delegate to invoke Add
            Console.WriteLine($"2 + 3 = {add(2, 3)}");

            // Using the multiply delegate to invoke Multiply
            Console.WriteLine($"5 x 3 = {multiply(5, 3)}");
        }
    }
}

// The example writes the following to the console
// 2 + 3 = 5
// 5 x 3 = 15
</code></pre>
                    <!-- !SECTION delegate -->
<!-- TODO add inheriting interfaces and records -->
                    <!-- SECTION Inheriting types -->
                    <h3 id="Inheriting_types">Inheriting types</h3>
                    <p>Inheritance is one of the main concepts in Object Oriented Programming. It allows you to create a parent type with common features that multiple
                        different child types can inherit and expand upon. In C# a parent type is called a base type, a child a derived type and
                        <a href="#class">classes</a>, <a href="#record">records</a> and <a href="#interface">interfaces</a> can be inherited. C# only allows
                        single inheritance, that is a derived type can only inherit from one base type but it does allow for multiple generations which means a base
                        type can be inherited by a second which in turn can inherited by a third and so on. As a result, members that are in the base type will be
                        available in each generation of derived types with the following exceptions.</p>
                    <ul>
                        <li>Static constructors</li>
                        <li>Instance constructors</li>
                        <li>Finalizers</li>
                    </ul>
                    <p>Events can only be invoked from within the type they are declared so to <a href="#Raising_base_class_events_in_a_derived_class">raise a base type
                        event from a derived type</a> a common pattern is to declare a method in the base type that can be called from the derived type to invoke the
                        event. The availability of all other members in a derived type is dependent on the <a href="#Scope_and_Modifiers">accessibility</a> of a member in
                        the base type. Where members in both a base and derived type have the same identifier, where neither are marked as either virtual or override and
                        where the member in the base type has an accessibility modifier other than private, the derived member will hide the base member. The two members
                        don't have to be of the same type or have the same <a href="#Parameters,_signatures_and_overloading">signature.</a> For example, a property in a
                        base type can be hidden by a method. Access to a hidden member can still be obtained through use of the <a href="#base_keyword">base</a> keyword.
                        When a member is hidden the code editor will indicate this on the hiding member in the derived type with a <u class="warning">warning</u>. This
                        can be removed by marking the member with the <code>new</code> keyword. A class that is marked as <a href="#static">static</a> or
                        <a href="#sealed">sealed</a> can't be inherited.</p>
                    <p>The following example demonstrates the syntax for inheriting a class. First base class <code>A</code> is declared as normal. Derived Class
                        <code>B</code> is then declared followed by a colon, then the identifier of the class to be inherited, followed by the code block for
                        <span class="nowrap">class <code>B</code>.</span></p>
<pre><code>namespace InheritanceSyntax
{
    // Base class A is fist declared
    class A { }

    // Derived class B inherits class A
    class B : A { }
}
</code></pre>
                    <p>It is important to note that a derived class cannot be made more accessible than a base class. In this next example, base class <code>A</code>
                        does not have an accessibility keyword applied so it will be internal by default. When derived public class <code>B</code> then attempts to
                        inherit internal class <code>A</code> this results in a <a href="#Syntax_errors">syntax error.</a> Following this base public class <code>C</code>
                        is declared then derived class <code>D</code> inherits <span class="nowrap">class <code>C</code>.</span> Although <code>D</code> is internal by
                        default, this is allowed as <code>D</code> is less accessible <span class="nowrap">that <code>C</code>.</span> Then when public class
                        <code>E</code> inherits <code>D</code>, again there is an error as <code>E</code> is more accessible
                        <span class="nowrap">than <code>D</code>.</span></p>
                    <p>This illustrates that relying on the default accessibility for a class or interface can easily lead to unexpected errors so it is advisable to
                        always use the <code>internal</code> keyword if that is your intention. This is important as the default template provided by Visual Studio does
                        not provide an accessibility keyword so if you see an 'Inconsistent accessibility' error, check that the base class has been declared public.</p>
<pre><code>namespace InheritanceAccessibility
{
    // Base class A default accessibility is internal
    class A { }

    // Syntax error, derived public class B can't be
    // more accessible than its internal base class A
    //public class B : A { }

    public class C { }

    // This is OK as internal class D is less
    // accessible than public class C
    class D : C { }

    // Syntax error, derived public class E can't be
    // more accessible than its internal base class D
    // even though D inherits from public class C
    //public class E : D { }

    class Program
    {
        static void Main(string[] args) { }
    }
}
</code></pre>
                    <p>The following example creates a base class called <code>Animal</code> with a public property <code>Legs</code> that provides access to a private
                        field <span class="nowrap"><code>_Legs;</code>.</span> Both classes <code>Bird</code> and <code>Cat</code> inherit and extend the
                        <code>Animal</code> class with <code>Bird</code> adding the property <code>Wings</code> and <code>Cat</code> the property
                        <span class="nowrap"><code>Meowing</code>.</span> In the <code>Program</code>
                        class an instance of <code>Bird</code> is created setting values for both <code>Legs</code> and <code>Wings</code> and an instance of
                        <code>Cat</code> setting values for both <code>Legs</code> and <span class="nowrap"><code>Meowing</code>.</span> A message describing each is then
                        written to the console with their corresponding properties.</p>

<pre><code>namespace InheritanceExample
{
    // Declare a base class called 'Animal'
    public class Animal
    {
        public int Legs { get; set; }
    }

    // The derived class 'Bird' inherits 'Animal'
    // and adds the property 'Flying'
    public class Bird : Animal
    {
        public string Flying { get; set; } = "Fast";
    }

    // The derived class 'Cat' inherits 'Animal'
    // and adds the property 'Meowing'
    public class Cat : Animal
    {
        public string Meowing { get; set; } = "Quietly";
    }

    class Program
    {
        static void Main(string[] args)
        {
            // An instance of 'Bird' class is created
            Bird bird = new()
            {
                Legs = 2,
                Flying = "Slowly"
            };

            // An instance of 'Cat' class is created
            Cat cat = new()
            {
                Legs = 4,
                Meowing = "Loudly"
            };

            Console.WriteLine($"The bird has {bird.Legs} legs and is flying {bird.Flying}");
            Console.WriteLine($"The cat has {cat.Legs} legs and is meowing {cat.Meowing}");
        }
    }
}

// The example writes the following to the console
// The bird has 2 legs and is flying Slowly
// The cat has 4 legs and is meowing Loudly
</code></pre>
                    <!-- !SECTION Inheriting types -->
                    <!-- TODO change to refer to types and that only applicable to classes and records -->
                    <!-- TODO add code example description -->
                    <!-- SECTION Raising base class events in a derived class -->
                    <h3 id="Raising_base_class_events_in_a_derived_class">Raising base class events in a derived class</h3>
                    <p>An event can only be invoked within the class it is declared. A common pattern to invoke a base class event in a derived class is to declare a
                        virtual method in the base class to invoke the event. This can then be overridden in the derived class where it can be used to indirectly call the
                        base class event. This also allows for additional code to be added and executed within the method before or after the event is raised.</p>
                    <p>CodeExample</p>
<pre><code>namespace CallingBaseClassEvents
{
    public class BaseClass
    {
        // An event to raise when the program is closing.
        public event EventHandler ProgramClosing;

        // A method to call to invoke the ProgramClosing event.
        protected virtual void OnProgramClosing(EventArgs e)
        {
            // Raise the ProgramClosing event.
            ProgramClosing.Invoke(this, e);
        }
    }

    public class ProgramManager : BaseClass
    {
        protected override void OnProgramClosing(EventArgs e)
        {
            // Do any program closing processing here.

            // Call the OnProgramClosing method in the base class.
            base.OnProgramClosing(e);

            // Do any program closed processing here.
        }

        // The method to call to close the program.
        public void CloseProgram()
        {
            OnProgramClosing(EventArgs.Empty);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ProgramManager programManager = new();

            // Subscribe to the ProgramManager.ProgramClosing event and
            // declare an event handler using a lambda expression.
            programManager.ProgramClosing += (s, e) =&gt;
            {
                Console.WriteLine("The program is exiting");
            };

            Console.WriteLine("Press return to exit the program");

            // Wait until the user presses the 'enter' key.
            while (Console.ReadKey(true).Key != ConsoleKey.Enter) { }

            programManager.CloseProgram();

            Console.WriteLine("The program has exited");
        }
    }
}

// The example writes the following to the console
// Press return to exit the program
// The program is exiting
// The program has exited
</code></pre>
                    <!-- !SECTION Raising base class events in a derived class -->
                    <!-- SECTION Polymorphism implementation -->
                    <h3 id="Polymorphism_implementation">Polymorphism implementation</h3>
                    <p>In the previous example each derived class was created and the methods called separately. Ideally it would have been better to do this all through
                        a loop. This can be done as <a href="#Polymorphism">polymorphism</a> allows you to substitute a parent for a child then when the parent's method
                        is called at runtime it will be substituted for the child's.</p>

                    <p>In this example a base class <code>LogAnalyzer</code> is declared that has a virtual <code>DisplayMessage</code> method. Derived class
                        <code>LogAnalyzer1</code> inherits from <code>LogAnalyzer</code> and <code>LogAnalyzer2</code> inherits from <code>LogAnalyzer1</code> with each
                        overriding <code>DisplayMessage</code> with its own implementation. In the <code>Program</code> class a list of type <code>LogAnalyzer</code> is
                        created that adds an instance of the base and the two derived classes. A foreach loop then loops through the list using a
                        <code>LogAnalyzer</code> type iterator calling the <code>DisplayMessage</code> method which at runtime is replaced by the overridden version of
                        each item.</p>
<pre><code>namespace Polymorphism
{
    public class LogAnalyzer
    {
        public virtual void DisplayMessage()
        {
            Console.WriteLine("Log message has occurred");
        }
    }

    public class LogAnalyzer1 : LogAnalyzer
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 1 has occurred");
        }
    }

    public class LogAnalyzer2 : LogAnalyzer1
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 2 has occurred");
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            List&lt;LogAnalyzer&gt; logAnalyzers = new()
            {
                new LogAnalyzer(),
                new LogAnalyzer1(),
                new LogAnalyzer2(),
            };

            foreach (LogAnalyzer logAnalyzer in logAnalyzers)
            {
                logAnalyzer.DisplayMessage();
            }
        }
    }
}

// The example writes the following to the console
// Log message has occurred
// Log message type 1 has occurred
// Log message type 2 has occurred
</code></pre>
                    <!-- !SECTION Polymorphism implementation -->

<!-- TODO Rewrite the following -->
<!-- TODO using base in override -->
                    <!-- SECTION base keyword -->
                    <h3 id="base_keyword">base keyword</h3>
                    <p>Although constructors cannot be inherited those in the base class are still called after the derived constructor is called but before the enclosed
                        code of the derived class constructor is executed. Additionally, the <code>base</code> keyword can be used in a derived class to call constructors
                        and overridden instance members within the base class. Only those in the immediate base class in the derived class declaration can be accessed.
                        Lastly if a base class is provided with one or more parameterized constructors, then the compiler forgoes providing the default parameterless
                        constructor. As a result, when inheriting such a class you will then need to provide the derived class with at least one constructor with the same
                        signature as one of the constructors in the base class. The constructor in the derived class must call the constructor in the base class by using
                        the <code>base</code> keyword and pass the arguments provided to it on to the base class constructor.</p>
                    <p>In this example <code>BaseClass</code> has a parameterless constructor that writes to the console when it is called, then sets a value in a field
                        called <span class="nowrap"><code>_Field</code>.</span> It also has a parameterized constructor that takes a value which it uses to set
                        <code>_Field</code> and a virtual method <code>GetFieldValue</code> that returns the value of
                        <span class="nowrap"><code>_Field</code>.</span> <code>DerivedClass</code> inherits from <span class="nowrap"><code>BaseClass</code>.</span> It
                        too has a parameterless constructor that writes to the console when it is called, then sets a value in its own field called
                        <span class="nowrap"><code>_Field</code>.</span> It also has a parameterized constructor which first calls its counterpart in the base class
                        through use of the <code>base</code> keyword which requires passing all arguments it receives to the base class. The derived class also overrides
                        <code>GetFieldValue</code> returning its own <code>_Field</code> value and has a method called <code>CallBaseMethod</code> which, using the
                        <code>base</code> keyword, calls <code>GetFieldValue</code> in the base class.</p>
                    <p>In the <code>Program</code> class an instance of <code>DerivedClass</code> is created using the parameterless constructor which results in first
                        the base class then the derived class constructor being called. Then the return value of <code>GetFieldValue</code> followed by
                        <code>CallBaseMethod</code> are written to the console. Next a second instance of <code>DerivedClass</code> is created using the parameterized
                        constructor with the string 'instance 2' passed in and again the return value of <code>GetFieldValue</code> followed by
                        <code>CallBaseMethod</code> are written to the console.</p>
                    <p>The example also declares a class <code>BaseClass2</code> which contains a parameterized constructor. Deriving the class
                        <code>DerivedClass2</code> from <code>BaseClass2</code> without providing a parameterized constructor with the same signature as that of the base
                        class results in a <a href="#Syntax_errors">syntax error.</a></p>

<pre><code>namespace BaseKeyword
{
    public class BaseClass
    {
        private string _Field;

        public BaseClass()
        {
            Console.WriteLine("Base class constructor");
            _Field = "Base class";
        }

        public BaseClass(string value)
        {
            _Field = "Base Class " + value;
        }

        public virtual string GetFieldValue()
        {
            return _Field;
        }
    }

    public class DerivedClass : BaseClass
    {
        private string _Field;

        public DerivedClass()
        {
            Console.WriteLine("Derived class constructor");
            _Field = "Derived class";
        }

        public DerivedClass(string value) : base(value)
        {
            _Field = "Derived Class " + value;
        }

        public override string GetFieldValue()
        {
            return _Field;
        }

        public string CallBaseMethod()
        {
            return base.GetFieldValue();
        }
    }

    public class BaseClass2
    {
        public BaseClass2(int value) { }
    }

    // Uncommenting the following results in the error
    // There is no argument given that corresponds to the
    // required formal parameter 'value' of 'BaseClass2.BaseClass2(int)'
    //public class DerivedClass2 : BaseClass2 { }

    class Program
    {
        static void Main(string[] args)
        {
            DerivedClass instance1 = new();
            Console.WriteLine();
            Console.WriteLine(instance1.GetFieldValue());
            Console.WriteLine(instance1.CallBaseMethod());

            Console.WriteLine();
            DerivedClass instance2 = new("instance 2");
            Console.WriteLine(instance2.GetFieldValue());
            Console.WriteLine(instance2.CallBaseMethod());
        }
    }
}

// The example writes the following to the console
// Base class constructor
// Derived class constructor

// Derived class
// Base class

// Derived Class instance 2
// Base Class instance 2
// Abstract event called
</code></pre>
                    <!-- !SECTION base keyword -->

                    <!-- SECTION Overriding object members -->
                    <h3 id="Overriding_object_members">Overriding object members</h3>
                    <p>All classes in C#, even the ones you write, are ultimately derived from the <i>object</i> class. This means that even if you don't explicitly use
                        the syntax to inherit from <code>object</code> our class will still contain the following overridable members</p>
                    <ul>
                        <li>Equals(Object)</li>
                        <li>Finalize()</li>
                        <li>GetHashCode()</li>
                        <li>ToString()</li>
                    </ul>
                    <p>the following non-overridable members</p>
                    <ul>
                        <li>GetType()</li>
                        <li>MemberwiseClone()</li>
                    </ul>
                    <p>and the following static members</p>
                    <ul>
                        <li>Equals(Object, Object)</li>
                        <li>ReferenceEquals(Object, Object)</li>
                    </ul>
                    <p>The default implementation of <code>ToString()</code> is to return the result of <code>GetType()</code> which is the fully qualified type name. As
                        a result it is not uncommon to override <code>ToString()</code> with something more meaningful. In the following example the
                        <code>ToString()</code> <a href="#Methods">method</a> is overridden to return the combined <code>FirstName</code> and <code>LastName</code>
                        properties values as the full name which is then written to the console.</p>
<pre><code>namespace OverridingObjectMembers
{
    public class Person
    {
        public string? FirstName { get; set; }

        public string? LastName { get; set; }

        public override string ToString()
        {
            return FirstName + " " + LastName;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Person person = new()
            {
                FirstName = "Denise",
                LastName = "Jones"
            };

            Console.WriteLine($"This person is {person.ToString()}");

            // As the default method for a type derived from a
            // System.Object is ToString it can be omitted in this case
            Console.WriteLine($"This person is {person}");
        }
    }
}

// The example writes the following to the console
// This person is Denise Jones
// This person is Denise Jones
</code></pre>
                    <!-- !SECTION Overriding object members -->
                    <!-- SECTION interface -->
                    <h3 id="interface">interface</h3>
                    <p>"An interface is a contract" has to be one of the worst explanations as to what an interface is, yet it still persists throughout much of the
                        literature you may find on line, including that of Microsoft's own C# reference. So, what is an interface.</p>
                    <p>Take a computer manufacturer. They can't anticipate every printer, keyboard, mouse, etc, that will be plugged into their devices. To allow for
                        this, the industry as a whole has created a set of specifications of which various devices must adhere to, so that they are compatible. For a
                        keyboard this may be the signals it must produce when a key is pressed, but it is not the computer manufacturer's job to tell the keyboard
                        manufacturer how to make their keyboards. Providing that the specifications are met the keyboard manufacturer is free to design it as they like.
                        An interface works on a similar basis by declaring which members a class or struct will have without saying how they are to be implemented.</p>
                    <p>An interface is created using the <code>interface</code> keyword. The following signature only members can be declared within an interface.</p>
                    <ul>
                        <li><a href="#Methods">Methods</a></li>
                        <li><a href="#Properties">Properties</a></li>
                        <li><a href="#Indexers">Indexers</a></li>
                        <li><a href="#Events">Events</a></li>
                    </ul>
                    <p>Members that are not implemented are public by default and access modifiers cannot be applied to them. Additionally, interfaces can contain members
                        that are implemented which is called default implementation. These are</p>
                    <ul>
                        <li><a href="#Constant_fields">Constant fields</a></li>
                        <li>Operators</li>
                        <li><a href="#Constructors">Static constructors</a></li>
                        <li>Nested types</li>
                        <li><a href="#Fields">Static fields</a></li>
                        <li><a href="#Methods">Static methods</a></li>
                        <li><a href="#Properties">Static properties</a></li>
                        <li><a href="#Indexers">Static indexers</a></li>
                        <li><a href="#Events">Static events</a></li>
                        <li>Member declarations using explicit interface implementation syntax</li>
                        <li>Explicit access modifiers</li>
                    </ul>
                    <p>An interface cannot contain an instance field or instance auto-property as an interface cannot have an instance state.</p>
                    <p><em>Note:</em> <i>whilst the declaration of a property in an interface is written with the same syntax as an instance
                        <span class="nowrap">auto-property,</span> it differs in that the compiler does not create an instance backing field.</i></p>
                    <p>Whereas a class can only inherit a single base class it can implement multiple interfaces. This is done in the same manner, i.e., the class
                        identifier is followed by a colon then the identifiers of all interfaces in a comma separated list. If a class also inherits a base class its
                        identifier must come first in the list. A class can also explicitly implement a member of an interface. An interface can be derived from or be the
                        base for by another interface. Implemented members in an interface can be overridden. When this is done explicit interface implementation syntax
                        must be used. Explicitly implemented members and default implemented members in an interface can only be accessed through an instance of the
                        interface.</p>
                    <p>Whilst on the surface an interface may seem to provide much of the same function as an abstract class, the important distinction is that a class
                        can contain a state and so can represent a thing where as an interface cannot and is used to represent a behavior.</p>
                    <p>In the following example the <code>Car</code> class inherits the base class <code>Vehicle</code> and overrides the <code>ApplyBrakes</code>
                        method. The <code>Dog</code> class has a method <span class="nowrap"><code>Speak</code>.</span> Whilst both are quite different objects both are
                        able to move and make a sound and so implement the <code>IMotion</code> and <code>ISound</code> interfaces which respectively include the
                        <code>Move</code> method and <code>Sound</code> property. As can be seen whilst the base class <code>Vehicle</code> must come first in the
                        declaration list, the order of the interface declaration is does not matter.</p>
<pre><code>namespace Interface
{
    // Declare interface IMotion
    public interface IMotion
    {
        void Move();
    }

    // Declare interface ISound
    public interface ISound
    {
        string Sound { get; set; }
    }

    // Declare abstract class Vehicle
    public abstract class Vehicle
    {
        public abstract void ApplyBrakes();
    }

    // Declare Car class that inherits Vehicle
    // and implements ISound and IMotion
    public class Car : Vehicle, ISound, IMotion
    {
        public string Sound { get; set; } = string.Empty;

        public void Move()
        {
            Console.WriteLine("Car accelerates");
        }

        public override void ApplyBrakes()
        {
            Console.WriteLine(Sound);
            Console.WriteLine("Car slows");
        }
    }

    // Declare Dog class that implements ISound and IMotion
    public class Dog : IMotion, ISound
    {
        public string Sound { get; set; } = string.Empty;

        public void Move()
        {
            Console.WriteLine("Dog chases car");
        }

        public void Speak()
        {
            Console.WriteLine(Sound);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Create an instance of Car
            Car car = new();
            car.Sound = "Brakes squeal";

            // Create an instance of Dog
            Dog dog = new();
            dog.Sound = "Dog barks";

            car.Move();
            dog.Move();
            car.ApplyBrakes();
            dog.Speak();
        }
    }
}

// The example writes the following to the console
// Car accelerates
// Dog chases car
// Brakes squeal
// Car slows
// Dog barks
</code></pre>
                    <!-- !SECTION interface -->
                </article>
            </section>
            <!-- !SECTION Classes and Other User Defined Types -->
            <!-- SECTION Anonymous functions -->
            <section class="main-section" id="Anonymous_functions">
                <header><h2>Anonymous functions</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>An anonymous function allows you to create a <a href="#delegate">delegate</a> and assign it a method in one line of code(<i>in-line</i>), without
                        the need for a separate named method. They can be declared with one of two basic syntaxes, <a href="#Anonymous_methods">anonymous methods</a> and
                        <a href="#Lambda_expressions">lambda expressions</a> with the latter replacing the former. C# also provides two types of built-in delegates,
                        <a href="#Action_and_Func">Action</a> and  <a href="#Action_and_Func">Func</a>, that allow the in-line declaration of an anonymous function
                        without the need for the separate declaration of a delegate or a named method. </p>
                    <!-- SECTION Anonymous methods -->
                    <h3 id="Anonymous_methods">Anonymous methods</h3>
                    <p>Whilst anonymous methods have largely been replaced by lambda expressions, they remain in the C# language for backwards compatibility so are
                        presented here for reference. As with a <a href="#delegate">named method</a> a delegate is first declared with the required return type and
                        <a href="#Parameters,_signatures_and_overloading">signature.</a> The delegate instance is then declared and assigned an anonymous method by using
                        the <code>delegate</code> keyword, followed by the same signature as the delegate, followed by a code block.</p>
                    <p>The following example demonstrates anonymous method declaration and use.</p>
<pre><code>namespace AnonymousMethods
{
    // Delegate 'Calculate' takes in two int's and returns an int
    public delegate int Calculate(int value1, int value2);

    class Program
    {
        static void Main(string[] args)
        {
            // The delegate keyword is used as an operator to assign
            // a method signature matching the delegate declaration
            // The return type is inferred from the return statement
            Calculate add = delegate (int x, int y) { return x + y; };

            // Using the add delegate
            Console.WriteLine($"2 + 3 = {add(2, 3)}");
        }
    }
}

// The example writes the following to the console
// 2 + 3 = 5
</code></pre>
                    <!-- !SECTION Anonymous methods -->
                    <!-- SECTION Lambda expressions -->
                    <h3 id="Lambda_expressions">Lambda expressions</h3>
                    <p>Lambda expressions allow for a more concise in-line syntax than anonymous methods. As with a <a href="#delegate">named method</a> a delegate is
                        first declared with the required <a href="#Parameters,_signatures_and_overloading">signature.</a> The delegate instance is then
                        declared and assigned an anonymous method by using a pair of round brackets containing the same signature as the delegate, followed by the lambda
                        operator <code>=&gt;</code>, followed by the lambda body. In most cases both the parameter types and the return type are inferred by the compiler.
                        This means that declaration of parameter types is usually not required but can be included if needed. In any case,
                        inclusion can assist with human readability of the code. Where only one parameter without a type declaration exists, the round brackets become
                        optional. The body can be in two forms, an <i>expression lambda</i> which can consist of an expression or a method call and a
                        <i>statement lambda</i> which consists of a statement block which can contain multiple statements.</p>
                    <p>The following example demonstrates various lambda expression declarations and use.</p>
<pre><code>namespace LambdaExpressions
{
    // 'CalculateTwoValues' takes in two int's and returns an int
    public delegate int CalculateTwoValues(int value1, int value2);

    // Delegate declares the method return type and signature
    // 'CalculateOneValue' takes an int and returns a string
    public delegate string CalculateOneValue(int value);

    // 'MethodCall' takes in a string and returns void
    public delegate void MethodCall(string value);

    class Program
    {
        static void Main(string[] args)
        {
            // Lambda expression. Return type is inferred based on the
            // parameter types and the expression in the body.
            // This form is an expression lambda.
            CalculateTwoValues add = (x, y) =&gt; x + y;

            // When needed, parameter types can also be explicitly declared
            CalculateTwoValues multiply = (int x, int y) =&gt; x * y;

            // With only one parameter brackets are not required.
            CalculateOneValue square = a =&gt; (a * a).ToString();

            // This is form is a statement lambda
            CalculateOneValue safeInvert = n =&gt;
            {
                if (n == 0)
                    return "Can't divide by zero";
                return $"1 / {n} = {1 / n}";
            };

            // A method call used as the lambda expression body
            MethodCall methodCall = a =&gt; Console.WriteLine(a);

            // Using the add delegate
            Console.WriteLine($"2 + 3 = {add(2, 3)}");

            //Using the multiply delegate
            Console.WriteLine($"5 x 3 = {multiply(5, 3)}");

            //Using the square delegate
            Console.WriteLine($"6 squared = {square(6)}");

            // Using the safeInvert delegate
            Console.WriteLine($"1 / 0 = {safeInvert(0)}");

            // Using the method call delegate
            methodCall("A method call was used as the expression body");
        }
    }
}

// The example writes the following to the console
// 2 + 3 = 5
// 5 x 3 = 15
// 6 squared = 36
// 1 / 0 = Can't divide by zero
// A method call was used as the expression body
</code></pre>
                    <!-- !SECTION Lambda expressions -->
                    <!-- SECTION Action and Func -->
                    <h3 id="Action_and_Func">Action and Func</h3>
                    <p>C# also has two built-in <a href="#delegate">delegates</a>, <code>Action</code> that returns <code>void</code> and <code>Func</code> that returns
                        a declared type. Both provide the in-line declaration of an anonymous function without the need for a separate declaration of a delegate or a
                        <a href="#delegate">named method.</a> An <code>Action</code> or <code>Func</code> can also be passed as a parameter to a method or another
                        <code>Action</code> or <span class="nowrap"><code>Func</code>.</span> The <code>Action </code> syntax is
                        <code>Action&lt;in T1, ... in T16t&gt;</code> and the <code>Func</code> syntax is
                        <span class="nowrap"><code>Func&lt;in T1, ... in T16, out TResult&gt;</code>.</span> Both provide
                        <a href="#Parameters,_signatures_and_overloading">overloads</a> for up to 16 input parameters of any type with <code>Func</code> allowing for one
                        return value of any type and both can be assigned a body in the form of either an <a href="#Anonymous_methods">anonymous method</a> or a
                        <a href="#Lambda_expressions">lambda expression.</a></p>
                    <p>The following example demonstrates both <code>Func</code> and <code>Action</code> declaration and use.</p>

<pre><code>namespace ActionsAndFuncs
{
    class Program
    {
        static void Main(string[] args)
        {
            // Func delegate 'calculateVolume' that takes in three int's
            // and returns an int from an expression lambda body.
            Func&lt;int, int&gt; getCubeVolume = x =&gt; x * x * x;

            // Action delegate 'printCircleArea' that takes
            // in one int and that has a statement lambda body
            Action&lt;int&gt; printCircleArea = r =&gt;
            {
                const double pi = 3.1415;
                var area = pi * r * r;
                Console.WriteLine($"Circle area with radius {r} = {area}");
            };

            // Using the calculateVolume delegate
            Console.WriteLine($"Cube volume with sides 4 = {getCubeVolume(4)}");

            // Using the printCircleArea delegate
            printCircleArea(4);
        }
    }
}

// The example prints the following to the console
// Cube volume with sides 4 = 64
// Circle area with radius 4 = 50.264
</code></pre>
                    <!-- !SECTION Action and Func -->
                </article>
            </section>
            <!-- !SECTION Anonymous functions -->
            <!-- SECTION Dependencies and Namespaces -->
            <section class="main-section" id="Dependencies_and_Namespaces">
                <header><h2>Dependencies and Namespaces</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION Dependencies -->
                    <h3 id="Dependencies">Dependencies</h3>
                    <p>A C# project may consist of multiple sources of code along with other resources such as media and text files which are then compiled to create an
                        <i>assembly</i>. This can be in the form of either an executable (.exe) or library (.dll) file and a program may consist of one or more of these.
                        When multiple assemblies are used, in order for one to be able to access the components of another it must have a reference to it. The reference
                        is a hierarchal such that if assembly A references assembly B then A can access B's components but not vice versa. If B was then to attempt to
                        reference A as well this would cause a circular reference error and would prevent either assembly from compiling. Accessibility of a
                        <a href="#Classes_and_Other_User_Defined_Types">type</a> or type's <a href="#Members">members</a> also depends on the program of
                        <a href="#Access_modifiers">access modifiers.</a></p>
                    <p>For most project types such as a Console, Windows Forms, WPF programs, etc, these will also include the <i>.NETCore framework</i> which is an
                        extensive library of code that our project will have access to through a reference automatically added by Visual Studio. Under each project in the
                        Solution Explorer is a <i>Dependencies</i> node which when expanded reveals a <i>Frameworks</i> node and under this <i>Microsoft.NETCore.App</i>
                        which is the <i>.NETCore framework</i>. Expanding this reveals many nodes, most of which represent a library (.dll) file prefixed with System.
                        These include types such as the runtime, file access, memory management, collections, etc available to you so that you don't have to create these
                        yourself. In addition to the .NETCore framework a project can have a reference to other projects within the solution and programs external to it.
                    </p>
                    <p>The following example demonstrates how to create a new project, add a second project to the solution of the first and then create a reference of
                        the second project to the first.</p>
                    <ol>
                        <li>Start the IDE then click <b>Create a new project</b></li>
                        <li> On the <span class="nowrap"><b>Create a new project</b></span> page in the search box at the top type
                            <span class="nowrap"><b>'console core'</b></span>.</li>
                        <li>A project template titled <span class="nowrap"><b>Console App</b></span> should appear at the top of the list. It has an icon that looks like
                            a document with C# in the top right corner. Select <span class="nowrap"><b>Console App</b></span> then choose <b>Next</b>
                            (Hint: if <span class="nowrap"><b>Console App</b></span> is not at the top, click <b>Clear all</b> and search again)</li>
                        <li>On the <span class="nowrap"><b>Configure your new project</b></span> page type <b>'ProjectA'</b> in the
                            <span class="nowrap"><b>Project name</b></span> box. Leave the <b>Location</b> and <span class="nowrap"><b>Solution name</b></span> as filled
                            in by the IDE and choose <b>Next</b></li>
                        <li>In the <span class="nowrap"><b>Additional information</b></span> page make sure <b>.NET5.0(Current)</b> is selected in the dropdown selector
                            then choose <b>Create</b></li>
                        <li>When the code editor has loaded right click the <b>Solution</b> node in the Solution Explorer then in the context menu hover the mouse over
                            <b>add</b> then in the new context menu that opens, click new project.</li>
                        <li>A project template called <b>ClassLibrary</b> : <i>A project for creating a class library that targets .NET Standard or .NET Core</i> should be
                            at the top of the list. If not, scroll down till you find the template then click on it to highlight it then click <b>Next</b></li>
                        <li>Repeat steps 4 and 5 using the project name <b>ProjectB</b></li>
                        <li>In <i>Solution Explorer</i> right click the <b>Dependencies</b> node under <b>ProjectA</b> and click <b>Add Project Reference</b> in the
                            context menu.</li>
                        <li>In the <b>Reference Manager - ProjectA</b> dialog box select the <b>Projects</b> node on the left pane.</li>
                        <li>In the middle section select <b>ProjectB</b> and mark its check box then click <b>OK</b> to add the reference</li>
                        <li>Under the <b>ProjectA</b> node in <b>Solution Explorer</b> expand the <b>Dependencies</b> node then the <b>Projects</b> node</li>
                        <li><b>ProjectB</b> should now be listed under this node confirming that <b>ProjectA</b> now has a reference to <b>ProjectB</b></li>
                    </ol>
                    <!-- !SECTION Dependencies -->
                    <!-- SECTION Namespaces -->
                    <h3 id="Namespaces">Namespaces</h3>
                    <p>C# requires that each type has a unique identifier. As the number of types increases naming conflicts become ever more probable, particularly when
                        external assemblies are referenced. Namespaces assist with this by compartmentally organizing types in a way that is similar to file system. For
                        example, in order to have two files on a drive called <i>MyFile.txt</i> you may put one in a folder called <i>MyFolder1</i> and the other in
                        <i>MyFolder2</i>. In a command window the two files are then referred to by <i>MyFolder1\MyFile.txt</i> and <i>MyFolder2\MyFile.txt</i>.
                        Namespaces are the same except that the backslashes (or forward slashes) are replaced with a dot. Like a file system, namespaces are hierarchical
                        and a sublevel namespace is known as a nested namespace.</p>
                    <p>A type is defined by its identifier and the namespace it is declared in. Two classes with identical identifiers and members
                        declared in different namespaces are treated as two different types, each identified by their <i>fully qualified</i> name in the form
                        <span class="nowrap"><code>MyNamespace.MyType</code>.</span> Accessing a type in another namespace requires use of its fully qualified name
                        whereas accessing a type in the same namespace only requires its identifier in the form <span class="nowrap"><code>MyType</code>.</span> Nested
                        namespaces are accessed by chaining the namespaces together in the form <span class="nowrap"><code>Namespace1.Namespace2.MyType</code>.</span>
                        Accessible <a href="#static">static</a> <a href="#Members">members</a>, <a href="#Constant_fields">constant fields</a> and nested types within a
                        type are accessed in a similar way in the form <span class="nowrap"><code>MyNamespace.MyType.Member</code>.</span> <i>IntelliSense</i> uses
                        namespaces to assist you by providing suggestions as you type. After typing the root namespace then <span class="nowrap">pressing <b>.</b></span>,
                        all the types and nested namespaces within it will appear in the suggestion box. If one of the nested namespaces is selected,
                        <span class="nowrap">the <b>.</b></span> can again be pressed to find all types and nested namespaces within it and the process can be repeated
                        until no nested namespaces remain. If a type is selected, pressing <span class="nowrap">the <b>.</b></span> will display type's accessible
                        members.</p>
                    <p>The <code>using</code> keyword allows types from another namespace to be <a href="#using_and_importing_types"><i>imported</i></a> into a local
                        namespace so that they can be accessed directly by their identifiers and can also be used to create namespace
                        <a href="#Aliases"><i>aliases</i></a> to avoid naming conflicts. The <code>static</code> modifier keyword can be applied to the <code>using</code>
                        directive to <a href="#Importing_static_members">import static members</a> and nested types. A type declared outside of any namespace is in the
                        <a href="#Global_namespace"><i>global</i></a> namespace. Types that are in the .NetCore library can be imported using the
                        <a href="#Importing_system_types">System namespace.</a></p>
                    <!-- !SECTION Namespaces -->
                    <!-- SECTION namespace -->
                    <h3 id="namespace">namespace</h3>
                    <p>The <code>namespace</code> keyword followed by a code block is used to declare that all <a href="#Classes_and_Other_User_Defined_Types">types</a>
                        enclosed within it belong to that <i>namespace</i> and can access each other through each type's identifier. Multiple declarations using the same
                        namespace can be made throughout the assembly and don't even have to be in the same file. Two types with the same identifier cannot be declared
                        within the same namespace even if they are declared in different files.</p>
                    <p>The following example demonstrates namespace declaration and usage.</p>
<pre><code>// All types declared in this namespace
// code block belong to NameSpace1
namespace NameSpace1
{
    enum Months { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Nov, Dec }

    // This Class1 is declared to belong to NameSpace1
    class Class1
    {
        public MyEnum Property { get; set; }

        public enum MyEnum { a, b, c }
    }

    interface ISomeInterFace
    {
        Months Month { get; set; }
    }
}

// All types declared in this namespace
// code block belong to NameSpace2
namespace NameSpace2
{
    // Despite having the same identifier and members by
    // being declared in NameSpace2 this is a different
    // type to the Months enum declared in NameSpace1
    enum Months { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Nov, Dec }

    // This Class1 is declared to belong to NameSpace2
    class Class1
    {
        public MyEnum Property { get; set; }

        public enum MyEnum { x, y, z }
    }
}

// All types declared in this namespace
// code block also belong to NameSpace1
namespace NameSpace1
{
    // ISomeInterFace and Class2 are both
    // in NameSpace1 so ISomeInterFace can be accessed
    // here directly by its identifier
    class Class2 : ISomeInterFace
    {
        public enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }

        public const double PI = 3.1415;

        public static double Area(double radius) =&gt; PI * radius * radius;

        // Implementation of ISomeInterFace member Property
        public Months Month { get; set; }

        private void Method()
        {
            // Months is in NameSpace1 so can be
            // accessed directly by its identifier
            Months month = Months.Jul;
        }

        public class Employer
        {
            // Months is in NameSpace1 so can be
            // accessed directly by its identifier
            // even within a nested type
            Months month = Months.Nov;
        }
    }

    // Syntax error, Class1 was already declared
    // in the previous NameSpace1 code block
    //class Class1 { }
}

// Declare an object in a sublevel namespace
namespace NameSpace1.DataModels
{
    class Person { }
}

// An alternate way to declare in a
// sublevel using a nested namespace
namespace NameSpace1
{
    namespace Animals
    {
        class Cat { }
    }
}

namespace NamespaceExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // The following access types using
            // their fully qualified names

            // NameSpace1 and NameSpace2 each have a
            // class called Class1 within which each
            // have their own unique members
            NameSpace1.Class1 class1 = new();
            NameSpace2.Class1 class2 = new();
            class1.Property = NameSpace1.Class1.MyEnum.a;
            class2.Property = NameSpace2.Class1.MyEnum.x;
            Console.WriteLine(class1.Property);
            Console.WriteLine(class2.Property);

            // Access the enum Months in NameSpace1
            NameSpace1.Months month = NameSpace1.Months.Apr;
            Console.WriteLine($"The month is {month}");

            // enums, constants, static members and nested
            // types can be accessed without an instance
            NameSpace1.Class2.Days day = NameSpace1.Class2.Days.Sun;
            var pi = NameSpace1.Class2.PI;
            var circleArea = NameSpace1.Class2.Area(5.1);
            NameSpace1.Class2.Employer employer = new();
            Console.WriteLine($"The day is {day}");
            Console.WriteLine($"PI = {pi}");
            Console.WriteLine($"The area of a circle with a radius of 5.1 is {circleArea}");

            // The 'Month' property of Class2 and Month
            // both belong to NameSpace2 even though
            // they are declared in separate code blocks
            NameSpace1.Class2 instance = new();
            instance.Month = NameSpace1.Months.May;
            Console.WriteLine(instance.Month);

            // Syntax error, being in different namespaces
            // NameSpace1.Month and NameSpace2.Month are different types
            // so this is attempting an implicit conversion which fails
            //instance.Month = NameSpace2.Months.May;

            // to access nested namespaces the identifiers
            // are chained using the '.'
            NameSpace1.DataModels.Person person = new();
            NameSpace1.Animals.Cat cat = new();
        }
    }
}

// The example writes the following to the console
// a
// x
// The month is Apr
// The day is Sun
// PI = 3.1415
// The area of a circle with a radius of 5.1 is 81.710415
// May
</code></pre>
                    <p>When adding a new class using the default class template, Visual Studio automatically puts it within a namespace based on the folder in the project
                        in which the class is added. If you want to use the root namespace instead and want to avoid editing the namespace, add the new class to the root
                        project then move the file to your desired folder. The following shows the code generated by adding a class called <i>MainViewModel</i> to a
                        folder called <i>ViewModels</i> in a project called <i>MyCompany</i>.</p>
<pre><code>namespace MyCompany.ViewModels
{
    class MainViewModel
    {
    }
}
</code></pre>
                    <!-- !SECTION namespace -->
                    <!-- SECTION Global namespace -->
                    <h3 id="Global_namespace">Global namespace</h3>
                    <p>The area outside any namespace declaration in a file is the <i>global namespace</i> and any type declared within it is accessible throughout the
                        assembly. Where two types have the same identifier, a type declared in a local namespace or type will hide a type declared in the global
                        namespace. In this case the global type can still be accessed by prefixing its identifier with the <code>global</code> keyword followed by the
                        <a href="#Namespace_alias_qualifier_operator"><i>namespace alias qualifier</i></a> <code>::</code> in the form
                        <span class="nowrap"><code>global::MyType</code>.</span></p>
                    <p>The following example demonstrates how to access a type in the global namespace.</p>
<pre><code>    // MyClass declared in the global namespace
    public class MyClass
    {
        public void WriteMessage()
        {
            Console.WriteLine("MyClass in global namespace");
        }
    }

    namespace NameSpace1
    {
        public class AnotherClass
        {
            public AnotherClass()
            {
                NestedClass = new();
            }

            // This refers to the global MyClass
            public MyClass NestedClass { get; private set; }
        }
    }

    namespace NameSpace2
    {
        // MyClass declared locally in NameSpace2
        public class MyClass
        {
            public void WriteMessage()
            {
                Console.WriteLine("MyClass in NameSpace2");
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                // The refers to NameSpace2.MyClass
                MyClass localMyClass = new();
                localMyClass.WriteMessage();

                // NameSpace2.MyClass hides the global
                // MyClass so to access it the identifier
                // is prefixed with the global keyword
                // followed by two colons
                global::MyClass globalMyClass = new();
                globalMyClass.WriteMessage();

                // AnotherClass.NestedClass refers to the
                // global MyClass
                NameSpace1.AnotherClass anotherClass = new();
                anotherClass.NestedClass.WriteMessage();
            }
        }
    }

    // The example writes the following to the console

    // MyClass in NameSpace2
    // MyClass in global namespace
    // MyClass in global namespace
</code></pre>
                    <!-- !SECTION Global namespace -->
                    <!-- SECTION using and importing types -->
                    <h3 id="using_and_importing_types">using and importing types</h3>
                    <p>The <code>using</code> keyword followed by a <a href="#namespace">namespace</a> identifier creates an import namespace directive. This imports all
                        types from the namespace which can be in any file in the containing assembly or others that the assembly references. Imported types can then
                        be accessed directly by their identifiers as if they were in the same namespace, which makes the code easier to read. Multiple namespaces can be
                        imported into a file but if two or more namespaces each contain a type with the same identifier, attempting to declare a variable of such a type
                        will result in an ambiguous reference error. In this case it will be necessary to use the fully qualified name for each type. A
                        <code>using</code> directive can be placed in either the <a href="#Global_namespace">global namespace</a> or within a namespace but must precede
                        all other code within it. A <code>using</code> directive that is placed in the <a href="#Global_namespace">global namespace</a> makes the types in
                        that namespace available in all other namespaces declared within the same file. A type in a nested namespace is not imported and if a
                        <code>using</code> directive to specifically target its namespace is not included, it will necessary to access its containing types using their
                        fully qualified names.</p>
                    <p>The <code>global</code> keyword can be applied to a using directive. This allows it to be placed in just a single file in an assembly yet allow its
                        types to be imported into all code files within the same assembly. A global using directive can only be placed in the global namespace and must
                        precede all non-global using directives.</p>
                    <p>If you know a type's identifier but don't know its namespace, Visual Studio provides a shortcut for adding this. After entering the type's
                        identifier, with the mouse hovering over it, press <b><kbd>Ctrl</kbd> + <kbd>.</kbd></b> and IntelliSense will suggest the correct using
                        directive, most likely at the top of the list. Click on the suggestion and it will be added to the code. Please note that the full identifier must
                        be entered with the correct case and the project must have a <a href="#Dependencies">reference</a> to the project containing the type.</p>
                    <p>To remove unused <i>using</i> directives, right click anywhere in the code editor and click <b>Remove and Sort Usings</b></p>
                    <p>The following example demonstrate importing types with the <code>using</code> directive.</p>
<pre><code>// Class5.cs
namespace NameSpace5
{
    public class Class5 { }
}

// -------------------------------------------------

// Program.cs

// This imports all types from the System namespace
// See Importing system types for details
using System;

// This imports all types within NameSpace1
// into all namespaces declared in this file
using NameSpace1;

// This imports all types within
// NameSpace5 in the Class5 file, into
// all namespaces declared in this file
using NameSpace5;

// GlobalClass is declared in the global namespace
class GlobalClass { }

// Syntax error, a using clause must precede all other
// elements defined in the namespace except alias declarations
//using NameSpace4;

// Class1 is declared in NameSpace1
namespace NameSpace1
{
    public class Class1 { }
}

// Class2 is declared in NameSpace2
namespace NameSpace2
{
    using NameSpace1;

    public class Class2 { }

    // Class3 is declared in NameSpace3
    // which is nested in NameSpace2
    namespace NameSpace3
    {
        public class Class3 { }
    }
}

// Class4 is declared in NameSpace4
namespace NameSpace4
{
    public class Class4
    {
        // Class1 can be accessed
        // directly using its identifier
        Class1 class1 = new();

        // Class2 must be accessed using
        // its fully qualified name
        NameSpace2.Class2 class2 = new();
    }
}

namespace ImportingTypes
{
    // This allows types within NameSpace2
    // to be imported into this namespaces only
    using NameSpace2;

    class Program
    {
        static void Main(string[] args)
        {
            // Class1 and Class2 can each be
            // accessed directly using their identifiers
            Class1 class1 = new();
            Class2 class2 = new();

            // Syntax error, types in nested namespaces are not imported
            //Class3 myClass3 = new();

            // Class3 must be accessed using
            // its fully qualified name
            NameSpace2.NameSpace3.Class3 class3 = new();

            // Class4 must be accessed using
            // its fully qualified name
            NameSpace4.Class4 class4 = new();

            // Class5 which is declared within
            // NameSpace5 in the Class5 file can be
            // accessed directly using its identifier
            Class5 class5 = new();

            // GlobalClass can be accessed
            // directly using its identifier
            GlobalClass globalClass = new();

            Console.WriteLine($"class1 type is {class1.GetType()}");
            Console.WriteLine($"class2 type is {class2.GetType()}");
            Console.WriteLine($"class3 type is {class3.GetType()}");
            Console.WriteLine($"class4 type is {class4.GetType()}");
            Console.WriteLine($"class5 type is {class5.GetType()}");
            Console.WriteLine($"globalClass type is {globalClass.GetType()}");
        }
    }
}

// The example writes the following to the console
// class1 type is NameSpace1.Class1
// class2 type is NameSpace2.Class2
// class3 type is NameSpace2.NameSpace3.Class3
// class4 type is NameSpace4.Class4
// class5 type is NameSpace5.Class5
// globalClass type is GlobalClass
</code></pre>
                    <!-- !SECTION using and importing types -->
                    <!-- SECTION Importing static members -->
                    <h3 id="Importing_static_members">Importing static members</h3>
                    <p>Accessible static members and nested types can be imported by applying the <code>static</code> modifier to the <code>using</code> directive. This
                        allows the static members to be accessed directly without the need for the type's identifier. Instance members that are also in the type will
                        still require an instance to be created to access them and inherited members are not imported.</p>
                    <p>The following example demonstrates importing and using static members.</p>
<pre><code>namespace NameSpace1
{
    public class MathClass
    {
        public const double PI = 3.1415;

        public static double CircleArea(double r) =&gt; PI * r * r;

        public double CubeVolume(double x) =&gt; x * x * x;
    }
}

namespace ImportingStaticMembers
{
    // Import the types in NameSpace1
    using NameSpace1;

    // Import the constant fields and static members
    // in NameSpace1.MathClass
    using static NameSpace1.MathClass;

    class Program
    {
        static void Main(string[] args)
        {
            // This uses the static members in NameSpace1.MathClass
            // without needing the namespace or the class identifier
            Console.WriteLine($"PI = {PI}");
            double area = CircleArea(5.1);
            Console.WriteLine($"Area of a circle with radius 5.1 = {area}");

            // To use the instance members in  NameSpace1.MathClass
            // an instance of the class is still required
            MathClass mathClass = new();
            double volume = mathClass.CubeVolume(3.3);
            Console.WriteLine($"Volume of a cube sides 3.3 = {volume}");
        }
    }
}

// The example writes the following the console
// PI = 3.1415
// Area of a circle with radius 5.1 = 81.710415
// Volume of a cube sides 3.3 = 35.937
</code></pre>
                    <!-- !SECTION Importing static members -->
                    <!-- SECTION Aliases -->
                    <h3 id="Aliases">Aliases</h3>
                    <p>Aliases provide a way of resolve naming conflicts which can be of particularly use when importing types from referenced assemblies. They can also
                        result in a much shorter name to use. This is of particular use where access to the type is through many namespace levels. The
                        <code>using</code> keyword is used to create the alias for a namespace or a type.</p>
                    <p>The following example demonstrates creating and using aliases.</p>
<pre><code>namespace NameSpace1
{
    // This MyClass is declared to belong to NameSpace1
    public class MyClass { }
}

namespace NameSpace2
{
    // This MyClass is declared to belong to NameSpace2
    public class MyClass { }
}

// A namespace with many levels
namespace Level1
{
    namespace Level2
    {
        namespace Level3
        {
            namespace Level4
            {
                namespace Level5
                {
                    public class NestedClass { }
                }
            }
        }
    }
}

namespace Aliases
{
    // Import MyClass from both
    // NameSpace1 and NameSpace2
    using NameSpace1;
    using NameSpace2;

    // An alias is created for each MyClass
    // in both NameSpace1 and NameSpace2
    using MyClass1 = NameSpace1.MyClass;
    using MyClass2 = NameSpace2.MyClass;

    // An alias can also be given to a namespace
    using ShortName = Level1.Level2.Level3.Level4.Level5;

    class Program
    {
        static void Main(string[] args)
        {
            // Syntax error, importing MyClass from both NameSpace1 and
            // NameSpace2 creates a naming conflict the compiler can't resolve.
            //MyClass myClass1 = new();

            // The aliases resolve the naming conflict
            // and results in a shorter name to use
            MyClass1 myClass1 = new();
            MyClass2 myClass2 = new();

            // The alias MyNameSpace is used to access SomeClass
            // Using the fully qualified name with many
            // nested namespaces gets quite cumbersome
            ShortName.NestedClass nestedClass = new();

            Console.WriteLine($"'myClass1' fully qualified name is '{myClass1.GetType()}'");
            Console.WriteLine($"'myClass2' fully qualified name is '{myClass2.GetType()}'");
            Console.WriteLine($"'nestedClass' fully qualified name is '{nestedClass.GetType()}'");
        }
    }
}

// The example writes the following to the console
// 'myClass1' fully qualified name is 'NameSpace1.MyClass'
// 'myClass2' fully qualified name is 'NameSpace2.MyClass'
// 'nestedClass' fully qualified name is 'Level1.Level2.Level3.Level4.Level5.NestedClass'
</code></pre>
                    <!-- !SECTION Aliases -->
                    <!-- SECTION Importing system types -->
                    <h3 id="Importing_system_types">Importing system types</h3>
                    <p>The <code>System</code> namespace and the namespaces nested within it, contain most of the C# built-in types that are part of the
                        .NetCore library. These include primitive value types such as <code>System.Int32</code> and reference types such as <code>System.String</code> and
                        access to these without a fully qualified name requires a <code>using System;</code> directive. Some of the C#
                        <a href="#Keywords">keywords</a> are special built-in <a href="#Aliases">aliases</a> for these types but unlike other aliases, don't require an
                        explicit <code>using</code> directive. For example, the <code>int</code> keyword can be used anywhere in code and is the alias for
                        <code>System.Int32</code>, both of which can be used interchangeably. Other system types such as <code>DateTime</code> which provides many tools
                        to access and manipulate dates and times and <code>Console</code> which has been used extensively throughout this guide, do require an explicit
                        <code>using System;</code> directive or use of their fully qualified names.</p>
                    <p>Nested within <code>System</code> are many other namespaces such as <code>System.Collections.Generic</code> that contains the
                        <a href="#List_T">List&lt;T&gt;</a> and <a href="#Dictionary_TKey_TValue">Dictionary&lt;TKey, TValue&gt;</a> types, <code>System.IO</code> that
                        contains types that allow you to access and manipulate files and <code>System.Threading</code> that provides tools for creating multi-threaded
                        programs. All the namespaces available in the .NetCore library can be viewed under the <a href="#Dependencies">dependencies</a> node in the
                        solution explorer and information about them and the types they contain can be found on the <a href="#References">Microsoft C# reference
                        documentation</a> website.</p>
                    <p>Starting with Visual Studio 2022 and .NET 6.0, an option called <i>Implicit global usings</i> is available in most of the project templates but not
                        all have this enabled by default when a new project is created. This adds a number of <a href="#using_and_importing_types">global using</a>
                        directives to import various namespaces appropriate to the type of project. These are automatically generated in a file not accessible by the code
                        editor, each time the project is built. This is important as there is currently no easy way to see which using directives are added and this can
                        result in an ambiguous reference error. At the time of this writing the namespaces that are added to a <i>Console App</i> with
                        <i>Implicit global usings</i>
                        enabled are</p>
                    <ul>
                        <li>System</li>
                        <li>System.Collections.Generic</li>
                        <li>System.IO</li>
                        <li>System.Linq</li>
                        <li>System.Net.Http</li>
                        <li>System.Threading</li>
                        <li>System.Threading.Tasks</li>
                    </ul>
                    <p>The following example demonstrates importing and using various System types.</p>
<pre><code>namespace NameSpace1
{
    class MyClass
    {
        // int is a C# keyword which is a built-in alias
        // for the System.Int32 struct. C# keywords can be
        // accessed without the 'using System' directive
        int x = 1;

        // Without the 'using System' directive
        // the fully qualified name must be used
        // even though this is the same type as int
        System.Int32 y = 2;
    }
}

namespace ImportingSystemTypes
{
    using System;
    using System.Threading;

    class Program
    {
        static void Main(string[] args)
        {
            // DateTime is a struct in the System namespace.
            // DateTime.Now gets the current date and time
            DateTime startTime = DateTime.Now;

            // Thread is a class in the System.Threading namespace. Thread.Sleep
            // suspends the thread for the specified number of milliseconds
            Thread.Sleep(1000);

            // TimeSpan is a struct in the System namespace.
            // A TimeSpan is the difference between two DateTime's
            TimeSpan elapsedTime = DateTime.Now - startTime;

            // double is a C# keyword which is a built-in alias
            // for the System.Double struct
            double totalSeconds = elapsedTime.TotalSeconds;

            // Math is a class in the System namespace.
            // Math.Round is a static method that rounds
            // a value to the nearest integer.
            // string is a C# keyword which is a built-in
            // alias for the System.String class.
            string roundedSeconds = Math.Round(totalSeconds).ToString();

            // Console is a class in the System namespace.
            Console.WriteLine($"The program has been asleep for {roundedSeconds} second");
        }
    }
}

// The example writes the following to the console
// The program has been asleep for 1 second
</code></pre>
                    <!-- !SECTION Importing system types -->
                </article>
            </section>
            <!-- !SECTION Dependencies and Namespaces -->
            <!-- SECTION Scope and Modifiers -->
            <section class="main-section" id="Scope_and_Modifiers">
                <header><h2>Scope and Modifiers</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION Scope -->
                    <h3 id="Scope">Scope</h3>
                    <p>Scope is the accessibility of a variable from one part of the code to another. In C# scope is arranged like the layers of an onion. Variables in an
                        outer scope can be accessed from those within but not vice versa. In computer science this is known as encapsulation and inner scopes that are
                        contained within outer scopes are said to be nested.</p>
                    <p>A local <a href="#Variables,_Constants,_Types_and_Literals">variable</a> is a variable declared in a <a href="#Methods">method</a>,
                        <a href="#Properties">property accessor</a>, <a href="#Indexers">indexer accessor</a>, <a href="#Constructors">constructor</a>,
                        <a href="#Anonymous_functions">anonymous function</a> or operator or one of its nested code blocks. A nested code block includes those of
                        <a href="#if_else_statements">if</a>, <a href="#if_else_statements">else</a>, <a href="#switch_statement">switch</a>,
                        <a href="#while_statement">while</a>, <a href="#do_statement">do</a>, <a href="#for_statement">for</a>, <a href="#foreach_statement">foreach</a>,
                        <a href="#try-catch">try</a> and using statements. A <a href="#Parameters">parameter</a> passed into a method, constructor, indexer or operator
                        becomes a local variable within the member. The variable is only accessible after it has been declared and only within the same code block or a
                        nested code block. A local variable within the same block or a nested code block cannot be declared with the same identifier.</p>
                    <p>A local variable can have the same identifier as a member within a container (enclosing type). When this is done the member is hidden by the local
                        variable. To access a hidden member, the <code>this</code> name qualifier keyword must be used. For example if a class contains both a property
                        called <code>someName</code> and a method containing a local variable called <code>someName</code>, to access the property from within the method
                        you would use <span class="nowrap"><code>this.someName</code>.</span> To avoid possible confusion or naming conflicts you should avoid declaring
                        local variables with the same identifier as a member in the same enclosing type. A common convention is to name local variables with
                        <i>camelCase</i>, <code>int someName;</code> private fields with <i>camelCase</i> prefixed with an underscore, <code>int _someName;</code>,
                        private static fields with <i>camelCase</i> prefixed with an 's' followed by an underscore, <code>private static int s_someName</code> and all
                        other members with <i>PascalCase</i>, <span class="nowrap"><code>public int SomeName { get; set; }</code>.</span> Whichever convention you or the
                        team you work for chose, it is important that it be consistent throughout all the code you write.</p>
                    <p>Following are examples of scope.</p>
<pre><code>namespace Scope
{
    public class MyClass
    {
        private string _nl = Environment.NewLine;

        // Declare _field1 and field2 at the top of the class
        // Fields do not have to be initialized so _field1
        // has the default integer value 0
        private int _field1;
        // Note: field2 does not have an underscore
        // prefix for demonstrative purposes only
        private string field2 = "field2";

        public void Method1(int value)
        {
            // variable1 is declared and initialized within the
            // scope of Method1. All code following this within
            // Method1 will have access to it
            int variable1 = 1;

            // Syntax error, because 'value' was declared in the signature
            // of Method1 it is a local variable in the scope of Method1
            // so another variable called value can't be declared in it
            //int value = 0;

            Console.WriteLine($"Initial class level _field1 value = {_field1}");

            // Syntax error, can't use local variable before
            // it is declared, local variable field2 is declared
            // after this statement and hides class level field2
            //Console.WriteLine($"Initial field2 value = {field2}");

            // Declaring a local field2 variable hides the class level field2
            // Local field2 is an int whereas class level field2 is a string
            int field2 = 0;
            Console.WriteLine($"Initial local variable field2 value = {field2}");

            // To access the hidden class level field2 use the 'this' qualifier
            Console.WriteLine($"Class level field2 value = {this.field2}");

            Console.WriteLine($"{_nl}Display iterator 'i' from Loop 1");

            // Loop 1 declares a nested scope within the scope of Method1
            // A variable named 'i' has been declared as the iterator for Loop 1
            for (int i = 0; i &lt;= 5; i++)
            {
                Console.Write($"{i}, ");
                variable1 += i;
                int variable2 = i * 2;
                _field1 += variable2;
            }

            Console.WriteLine($"{_nl}Result of variable1 in Loop 1 = {variable1}");
            Console.WriteLine($"Result of _field1 in Loop 1 = {_field1}");

            variable1 = 0;
            _field1 = 0;

            Console.WriteLine($"{_nl}Display iterator 'i' from Loop 2");

            // Loop 2 also declares a nested scope within Method1 but is outside the scope of
            // loop 2 so a variable named 'i' can also be declared as an iterator for Loop 2
            for (int i = 0; i &lt;= 15; i += 3)
            {
                Console.Write($"{i}, ");
                variable1 += i;
                int variable2 = i * 4;

                // Although _field3 was declared within MyClass after Method1
                // as it is a Field the location of its declaration within
                // the class does not matter so it can be accessed here
                _field3 += variable2;

                // Syntax error, this nested loop is within the scope of loop 2 so it
                // can't declare the same iterator 'i' that was declared by loop 2.
                //for (int i = 0; i &lt; 10; i++) { }

                // Syntax error, variable3 is declared after loop 2 so can't be accessed in it
                //variable3 = 1;

                // Syntax error, loop 2's scope is nested in Method1's scope
                // so another local variable3 can't be declared here also
                //int variable3 = i;

                // Loop 3 creates a nested scope within Loop 2
                for (int j = 0; j &lt; 5; j++)
                {
                    // Loop 2 iterator i and variable2 can
                    // be accessed within the scope of Loop 2
                    int variable4 = j + i + variable2;
                    _field1 += variable4;
                }
            }

            Console.WriteLine($"{_nl}Result of variable1 in Loop 2 = {variable1}");
            Console.WriteLine($"Result of _field1 in Loop 2 = {_field1}");
            Console.WriteLine($"Result of _field3 in Loop 2 = {_field3}");
            Console.WriteLine($"local field2 = {field2}");
            Console.WriteLine($"class level field2 = {this.field2}");

            // Syntax error, 'variable2' and 'i' from Loop 1 and
            // Loop 2 and 'j' from Loop 3 are all out of scope
            //Console.WriteLine($"variable2 = {variable2}");
            //Console.WriteLine($"i = {i}");
            //Console.WriteLine($"j = {j}");

            int variable3 = 0;
        }

        // Although by convention fields are declared at
        // the top of a class they can be placed anywhere
        int _field3 = 20;

        // Syntax error, local variables within the scope of Method1
        // can't be accessed outside of it at the class level
        //variable1 = 0;
        //variable2 = 0;
        //variable3 = 0;
        //variable4 = 0;
        //i = 0;
        //j = 0;
        //value = 0;

        // Method2 declares the same local variables as Method1
        // There is no conflict as the variables within each
        // method are within their own local scope
        public void Method2(string value)
        {
            int variable1 = 0;
            int variable2 = 0;
            int variable3 = 0;
            int variable4 = 0;
            int i = 0;
            int j = 0;
            field2 = value;
            Console.WriteLine($"Method2 field2 = {field2}");
        }

        // Syntax error, _field1 was already declared
        // within the same scope at the top of MyClass
        //int _field1;
    }

    class Program
    {
        static void Main(string[] args)
        {
            MyClass myClass = new();
            myClass.Method1(10);
            myClass.Method2("New value");
        }
    }
}

// The example prints the following to the console
// Initial class level _field1 value = 0
// Initial local variable field2 value = 0
// Class level field2 value = field2

// Display iterator 'i' from Loop 1
// 0, 1, 2, 3, 4, 5,
// Result of variable1 in Loop 1 = 16
// Result of _field1 in Loop 1 = 30

// Display iterator 'i' from Loop 2
// 0, 3, 6, 9, 12, 15,
// Result of variable1 in Loop 2 = 45
// Result of _field1 in Loop 2 = 1185
// Result of _field3 in Loop 2 = 200
// local field2 = 0
// class level field2 = field2
// Method2 field2 = New value
</code></pre>
                    <!-- !SECTION Scope -->
                    <!-- SECTION Modifiers -->
                    <h3 id="Modifiers">Modifiers</h3>
                    <p>Modifiers are used to change the behavior of a types and members. Access modifiers are grouped into their own category.</p>
                    <p>Following is a list of the modifiers and which types and members they apply to</p>
                    <ul>
                        <li><a href="#abstract">abstract</a> - classes, records, methods, properties</li>
                        <li><a href="#async">async</a> - method, lambda expression, anonymous method, local functions</li>
                        <li><a href="#const">const</a> - fields, local variables</li>
                        <li><a href="#extern">extern</a> - methods, constructors, properties, events, indexers, finalizers, local functions</li>
                        <li><a href="#in">in</a> - parameters, generics</li>
                        <li><a href="#new">new</a> - methods, fields, properties, events, indexers, nested types</li>
                        <li><a href="#out">out</a> - parameters, generics </li>
                        <li><a href="#override">override</a> - methods, properties, events, indexers</li>
                        <li><a href="#partial">partial</a> - classes, structures, interfaces, methods</li>
                        <li><a href="#readonly">readonly</a> - fields</li>
                        <li><a href="#sealed">sealed</a> classes, records, methods, properties, events, indexers</li>
                        <li><a href="#static">static</a> - classes, methods, constructors, fields, properties, events, local functions</li>
                        <li><a href="#unsafe">unsafe</a> - class, struct, record, delegate, interface, method, constructor, field, property, indexer, event, operator,
                            finalizer, local functions</li>
                        <li><a href="#virtual">virtual</a> -  methods, properties, events, indexers</li>
                        <li><a href="#volatile">volatile</a> - fields</li>
                    </ul>
                    <p>In addition, accessibility to members from outside of a type or an assembly can be changed with the use of
                        <a href="#Access_modifiers">access modifiers.</a></p>
                    <p><i><em>Note:</em> the behavior of modifiers may change when combined and some modifiers are mutually exclusive as detailed in the relevant
                        sections </i></p>
                    <!-- !SECTION Modifiers -->
                    <!-- SECTION abstract -->
                    <h3 id="abstract">abstract</h3>
                    <p> An <i>abstract</i> class is used when it makes sense to declare a common base class but where the implementation is specific to each derived class.
                        A base class and its members can be declared abstract by marking them with the <code>abstract</code> keyword. It cannot be instantiated so to be
                        used, a derived class must be created that inherits it and overrides all abstract members it contains. Abstract classes can be inherited by
                        sealed, abstract and non-abstract classes and can inherit from an abstract or non-abstract base class that is not a sealed class. Abstract members
                        cannot declare an implementation and within a derived class are treated the same as a virtual member. Any class that contains an abstract member
                        must be marked with the <code>abstract</code> keyword. An abstract class can contain both abstract and non-abstract members.</p>
                    <p>In the following example an abstract class <code>PriceCalculator</code> is declared with an abstract method called
                        <span class="nowrap"><code>CalculateAmount</code>.</span> Two derived classes that inherit from <code>PriceCalculator</code> are declared. The
                        first <code>ItemsPriceCalculator</code> has two properties, <code>ItemPrice</code> and <code>Quantity</code> and overrides
                        <code>CalculateAmount</code> to return an amount by multiplying these two properties. The second class <code>HoursPriceCalculator</code> has three
                        properties, <code>StartTime</code>, <code>FinishTime</code> and <span class="nowrap"><code>HourlyRate</code>.</span> In this case the overridden
                        <code>CalculateAmount</code> first subtracts <code>StartTime</code> from <code>FinishTime</code> then multiplies thy result by
                        <code>HourlyRate</code> and then returns the amount. Lastly as can be seen, attempting to instantiate <code>PriceCalculator</code> results in a
                        <a href="#Syntax_errors">syntax error.</a></p>
<pre><code>using System.Globalization;

namespace Abstract
{
    public abstract class PriceCalculator
    {
        public abstract double CalculateAmount();
    }

    public class ItemsPriceCalculator : PriceCalculator
    {
        public double ItemPrice { get; set; }

        public int Quantity { get; set; }

        public override double CalculateAmount()
        {
            return ItemPrice * Quantity;
        }
    }

    public class HoursPriceCalculator : PriceCalculator
    {
        public DateTime StartTime { get; set; }

        public DateTime FinishTime { get; set; }

        public double HourlyRate { get; set; }

        public override double CalculateAmount()
        {
            var timeTaken = FinishTime - StartTime;
            return timeTaken.TotalHours * HourlyRate;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ItemsPriceCalculator itemsPriceCalculator = new();
            itemsPriceCalculator.Quantity = 6;
            itemsPriceCalculator.ItemPrice = 3.10;
            Console.WriteLine($"The price of the items is {itemsPriceCalculator.CalculateAmount().ToString("C", CultureInfo.CurrentCulture)}");

            HoursPriceCalculator hoursPriceCalculator = new();
            hoursPriceCalculator.StartTime = new DateTime(2021, 11, 4, 9, 0, 0);
            hoursPriceCalculator.FinishTime = new DateTime(2021, 11, 4, 17, 0, 0);
            hoursPriceCalculator.HourlyRate = 30;
            Console.WriteLine($"The price of the hours is {hoursPriceCalculator.CalculateAmount().ToString("C", CultureInfo.CurrentCulture)}");

            // Syntax error, can't create an instance of an abstract class
            //PriceCalculator priceCalculator = new();
        }
    }
}

// The example writes the following to the console
// The price of the items is $18.60
// The price of the hours is $240.00
</code></pre>
                    <!-- !SECTION abstract -->
                    <!-- SECTION async -->
                    <h3 id="async">async</h3>
                    <p>The <code>async</code> modifier is outside the scope of this guide. For more information, please see the
                        <a href="#References">Microsoft C# reference documentation</a></p>
                    <!-- !SECTION async -->
                    <!-- SECTION const -->
                    <h3 id="const">const</h3>
                    <p>A field or local <a href="#Variables,_Constants,_Types_and_Literals">variable</a> marked with the <code>const</code> keyword causes it to become a
                        constant which can only be initialized when declared and then can't be changed later. A field marked this way is called a
                        <a href="#Constant_fields">constant field.</a></p>
                    <!-- !SECTION const -->
                    <!-- SECTION extern -->
                    <h3 id="extern">extern</h3>
                    <p>The <code>extern</code> modifier allows a C# program to run code that is implemented in an external library. This could be one of the native code
                        libraries that contain many of the common functions used by the operating system and which may be in another programming language such as C or
                        C++. Similar to the <a href="#abstract">abstract</a> modifier, <code>extern</code> allows you to create the declaration only, which points to the
                        implementation in the external library. The <code>extern</code> modifier is often used with the <code>DllImport</code> attribute which in turn is
                        used to import the external library.</p>
                    <p>In the following example a <a href="#Access_modifiers">private</a> method called <code>MessageBox</code> is declared with the <code>extern</code>
                        modifier and <code>DllImport</code> attribute that imports the method implementation from the Windows <i>User32.dll</i> library. When the user
                        presses the <b>x</b> key, an overloaded <code>public</code> <code>MessageBox</code> method is called which in turn calls the
                        <code>private</code> <code>MessageBox</code> which then displays a message box asking the user if they want to end the program. The program
                        execution loops until the user clicks the <i>Yes</i> button.</p>
                    <p><i><em>Note:</em> due to the use of user32.dll, this example will only work with the Windows operating system.</i></p>
<pre><code>using System.Runtime.InteropServices;

namespace Extern
{
    class Program
    {
        static void Main(string[] args)
        {
            bool exit = false;
            // Loop until the user presses the 'y' in the message box
            while (!exit)
            {
                Console.Clear();
                Console.WriteLine("Press x to exit the program");
                // Wait until the user presses the 'x' key
                while (Console.ReadKey(true).Key != ConsoleKey.X) { }
                exit = MessageBox("Are you sure you want to exit the program?", "Exit program?");
            }
            Console.WriteLine("You have exited the program");
        }

        public static bool MessageBox(string message, string caption)
        {
            // Call the 'MessageBox' method with type set to 4 which displays
            // yes and no buttons. If the user clicks yes, the method returns 6.
            return MessageBox((IntPtr)0, message, caption, 4) == 6;
        }

        // Declare a 'MessageBox' method that is implemented
        // by the 'MessageBox' method in 'User32.dll'
        [DllImport("User32.dll", EntryPoint = "MessageBox", CharSet = CharSet.Unicode)]
        private static extern int MessageBox(IntPtr h, string message, string caption, int type);
    }
}
    </code></pre>
                    <!-- !SECTION extern -->
                    <!-- SECTION in -->
                    <h3 id="in">in</h3>
                    <p>When used with a parameter the <code>in</code> modifier keyword allows an argument to be passed by reference to a method but prevents it from being
                        modified, please see <a href="#Parameters,_signatures_and_overloading">Signatures parameters and overloading.</a> Use of the <code>in</code>
                        modifier with generics is outside the scope of this guide. For more information, please see the
                        <a href="#References">Microsoft C# reference documentation</a></p>
                    <!-- !SECTION in -->
                    <!-- SECTION new -->
                    <h3 id="new">new</h3>
                    <p>Where members in both a base and derived type have the same identifier under certain conditions the derived member may hide the base member
                        resulting in a warning from the compiler. Marking the member in the derived type with the <code>new</code> modifier keyword suppresses the warning,
                        please see <a href="#Inheriting_types">Inheriting types</a></p>
                    <!-- !SECTION new -->
                    <!-- SECTION out -->
                    <h3 id="out">out</h3>
                    <p>When used with a parameter the <code>out</code> modifier keyword allows an argument to be passed by reference back to the calling statement,
                        please see <a href="#Parameters,_signatures_and_overloading">Signatures parameters and overloading.</a> Use of the <code>out</code> modifier with
                        generics is outside the scope of this guide. For more information, please see the <a href="#References">Microsoft C# reference documentation</a>
                    </p>
                    <!-- !SECTION out -->
                    <!-- SECTION override -->
                    <h3 id="override">override</h3>
                    <p>The implementation of a <a href="#Methods">method</a>, <a href="#Properties">property</a>, <a href="#Indexers">indexer</a> or
                        <a href="#Events">event</a> that is marked with either the <a href="#virtual">virtual</a> or <code>override</code> keyword in a base
                        <a href="#class">class</a> or <a href="#record">record</a> can be overridden in a derived class or record respectively. To do so the member in the
                        derived type must be marked with the <code>override</code> keyword. Base members are not virtual by default and attempting to override a member
                        not marked as virtual results in an error.</p>
                    <p><em>Note:</em> <i>Microsoft has advised not to declare an event as <code>virtual</code> as the compiler does not handle these correctly. Instead, a
                        method should be created in the base type that <a href="#Events">invokes the event.</a> This method can then be called from the derived type to
                        raise the event.</i>
                    </p>
                    <p>In the following example a base class <code>LogAnalyzer</code> is created that has a method <code>AnalyzeLogMessage()</code> and a virtual method
                        <span class="nowrap"><code>DisplayMessage()</code>.</span> Derived class <code>LogAnalyzer1</code> inherits <code>LogAnalyzer</code> and overrides
                        the virtual method providing its own implementation. <code>LogAnalyzer2</code> inherits <code>LogAnalyzer1</code> and overrides the virtual method
                        that it had overridden. <code>LogAnalyzer3</code> also inherits <span class="nowrap"><code>LogAnalyzer</code>.</span> It does not override the
                        virtual method but it shows that attempting to override the non-virtual method results in a <a href="#Syntax_errors">syntax error.</a> When
                        <code>DisplayMessage()</code> is called from each of the derived class instances <code>LogAnalyzer1</code> and <code>LogAnalyzer2</code> each
                        display the message in their own overridden methods whereas <code>LogAnalyzer3</code> displays the message from the base class.</p>
<pre><code>namespace OverridingVirtualMembers
{
    public class LogAnalyzer
    {
        public void AnalyzeLogMessage()
        {
            Console.WriteLine("Analyzing log message");
        }

        public virtual void DisplayMessage()
        {
            Console.WriteLine("Log message has occurred");
        }
    }

    public class LogAnalyzer1 : LogAnalyzer
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 1 has occurred");
        }
    }

    public class LogAnalyzer2 : LogAnalyzer1
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 2 has occurred");
        }
    }

    public class LogAnalyzer3 : LogAnalyzer
    {
        // Syntax error, can't override a member that
        // is not marked virtual, abstract or override
        //public override void AnalyzeLogMessage() { }
    }

    class Program
    {
        static void Main(string[] args)
        {
            LogAnalyzer1 logAnalyzer1 = new();
            LogAnalyzer2 logAnalyzer2 = new();
            LogAnalyzer3 logAnalyzer3 = new();

            Console.WriteLine("Using logAnalyzer1");
            logAnalyzer1.AnalyzeLogMessage();
            logAnalyzer1.DisplayMessage();

            Console.WriteLine();
            Console.WriteLine("Using logAnalyzer2");
            logAnalyzer2.AnalyzeLogMessage();
            logAnalyzer2.DisplayMessage();

            Console.WriteLine();
            Console.WriteLine("Using logAnalyzer3");
            logAnalyzer3.AnalyzeLogMessage();
            logAnalyzer3.DisplayMessage();
        }
    }
}

// The example writes the following to the console
// Using logAnalyzer1
// Analyzing log message
// Log message type 1 has occurred

// Using logAnalyzer2
// Analyzing log message
// Log message type 2 has occurred

// Using logAnalyzer3
// Analyzing log message
// Log message has occurred
</code></pre>
                    <!-- !SECTION override -->
                    <!-- SECTION partial -->
                    <h3 id="partial">partial</h3>
                    <p>The <code>partial</code> keyword allows a class, struct or interface definition to be split across multiple code files. Often this is used to place
                        the boilerplate code of a class into one file and the rest in another.</p>
                    <p>Additionally, within a partial type, a method can also be marked as
                        <code>partial</code> in which case the declaration of the method is placed in one file and the implementation in another, provided that both the
                        declaration and the implementation both start with the <code>partial</code> keyword and both have the same
                        <a href="#Parameters,_signatures_and_overloading">signature.</a> A common use for a partial method is a class designer that automatically declares
                        methods that the developer can then decide whether or not to implement. A partial method's implementation is optional provided it does not have an
                        <a href="#Access_modifiers">access modifier</a>, it returns <code>void</code>, it does not have any <a href="#out">out</a> parameters and it does
                        not have the <a href="#extern">extern</a>, <a href="#new">new</a>, <a href="#override">override</a>, <a href="#sealed">sealed</a> or
                        <a href="#virtual">virtual</a> modifier.</p>
                    <p>The following example demonstrates a class called <code>MyClass</code> that is split across two files called <i>MyClass_Part_1.cs</i> which holds
                        the boilerplate code and <i>MyClass_Part_2.cs</i> which holds the business logic. The <code>Program</code> class is able to access the members
                        that are located in the separate files of the instance of <code>MyClass</code> called <code>myClass</code> as normal using
                        <span class="nowrap"><code>myClass.Member</code>.</span> It also has a method called <code>PartialMethod</code> which is declared in
                        <i>MyClass_Part_1.cs</i>, implemented in <i>MyClass_Part_2.cs</i> and which can be accessed in the <code>Program</code> class.</p>
<pre><code>// MyClass_Part_1.cs
// A file to hold the boiler plate code of MyClass

namespace PartialModifier
{
    public partial class MyClass
    {
        public string FirstName { get; set; }

        public string LastName { get; set; }

        public DateTime Modified { get; private set; }

        private void InitializeMyClass()
        {
            Modified = DateTime.Now;
        }

        public partial void PartialMethod(string value);
    }
}

// -----------------------------------------------------------------------

// MyClass_Part_2.cs
// A file to hold the business logic code for MyClass

namespace PartialModifier
{
    public partial class MyClass
    {
        public MyClass(string firstName, string lastName)
        {
            FirstName = firstName;
            LastName = lastName;
            InitializeMyClass();
        }

        public string GetFullName() =&gt; $"{FirstName} {LastName}";

        public partial void PartialMethod(string value)
        {
            Console.WriteLine(value);
        }
    }
}

// -----------------------------------------------------------------------

// Program.cs
// The main file of the program

namespace PartialModifier
{
    class Program
    {
        static void Main(string[] args)
        {
            MyClass myClass = new("John", "Smith");
            Console.WriteLine($"Name: {myClass.GetFullName()}");
            Console.WriteLine($"Last updated: {myClass.Modified:dd MMMM yyyy}");
            myClass.PartialMethod("The partial method was called");
        }
    }
}

// This example writes the following to the console
// Name: John Smith
// Last updated: 18 January 2022
// The partial method was called
</code></pre>
                    <!-- !SECTION partial -->
                    <!-- SECTION readonly -->
                    <h3 id="readonly">readonly</h3>
                    <p>A <a href="#Fields">field</a> that is marked <a href="">readonly</a> can only be set when declared or through a
                        <a href="#Constructors">constructor.</a></p>
                    <!-- !SECTION readonly -->
                    <!-- SECTION sealed -->
                    <h3 id="sealed">sealed</h3>
                    <p>To prevent a class from being inherited it can be marked with the <code>sealed</code> keyword. A member that is being overridden in a class can
                        also be marked as <code>sealed</code> which prevents it from being overridden in any further derived classes.</p>
<pre><code>namespace Sealed
{
    public sealed class A
    {
        public void Method1() { }

        // Syntax error, a virtual member is invalid in a sealed class
        //public virtual void Method2() { }
    }

    // Syntax error, a derived class cannot inherit a sealed class
    //public class B : A { }

    public class C
    {
        public virtual void Method1() { }
    }

    public class D : C
    {
        public sealed override void Method1() { }
    }

    public class E : D
    {
        // Syntax error, 'E.Method1()' cannot override
        // inherited member 'D.Method1()' because it is sealed
        //public override void Method1() { }
    }

    class Program
    {
        static void Main(string[] args) { }
    }
}
</code></pre>
                    <!-- !SECTION sealed -->
                    <!-- SECTION static -->
                    <h3 id="static">static</h3>
                    <p>So far, the majority of the examples involve creating an instance of a class by using the <code>new</code> keyword. This
                        allows for multiple instances of a class to be created each with its own initialized state which can be set either by arguments passed in
                        through a constructor or with an object-initializer. Creating an instance of a class in this way is known as instantiation.</p>
                    <p>In addition, you can make a class static by applying the <code>static</code> keyword to the class declaration. Here the class cannot be
                        instantiated but is instead created automatically during runtime and only one instance of it exists. As a static class is not assigned an instance
                        variable identifier it is accessed by its class identifier instead.</p>
                    <p>The following members can also be made static using the static the <code>static</code> keyword.</p>
                    <ul>
                        <li><a href="#Constructors">constructors</a></li>
                        <li><a href="#Methods">methods</a></li>
                        <li><a href="#Fields">fields</a></li>
                        <li><a href="#Properties">properties</a></li>
                        <li><a href="#Events">events</a></li>
                    </ul>
                    <p>Static members belong to the type and can't be accessed through an instance. Instead, they are accessed through the type by using the type's
                        identifier in the form <span class="nowrap"><code>TypeName.Member</code>.</span> Within
                        a type, instance members can access static members but static members can only access other static members. As with a static class, static members
                        are created automatically at runtime and only one instance of the member exists. This means that if the value of a static member is changed
                        through its type or an instance of that type, then the value will be changed in all instances that contain it. Static fields that do not have
                        initializers and that are not assigned a value in a constructor will be assigned their default values. All members in a static class must always
                        be static.</p>
                    <p> A static constructor can't have access modifiers or parameters and can't be inherited or overloaded, so a type can only have one. It is called
                        automatically at runtime after any static field initializers are executed and before any instances are created or any static members are accessed.
                        A static constructor can't be directly called and a developer can't control when it will be executed.</p>
                    <p>A static method can be useful when it is to perform simple functions that don't have to store or retrieve data from within the class. As it is
                        automatically created at runtime, it can be shared from multiple locations throughout the program without the necessity to create a new instance
                        every time. The .NET <code>System.Math</code> class which contains numerous small math functions is an example of a static class.</p>
                    <p>In the following example, <code>InstanceClass</code> contains both instance and static, fields and methods. Whilst <code>InstanceMethod</code> can
                        access both <code>instanceField</code> and <code>staticField</code>, <code>StaticMethod</code> can only access
                        <span class="nowrap"><code>staticField</code>.</span></p>
                    <p> Next <code>MyClass</code> contains an instance property <code>InstanceProperty</code> and a static property
                        <span class="nowrap"><code>StaticProperty</code>.</span> <code>MyClass</code> also contains methods that can separately set and get the property
                        values. The static property is first set without an instance of <code>MyClass</code> through the use of
                        <span class="nowrap"><code>MyClass.StaticProperty</code>.</span> Next 2 instances of <code>MyClass</code>, <code>myClass1</code> and
                        <code>myClass2</code> are created and when the values of the properties are displayed it can be seen that <code>InstanceProperty</code> has the
                        value 0 and the <code>StaticProperty</code> the value 1. Next <code>myClass1</code> is used to change only the instance property in
                        <code>myClass1</code> has changed whereas the static property in both now has the value 3. This shows you that each instance has its own copy of
                        <code>InstanceProperty</code> whereas both share <span class="nowrap"><code>StaticProperty</code>.</span></p>
                    <p>Lastly the static class <code>MyMathFunctions</code> has the static method <code>SquareNumber</code> which is called directly using
                        <code>MyMathFunction.SquareNumber</code> to display the square of 3.</p>
<pre><code>namespace StaticExample
{
    public class InstanceClass
    {
        private int _instanceField;
        private static int _staticField;

        public void InstanceMethod(int value)
        {
            // An instance method can access both
            // static and instance fields
            _staticField = value;
            _instanceField = value;
        }

        public static void StaticMethod(int value)
        {
            _staticField = value;

            // Syntax error, a static method cannot access an instance field
            //_instanceField = value;
        }
    }

    // MyClass requires an instance to be created
    // before any instance members within it can be used
    // Static members can be used without an instance
    public class MyClass
    {
        public int InstanceProperty { get; set; }

        public static int StaticProperty { get; set; }

        public int GetInstanceProperty()
        {
            return InstanceProperty;
        }

        public void SetInstanceProperty(int value)
        {
            InstanceProperty = value;
        }

        public int GetStaticProperty()
        {
            return StaticProperty;
        }

        public void SetStaticProperty(int value)
        {
            StaticProperty = value;
        }
    }

    // A static class cannot be instantiated and can only contain static members
    public static class MyMathFunctions
    {
        private static readonly double _PI;

        static MyMathFunctions()
        {
            _PI = 3.1415;
        }

        public static double PI =&gt; _PI;

        public static int SquareNumber(int value)
        {
            return value * value;
        }

        // Syntax error, a static class can't declare instance members
        //public void InstanceMethod() { }
    }

    class Program
    {
        static void Main(string[] args)
        {
            string nl = Environment.NewLine;

            // Set MyClass.StaticProperty
            MyClass.StaticProperty = 1;

            // Syntax error, an instance of a class must be created to
            // use an instance member even if it contains static members
            //MyClass.InstanceProperty = 1;

            MyClass myClass1 = new();
            MyClass myClass2 = new();

            // Display the initial values of the instance and
            // static properties in instanceClass1 and instanceClass2
            // Both instance values will be 0 as they were set when the
            // instance was created. The static property is shared by all
            // instances and was set to 1 by MyClass.StaticProperty = 1; above
            Console.WriteLine("Display initial static and instance property");
            Console.WriteLine($"values of the two instances of MyClass{nl}");
            Console.WriteLine($"myClass1 InstanceProperty: {myClass1.GetInstanceProperty()}");
            Console.WriteLine($"myClass2 InstanceProperty: {myClass2.GetInstanceProperty()}");
            Console.WriteLine($"myClass1 StaticProperty: {myClass1.GetStaticProperty()}");
            Console.WriteLine($"myClass2 StaticProperty: {myClass2.GetStaticProperty()}");

            // Change the instance and static properties in myClassInstance2
            Console.WriteLine($"{nl}The instance and static properties are changed in myClassInstance2");


            // Each instance of MyClass has its own instance of
            // InstanceProperty so only myClassInstance1's is changed
            myClass1.SetInstanceProperty(2);

            // Both instances of MyClass share StaticProperty so changing
            // the value in myClassInstance1 changes it for both
            myClass1.SetStaticProperty(3);
            Console.WriteLine($"values of the two instances of MyClass are now{nl}");
            Console.WriteLine($"myClass1 InstanceProperty: {myClass1.GetInstanceProperty()}");
            Console.WriteLine($"myClass2 InstanceProperty: {myClass2.GetInstanceProperty()}");
            Console.WriteLine($"myClass1 StaticProperty: {myClass1.GetStaticProperty()}");
            Console.WriteLine($"myClass2 StaticProperty: {myClass2.GetStaticProperty()}");

            // The MyMathFunctions Square method and PI property and can
            // be accessed without creating an instance of MyMathFunctions
            Console.WriteLine($"{nl}The square of 3 is {MyMathFunctions.SquareNumber(3)}");
            var area = MyMathFunctions.PI * 4 * 4;
            Console.WriteLine($"Area of a circle with radius 4 = {area}");

            // Syntax error, a static class cannot be instantiated
            //MyMathFunctions staticClass;
        }
    }
}

// The example writes the following to the console
// Display initial static and instance property
// values of the two instances of MyClass

// myClass1 InstanceProperty: 0
// myClass2 InstanceProperty: 0
// myClass1 StaticProperty: 1
// myClass2 StaticProperty: 1

// The instance and static properties are changed in myClassInstance2
// values of the two instances of MyClass are now

// myClass1 InstanceProperty: 2
// myClass2 InstanceProperty: 0
// myClass1 StaticProperty: 3
// myClass2 StaticProperty: 3

// The square of 3 is 9
// Area of a circle with radius 4 = 50.264
</code></pre>
                    <!-- !SECTION static -->
                    <!-- SECTION unsafe -->
                    <h3 id="unsafe">unsafe</h3>
                    <p>The <code>unsafe</code> modifier is outside the scope of this guide. For more information, please see the
                        <a href="#References">Microsoft C# reference documentation</a></p>
                    <!-- !SECTION unsafe -->
                    <!-- SECTION virtual -->
                    <h3 id="virtual">virtual</h3>
                    <p>A <a href="#Methods">method</a>, <a href="#Properties">property</a>, <a href="#Indexers">indexer</a> or <a href="#Events">event</a> that is marked
                        <code>virtual</code> can be <i>overridden</i> in a <a href="#Inheriting_types">derived</a> <a href="#class">class</a> or
                        <a href="#record">record.</a> See <a href="#override">override.</a></p>
                    <p><em>Note:</em> <i>Microsoft has advised not to declare an event as <code>virtual</code> as the compiler does not handle these correctly.</i></p>
                    <!-- !SECTION virtual -->
                    <!-- SECTION volatile -->
                    <h3 id="volatile">volatile</h3>
                    <p>The <code>volatile</code> modifier is outside the scope of this guide. For more information, please see the
                        <a href="#References">Microsoft C# reference documentation</a></p>
                    <!-- !SECTION volatile -->
                    <!-- SECTION Access modifiers -->
                    <h3 id="Access_modifiers">Access modifiers</h3>
                    <p> Accessibility level declares where a type or type's members can be used by other code within an assembly or other assemblies that reference it.
                        Each type or
                        member has a default access level which, depending on the context, can be changed either by the access level of the container or by the use of an
                        access modifier keyword. A local variable's accessibility is always restricted to the <a href="#Scope">scope</a> in which it is contained and
                        cannot be modified.
                        Except for <code>protected internal</code> and <code>private protected</code> only one access modifier keyword can be applied to a type or a
                        member. For information about accessibility of the accessors for properties see <a href="#Properties">Properties</a> and for indexers see
                        <a href="#Indexers">Indexers.</a> Following is the list of access modifier keywords and the access level provided by them.</p>
                    <ul>
                        <li><i>public</i> - the same assembly or another assembly that references it</li>
                        <li><i>protected internal</i> - the same assembly or in a derived class in another assembly</li>
                        <li><i>protected</i> - the same class or a derived class in the same or another assembly</li>
                        <li><i>internal</i> - the same assembly only</li>
                        <li><i>private protected</i> - the same class or a derived class in the same assembly only</li>
                        <li><i>private</i> - the same class or a derived class nested within a base class only</li>
                    </ul>
                    <p>Types declared directly within a namespace (i.e., not nested), can only be declared public or internal where internal is the default level. The
                        following types can be declared in a namespace <code>class</code>, <code>struct</code>, <code>interface</code>, <code>delegate</code>,
                        <code>record</code> and <span class="nowrap"><code>enum</code>.</span></p>
                    <p>The following list shows containing types, which access modifiers can be applied to members and nested types, and the default access levels.</p>
                    <ul>
                        <li><i>class or record</i> - <code>public</code>, <code>protected internal</code>, <code>protected</code>,
                            <code>internal</code>, <code>private protected</code>, <code>private(default)</code></li>
                        <li><i>interface</i> - <code>public (default)</code>, <code>protected internal</code>, <code>protected</code>,
                            <code>internal</code>, <code>private protected</code>, <code>private</code>*</li>
                        <li><i>struct</i> - <code>public</code>, <code>internal</code>, <code>private(default)</code></li>
                    </ul>
                    <p>* A member in an interface that is marked <code>private</code> must have a default implementation.</p>
                    <p>Enum members do not have any declared accessibility and access modifiers cannot be applied to them. An enum member's accessibility  is determined
                        by the accessibility of the enum container type.</p>
                    <p>Even though not required, for code readability and to avoid errors, it is advisable to apply default level access modifiers to types and members.
                    </p>
                    <p>The following example demonstrates various accessibility scenarios. It contains two projects. The first is a class library called
                        <i>ClassLibrary</i> that has one file called <i>PublicBase.cs</i> with several classes within the namespace
                        <span class="nowrap"><code>ClassLibrary</code>.</span> The second is an executable called <i>AccessModifiers</i> that has a reference to
                        ClassLibrary and one file called <i>Program.cs</i> with several classes within the namespace
                        <span class="nowrap"><code>AccessModifiers</code>.</span></p>
<pre><code>// PublicBase.cs
// A class library referenced by Program.cs

namespace ClassLibrary
{
    public class PublicBase
    {
        public string PublicProperty { get; set; } = "library PublicProperty";
        protected internal string ProtectedInternalProperty { get; set; } = "library ProtectedInternalProperty";
        protected string ProtectedProperty { get; set; } = "library ProtectedProperty";
        internal string InternalProperty { get; set; } = "library InternalProperty";
        private protected string PrivateProtectedProperty { get; set; } = "library PrivateProtectedProperty";
        private string PrivateProperty { get; set; } = "library PrivateProperty";
    }

    internal class InternalBase { }

    class DefaultAccessBase { }
}

// ---------------------------------------------------------------------------------------------------

// Program.cs
// The main file of the program

namespace AccessModifiers
{
    // Default access for class without
    // an access modifier is internal
    class BaseClass
    {
        public string PublicProperty { get; set; } = "base PublicProperty";
        protected internal string ProtectedInternalProperty { get; set; } = "base ProtectedInternalProperty";
        protected string ProtectedProperty { get; set; } = "base ProtectedProperty";
        internal string InternalProperty { get; set; } = "base InternalProperty";
        private protected string PrivateProtectedProperty { get; set; } = "base PrivateProtectedProperty";
        private string PrivateProperty { get; set; } = "base PrivateProperty";

        // Default access for a class member
        // without an access modifier is private
        string DefaultProperty { get; set; } = "base DefaultProperty";

        // A method marked protected can only be
        // accessed within the base or a derived class
        protected void ProtectedMethod()
        {
            string nl = Environment.NewLine;
            Console.WriteLine($"base ProtectedMethod{nl}");
            PrivateMethod();
        }

        // A method marked private can only be
        // accessed from within the base class
        private void PrivateMethod()
        {
            string nl = Environment.NewLine;
            Console.WriteLine($"base PrivateMethod{nl}");
            // Within the same class any member can be accessed
            // within another no matter what its access level is
            Console.WriteLine($"base PrivateMethod PublicProperty = {PublicProperty}");
            Console.WriteLine($"base PrivateMethod ProtectedInternalProperty = {ProtectedInternalProperty}");
            Console.WriteLine($"base PrivateMethod ProtectedProperty = {ProtectedProperty}");
            Console.WriteLine($"base PrivateMethod InternalProperty = {InternalProperty}");
            Console.WriteLine($"base PrivateMethod PrivateProtectedProperty = {PrivateProtectedProperty}");
            Console.WriteLine($"base PrivateMethod PrivateProperty = {PrivateProperty}");
            Console.WriteLine($"base PrivateMethod DefaultProperty = {DefaultProperty}");
        }

        // As this class is nested it can be marked private
        private class Nested1 { }

        public class Nested2
        {
            public string PublicProperty { get; set; } = "nested PublicProperty";
            protected internal string ProtectedInternalProperty { get; set; } = "nested ProtectedInternalProperty";
            protected string ProtectedProperty { get; set; } = "nested ProtectedProperty";
            internal string InternalProperty { get; set; } = "nested InternalProperty";
            private protected string PrivateProtectedProperty { get; set; } = "nested PrivateProtectedProperty";
            private string PrivateProperty { get; set; } = "nested PrivateProperty";
        }
    }

    // Syntax error, a class that is not nested i.e. declared within
    // a namespace can only be marked as internal or public
    //private class Base2 { }

    // Inherits from Base within same assembly
    class DerivedClass : BaseClass
    {
        public void PublicMethod()
        {
            string nl = Environment.NewLine;
            Console.WriteLine($"derived PublicMethod{nl}");
            PublicProperty = "derived publicProperty";
            ProtectedInternalProperty = "derived protectedInternalProperty";
            ProtectedProperty = "derived protectedProperty";
            InternalProperty = "derived internalProperty";
            PrivateProtectedProperty = "derived privateProtectedProperty";

            // Syntax error, as 'PrivateProperty' and 'DefaultProperty' are private
            // in the base class they are inaccessible in the derived class
            //PrivateProperty = 0;
            //DefaultProperty = 0;

            ProtectedMethod();
        }
    }

    // Inherits PublicBase from ClassLibrary
    public class Class1 : ClassLibrary.PublicBase
    {
        public void PublicMethod()
        {
            PublicProperty = "Class1 publicProperty";
            ProtectedInternalProperty = "Class1 protectedInternalProperty";
            ProtectedProperty = "Class1 protectedProperty";

            // Syntax error, internal, private protected and private marked
            // members can only be accessed within the same assembly
            //InternalPublicProperty = "Class1 InternalPublic";
            //PrivateProtectedPublicProperty = "Class1 PrivateProtectedPublic";
            //PrivatePublicProperty = "Class1 PrivateProperty";
        }
    }

    // Cannot inherit from 'ClassLibrary.InternalBase' as it has
    // been marked Internal and cannot be accessed in another assembly
    //public class Class2 : ClassLibrary.InternalBase { }

    // Cannot inherit from 'ClassLibrary.DefaultAccessBase'
    // as it has no access modifier, is internal by default
    // and cannot be accessed in another assembly
    //public class Class3 : ClassLibrary.DefaultAccessBase { }

    class Program
    {
        static void Main(string[] args)
        {
            string nl = Environment.NewLine;

            // Only the internal, protected internal and public properties
            // from BaseClass, BaseClass.Nested2 and DerivedClass
            // are accessible within the Program class
            BaseClass baseClass = new();
            Console.WriteLine(baseClass.InternalProperty);
            Console.WriteLine(baseClass.ProtectedInternalProperty);
            Console.WriteLine(baseClass.PublicProperty + nl);

            BaseClass.Nested2 nested2 = new();
            Console.WriteLine(nested2.InternalProperty);
            Console.WriteLine(nested2.ProtectedInternalProperty);
            Console.WriteLine(nested2.PublicProperty + nl);

            DerivedClass derivedClass = new();
            Console.WriteLine(derivedClass.InternalProperty);
            Console.WriteLine(derivedClass.ProtectedInternalProperty);
            Console.WriteLine(derivedClass.PublicProperty + nl);
            derivedClass.PublicMethod();

            Class1 class1 = new();
            // Only the Public property from ClassLibrary.PublicBase that
            // Class1 inherited is accessible within the Program class
            Console.WriteLine(nl + class1.PublicProperty + nl);
            class1.PublicMethod();
            Console.WriteLine(class1.PublicProperty + nl);
        }
    }
}

// The example prints the following to the console
// base InternalProperty
// base ProtectedInternalProperty
// base PublicProperty

// nested InternalProperty
// nested ProtectedInternalProperty
// nested PublicProperty

// base InternalProperty
// base ProtectedInternalProperty
// base PublicProperty

// derived PublicMethod

// base ProtectedMethod

// base PrivateMethod

// base PrivateMethod PublicProperty = derived publicProperty
// base PrivateMethod ProtectedInternalProperty = derived protectedInternalProperty
// base PrivateMethod ProtectedProperty = derived protectedProperty
// base PrivateMethod InternalProperty = derived internalProperty
// base PrivateMethod PrivateProtectedProperty = derived privateProtectedProperty
// base PrivateMethod PrivateProperty = base PrivateProperty
// base PrivateMethod DefaultProperty = base DefaultProperty

// library PublicProperty

// Class1 publicProperty
</code></pre>
                    <!-- !SECTION Access modifiers -->
                </article>
            </section>
            <!-- !SECTION Scope and Modifiers -->
            <!-- SECTION Object-oriented Programming -->
            <section class="main-section" id="Object-oriented_Programming">
                <header><h2>Object-oriented Programming</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Object-oriented programming (OOP) is a programming paradigm used extensively throughout C#. It encompasses a number of concepts that provide the
                        developer a structured process for writing a program. This is particularly important for large programs that may be maintained by multiple teams
                        of developers. Instead of having one massive length of code that does everything, it is instead broken down into objects that each have a narrowly
                        defined responsibility. C# uses a sort of template called a type to define an object that is created when a program is run and multiple objects,
                        also called instances, can be created based on the type, each with their own state. These types are then combined to create an assembly and one or
                        more assemblies are combine to create a program.</p>
                    <p> Major principles of OOP include:</p>
                    <ul>
                        <li>Object</li>
                        <li>Encapsulation</li>
                        <li>Inheritance</li>
                        <li>Abstraction</li>
                        <li>Polymorphism</li>
                    </ul>
                    <!-- SECTION Object -->
                    <h3 id="Object">Object</h3>
                    <p>An object combines data and behavior to represent everyday things such as a number, a spreadsheet, a person or even something less tangible such as
                        the relationship between a part's name and its quantity in a database. During runtime multiple objects are created from a type definition each
                        with their own internal state. This allows different versions (instances) of an object to exist. For example, two number type objects could be
                        created, one with a value of 5 and another with 7. Three techniques employed by C# to define an object are:</p>
                    <ul>
                        <li>Properties - a particular state of an object such as color, the number of columns, what a thing is made of.</li>
                        <li>Methods - the behavior of an object such as add numbers, manipulate text, etc. Methods can take in and return modified data.</li>
                        <li>Events - a way of communicating to other objects that its state has changed.</li>
                    </ul>
                    <p>Take for example a light. It could have a 'Light Is On' property, a 'Turn Light On' method and a 'Light Has Turned' On event. A person object
                        could then check the 'Light Is On' property and if it's off (false), use the 'Turn Light On' method to turn the light on. The method would then
                        set 'Light Is On' to true and then trigger the 'Light Has Turned On' event. A second person object could be watching out for the event and when it
                        happens it would know to run its own 'Read Book' method.</p>
                    <!-- !SECTION Object -->
                    <!-- SECTION Encapsulation -->
                    <h3 id="Encapsulation">Encapsulation</h3>
                    <p>Encapsulation protects the data and methods used to define the internal state of an object from direct manipulation. Data that is passed in and out
                        of the object can be validated so as to ensure that the state of the object becomes invalid. This way code external to an object need not be
                        concerned with the data it contains or how a method works, only that by using it, it will provide the expected result. Take for example the
                        posting of a letter. Provided that you give it the correct address and a stamp, once you place it in the mail box you expect it to arrive at the
                        recipient. You need not be concerned with the details of the method (how it will be delivered) or the internal data (the name of the person doing
                        the delivery). With this the creator of the object is free to change the internal workings of an object without affecting those using it, as long
                        as it continues to do what it says on the box. In order to decide which object members are made available externally to an object, C# provides
                        access modifier keywords such as <code>public</code> and <span class="nowrap"><code>private</code>.</span></p>
                    <!-- !SECTION Encapsulation -->
                    <!-- SECTION Inheritance -->
                    <h3 id="Inheritance">Inheritance</h3>
                    <p>Many things in life have similarities. For example, a car and a motorbike both have an engine, wheels and brakes but whereas a motorbike has
                        handlebars a car has a steering wheel. This makes it difficult to use one object to represent both but rather than create two objects duplicating
                        much of the same functionality we can use the concept of inheritance. Here, first a parent object containing all the common traits is created
                        then separate child objects based on the parent are created, each adding just their own differences. Using the previous example, we could create a
                        vehicle object that has the engine, brakes and wheels properties then from that create a motorbike object that adds handlebars and a car object
                        that adds a steering wheel. By having a common inherited wheels property, the number of wheels can be set at runtime to 2 for a motorbike and 4
                        for car or even 3 if it is a three-wheeler.</p>
                    <p>Other names for parent are ancestor or superclass and for child, descendant or subclass. Just to be different, C# calls a parent a base type and
                        a child a derived type which is specifically mentioned here as C# provides the <code>base</code> keyword to access a base type from a derived
                        type. Also note that structs can neither inherit or be inherited by another class or struct.</p>
                    <!-- !SECTION Inheritance -->
                    <!-- SECTION Abstraction -->
                    <h3 id="Abstraction">Abstraction</h3>
                    <p>Abstraction is the process of determining and extracting from a complex problem just the information we require to define a solution. For example,
                        what does it take to eat food? Here we need to ask an expert in this case let's consider what a child would say. They'd probably say something
                        like, you  put food in your mouth, chew it then swallow. That's it. Now of course the human body is an extremely complex organism, to actually
                        eat food the brain has to send signals to the jaw muscles to chew the food, then to the tongue to swallow it. From there it goes into the stomach
                        where it is mixed with acid, then into the small intestine ... But for the purposes of survival all the user has to be concerned with is food,
                        mouth, chew, swallow. Of course, had we omitted the chew step then the choke method may have kicked in resulting in a premature end to our
                        program. It is important then to extract exactly what is required, no less, no more and this is an essential design step before the first line of
                        code is even written.</p>
                    <p>Another term you may come across is abstraction layers which is the dividing of a problem into the various layers of complexity. Take for instance
                        what is involved in writing and running a program. As mentioned in the C Sharp Language section all a computer knows is ones and zeroes but even
                        that is not the lowest level. If we go further, we get down to the quantum level where the state of electrons is controlled by transistors. This
                        is the hardware abstraction layer limited mainly to the manufacturer. Above the ones and zeroes, or binary abstraction layer, is the assembly
                        language which is a set of instructions in a pseudo human language provided by hardware manufacturers as to what the hardware does. This is the
                        language used by those creating the compiler that translates the C# language we write into the binary language and ultimately into the quantum
                        state of the hardware. This does not mean that someone writing in C# is completely separated from the other layers. For example, as you use the
                        code editor the compiler is constantly interpreting what you write and if it can't, it will warn you that there is a
                        <a href="#Syntax_errors">syntax error.</a></p>
                    <!-- !SECTION Abstraction -->
                    <!-- SECTION Polymorphism -->
                    <h3 id="Polymorphism">Polymorphism</h3>
                    <p>Polymorphism is the ability to substitute any child object for its parent and the members they contain. Using the inheritance example, we want to
                        make sure that we can steer our vehicle so we provide a steer method. This presents a problem as we can't be sure whether the consumer is going
                        to buy a car or a motorbike. The car has a steering wheel property that has to be set whereas the motor bike has handle bars. Polymorphism allows
                        you to substitute what the steer method does in the child object. If you then have a purchasing object, that has a buy method that can take in a
                        vehicle object and when it is called, you can substitute the vehicle parent object for either car or motorbike child object. This way whichever is
                        provided will have the correct steer method. </p>
                    <!-- !SECTION Polymorphism -->
                </article>
            </section>
            <!-- !SECTION Object-oriented Programming -->
            <!-- SECTION Keywords and Specifications -->
            <section class="main-section" id="Keywords_and_Specifications">
                <header><h2>Keywords and Specifications</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION Keywords -->
                    <h3 id="Keywords">Keywords</h3>
                    <p>Keywords are words reserved for use by the compiler and cannot be used as identifiers unless prefixed
                        <span class="nowrap">with<code>@</code>.</span> It is advisable not to do so as there is the possibility of introducing errors. For detailed
                        information on the keywords and specifications listed below see the <a href="#References">Microsoft C# reference documentation.</a></p>
                    <!-- SECTION C# Reserved keywords -->
                    <h4 id="C_sharp_Reserved_keywords">C# Reserved keywords</h4>
                    <p>These are keywords that are reserved throughout any part of a C# program</p>
                    <div class="four-column">
                        <!-- Column 1 -->
                        <div>
                            <p>abstract</p>
                            <p>as</p>
                            <p>base</p>
                            <p>bool</p>
                            <p>break</p>
                            <p>byte</p>
                            <p>case</p>
                            <p>catch</p>
                            <p>char</p>
                            <p>checked</p>
                            <p>class</p>
                            <p>const</p>
                            <p>continue</p>
                            <p>decimal</p>
                            <p>default</p>
                            <p>delegate</p>
                            <p>do</p>
                            <p>double</p>
                            <p>else</p>
                            <p>enum</p>
                        </div>
                        <!-- Column 2 -->
                        <div>
                            <p>event</p>
                            <p>explicit</p>
                            <p>extern</p>
                            <p>false</p>
                            <p>finally</p>
                            <p>fixed</p>
                            <p>float</p>
                            <p>for</p>
                            <p>foreach</p>
                            <p>goto</p>
                            <p>if</p>
                            <p>implicit</p>
                            <p>in</p>
                            <p>int</p>
                            <p>interface</p>
                            <p>internal</p>
                            <p>is</p>
                            <p>lock</p>
                            <p>long</p>
                        </div>
                        <!-- Column 3 -->
                        <div>
                            <p>namespace</p>
                            <p>new</p>
                            <p>null</p>
                            <p>object</p>
                            <p>operator</p>
                            <p>out</p>
                            <p>override</p>
                            <p>params</p>
                            <p>private</p>
                            <p>protected</p>
                            <p>public</p>
                            <p>readonly</p>
                            <p>ref</p>
                            <p>return</p>
                            <p>sbyte</p>
                            <p>sealed</p>
                            <p>short</p>
                            <p>sizeof</p>
                            <p>stackalloc</p>
                        </div>
                        <!-- Column 4 -->
                        <div>
                            <p>static</p>
                            <p>string</p>
                            <p>struct</p>
                            <p>switch</p>
                            <p>this</p>
                            <p>throw</p>
                            <p>true</p>
                            <p>try</p>
                            <p>typeof</p>
                            <p>uint</p>
                            <p>ulong</p>
                            <p>unchecked</p>
                            <p>unsafe</p>
                            <p>ushort</p>
                            <p>using</p>
                            <p>virtual</p>
                            <p>void</p>
                            <p>volatile</p>
                            <p>while</p>
                        </div>
                    </div>
                    <!-- !SECTION C# Reserved keywords -->
                    <!-- SECTION C# Contextual keywords -->
                    <h4 id="Contextual_keywords">Contextual keywords</h4>
                    <p>These are keywords that are reserved in only limited context within the program.</p>
                    <div class="four-column">
                        <!-- Column 1 -->
                        <div>
                            <p>add</p>
                            <p>and</p>
                            <p>alias</p>
                            <p>ascending</p>
                            <p>async</p>
                            <p>await</p>
                            <p>by</p>
                            <p>descending</p>
                            <p>dynamic</p>
                            <p>equals</p>
                            <p>from</p>
                        </div>
                        <!-- Column 2 -->
                        <div>
                            <p>get</p>
                            <p>global</p>
                            <p>group</p>
                            <p>init</p>
                            <p>into</p>
                            <p>join</p>
                            <p>let</p>
                            <p>managed (function pointer calling convention)</p>
                            <p>nameof</p>
                            <p>nint</p>
                            <p>not</p>
                        </div>
                        <!-- Column 3 -->
                        <div>
                            <p>notnull</p>
                            <p>nuint</p>
                            <p>on</p>
                            <p>or</p>
                            <p>orderby</p>
                            <p>partial (type)</p>
                            <p>partial (method)</p>
                            <p>record</p>
                            <p>remove</p>
                            <p>select</p>
                        </div>
                        <!-- Column 4 -->
                        <div>
                            <p>set</p>
                            <p>unmanaged (function pointer calling convention)</p>
                            <p>unmanaged (generic type constraint)</p>
                            <p>value</p>
                            <p>var</p>
                            <p>when (filter condition)</p>
                            <p>where (generic type constraint)</p>
                            <p>where (query clause)</p>
                            <p>with</p>
                            <p>yield</p>
                        </div>
                    </div>
                    <!-- !SECTION C# Contextual keywords -->
                    <!-- !SECTION Keywords -->
                    <!-- SECTION C# Specifications -->
                    <h3 id="C_Sharp_Specifications">C# Specifications</h3>
                    <p>Following is a list of specifications for the various C# types and escape characters</p>
                    <!-- SECTION C# Value type keywords -->
                    <h4 id="Value_type_keywords">Value type keywords</h4>
                    <ul>
                        <li>Boolean: <b>bool</b></li>
                        <li>Signed integer: <b>sbyte</b>, <b>short</b>, <b>int</b>, <b>long</b></li>
                        <li>Unsigned integer: <b>byte</b>, <b>ushort</b>, <b>uint</b>, <b>ulong</b></li>
                        <li>IEEE binary floating-point: <b>float</b>, <b>double</b></li>
                        <li>Decimal floating-point: <b>decimal</b></li>
                        <li>Unicode characters: <b>char</b></li>
                        <li>User-defined type of form <b>enum E {...}</b></li>
                        <li>User defined type of form <b>struct S {...}</b></li>
                        <li>Nullable value type: Extension of all other value types with a null value of the form <b>T?</b></li>
                    </ul>
                    <!-- !SECTION C# Value type keywords -->
                    <!-- SECTION C# Value type range and size -->
                    <h4 id="Value_type_range_and_size">Value type range and size</h4>
                    <ul>
                        <li><span><b>bool</b> :</span> false, true (1 byte, 8 bits)</li>
                        <li><b>sbyte</b> : -128 to 127 (1 byte, 8 bits)</li>
                        <li><b>short</b> : -32,768 to 32,767 (2 bytes, 16 bits)</li>
                        <li><b>int</b> : -2,147,438,648 to 2,147,483,647 (4 bytes, 32 bits)</li>
                        <li><b>long</b> : -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (8 byte, 64 bits)</li>
                        <li><b>byte</b> : 0 to 255 (1 byte, 8 bits)</li>
                        <li><b>ushort</b> : -128 to 127 (2 byte, 16 bits)</li>
                        <li><b>uint</b> : 0 to 65,535 (4 byte, 32 bits)</li>
                        <li><b>ulong</b> : 0 to 18,446,744,073,709,551,615 (8 byte, 64 bits)</li>
                        <li><b>float</b> : 1.5 x 10-45 to 3.4 x 1038, 7-digit precision (4 byte, 32 bits)</li>
                        <li><b>double</b> : 5.0 x 10-324 to 1.7 x 10308, 15-digit precision (8 byte, 64 bits)</li>
                        <li><b>decimal</b> : 1.0 x 10-28 to  7.9 x 1028, 28-bit precision (16 byte, 128 bits)</li>
                    </ul>
                    <p>The default value a <code>bool</code> is <code>false</code> for all numeric types <span>is <code class="nowrap">0</code>.</span></p>
                    <p>The float and double also have constants for not-a-number and infinity values. For a double this would be <code>double.NaN</code>,
                        <code>double.PositiveInfinity</code> and <span class="nowrap"><code>double.NegativeInfinity</code>.</span></p>
                    <!-- !SECTION C# Value type range and size -->
                    <!-- SECTION C# Built-in reference types -->
                    <h4 id="Built-in_reference_types">Built-in reference types</h4>
                    <ul>
                        <li>Ultimate base class of all other types: <b>object</b></li>
                        <li>Unicode strings: <b>string</b></li>
                        <li>Array types: Single dimensional <b>int[]</b>, multi-dimensional <b>int[,]</b></li>
                        <li>dynamic of the form <b>dynamic T</b></li>
                    </ul>
                    <!-- !SECTION C# Built-in reference types -->
                    <!-- SECTION C# User defined reference types -->
                    <h4 id="User_defined_reference_types">User defined reference types</h4>
                    <ul>
                        <li>User defined type of form <b>class C {...}</b></li>
                        <li>User defined type of form <b>interface I {...}</b></li>
                        <li>User-defined type of form <b>delegate T D(...)</b></li>
                        <li>User-defined type of form <b>record T R(...)</b></li>
                    </ul>
                    <!-- !SECTION C# User defined reference types -->
                    <!-- SECTION Literals -->
                    <h4 id="Literals">Literals</h4>
                    <p>A literal is interpreted by the compiler both by the way it is written and the context in which it is used. A compile error will result if a
                        literal is outside the range for the type it is being assigned to.</p>
                    <p>In the following</p>
<!-- Line space at bottom of code block is to prevent vertical scroll bar due to underline -->
<pre><code>byte b = 25; // This is OK
<u class="error">byte b = 311;</u> // Compile error: Value '311' cannot be converted to a 'byte'.

</code></pre>
                    <p>Literals are interpreted as follows.</p>
                    <p class="no-bottom-margin">Boolean literal, one of:</p>
                    <p><i>true &emsp; false</i></p>
<pre><code>bool test = true;
bool test = false;
</code></pre>
                    <p>Integer literals consist of combinations of the following.</p>
                    <p class="no-bottom-margin">decimal digits without any prefix:</p>
                    <p><i>0 1 2 3 4 5 6 7 8 9</i></p>
                    <p class="no-bottom-margin">hex digits with <code>0x</code> or <code>0X</code> prefix:</p>
                    <p><i>0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f</i></p>
                    <p class="no-bottom-margin">binary digits with <code>0b</code> or <code>0B</code> prefix:</p>
                    <p><i>0 1</i></p>
                    <p class="no-bottom-margin">unsigned, long and unsigned long identification suffix, one of:</p>
                    <p><i>U  u  L  l  UL  Ul  uL  ul  LU  Lu  lU  lu</i></p>
                    <p class="no-bottom-margin">sign prefix, one of:</p>
                    <p><i>+ -</i></p>
                    <p class="no-bottom-margin">digit separator:</p>
                    <p><i>_</i></p>
                    <p>Integer literals type are interpreted in the following order in which the value can be represented</p>
                    <ul>
                        <li>No suffix : <i>int, uint, long, ulong</i></li>
                        <li>Suffixed with <i>U</i> or <i>u</i> : <i>uint, ulong</i></li>
                        <li>Suffixed with <i>L</i> or <i>l</i> : <i>long, ulong</i></li>
                        <li>Suffixed by <i>UL, Ul, uL, ul, LU, Lu, lU, lu</i> : <i>ulong</i></li>
                    </ul>
                    <p>Some examples of usage</p>
<pre><code>var a = 1; // int
var b = -2147483648; // int
var c = 2147483648; // uint
var d = -9223372036854775808; // long
var e = 9223372036854775808; // ulong
var f = 4294967295u; // uint
var g = 4294967296u; // ulong
var h = -1L; // long
var j = 9223372036854775807L; // long
var k = 9223372036854775808L; // ulong
var l = 1UL; // ulong
var hex = 0xF81A; // int
var binary = 0b_0100_1010
</code></pre>
                    <p>A value outside of the range of the ulong type results in a compile error</p>
<pre><code>var tooBig = 18446744073709551616; // compile error: Integral constant too large
</code></pre>
                    <p>Real literals consist of combinations of the following:</p>
                    <p class="no-bottom-margin">decimal digits:</p>
                    <p><i>0 1 2 3 4 5 6 7 8 9</i></p>
                    <p class="no-bottom-margin">exponent part, one of:</p>
                    <p><i>e sign decimal digits &emsp; E sign decimal digits</i></p>
                    <p class="no-bottom-margin">sign prefix, one of:</p>
                    <p><i>+ -</i></p>
                    <p class="no-bottom-margin">real type suffix, one of:</p>
                    <p><i>F  f  D  d  M  m</i></p>
                    <p>Real literals are interpreted as follows</p>
                    <ul>
                        <li>No suffix : <i>double</i></li>
                        <li>Suffixed with <i>F</i> or <i>f</i> : <i>float</i></li>
                        <li>Suffixed with <i>D</i> or <i>d</i> : <i>double</i></li>
                        <li>Suffixed with <i>M</i> or <i>m</i> : <i>decimal</i></li>
                    </ul>
                    <p><em>Note:</em> <i>As per integer literals above a literal digit that is a whole number will be interpreted as an integer.</i></p>
<pre><code>var i = 1; // int
</code></pre>
                <p>Literals interpreted as real numbers</p>
<pre><code>var a = 1.0; //double
var b = 2.3; // double
var c = 3e9; // double
var d = -2.1e-3; // double
var e = 1f; // float
var f = 2.3f; // float
var g = 3e9f; // float
var h = -2.1e-3f; // float
var j = 1d; // double
var k = 2.3d; // double
var l = 3e9d; // double
var m = -2.1e-3d; // double
var n = 1m; // decimal
var o = 2.3m; // decimal
var p = 3e9m; // decimal
var q = -2.1e-3m; // decimal
</code></pre>
                    <!-- !SECTION Literals -->
                    <!-- SECTION C# Character specifications -->
                    <h4 id="Character_specifications">Character specifications</h4>
                    <p>Single character, one of:</p>
                    <p>any character except <code>'</code> <i>(U+0027)</i>, <code>\</code> <i>(U+005C)</i> or line character</p>
                    <p>Simple escape character, one of:</p>
                    <ul>
                        <li><b>\'</b>&emsp; Single quote</li>
                        <li><b>\"</b>&emsp; Double quote</li>
                        <li><b>\\</b>&emsp; Backslash</li>
                        <li><b>\0</b>&emsp; Null</li>
                        <li><b>\a</b>&emsp; Alert</li>
                        <li><b>\b</b>&emsp; Backspace</li>
                        <li><b>\f</b>&emsp; Form feed</li>
                        <li><b>\n</b>&emsp; New line</li>
                        <li><b>\r</b>&emsp; Carriage return</li>
                        <li><b>\t</b>&emsp; Horizontal tab</li>
                        <li><b>\v</b>&emsp; Vertical tab</li>
                    </ul>
                    <p class="no-bottom-margin">Unicode character escape sequence (UTF-16), one of:</p>
                    <p><b>\u0000</b> to <b>\uFFFF</b></p>
                    <p class="no-bottom-margin">Unicode character escape sequence (UTF-32), one of:</p>
                    <p><b>\U000000</b> to <b>\U10FFFF</b></p>
                    <p class="no-bottom-margin">Unicode escape sequence similar to "\u" except with variable length:</p>
                    <p><b>\x hhhh</b>&emsp; <em>Note:</em> <i>Due to possible confusion with \u and \U Unicode escape sequences it is not recommended to use
                        <b>\x hhhh</b></i></p>
                    <p>The default character value is the NUL character \u0000</p>
                    <p>Character literal examples</p>
<pre><code>var a = 'a' \\ the <i>a</i> character
var b = '\\' \\ the <i>\</i> character
var c = '\u0123' \\ the <i>g</i> character
</code></pre>
                    <!-- !SECTION C# Character specifications -->
                    <!-- !SECTION C# Specifications -->
                </article>
            </section>
            <!-- !SECTION Keywords -->
            <!-- Completed -->
            <!-- SECTION References -->
            <section class="main-section" id="References">
                <header><h2>References</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>
                        <a href="https://docs.microsoft.com/en-us/dotnet/csharp/"
                         rel="external nofollow noopener noreferrer" target="_blank">Microsoft C# reference documentation</a>
                    </p>
                    <p>
                        <a href="https://www.ecma-international.org/wp-content/uploads/ECMA-334_5th_edition_december_2017.pdf"
                         rel="external nofollow noopener noreferrer" target="_blank">ECMA-334 C# Language Specification</a>
                    </p>
                </article>
            </section>
            <!-- !SECTION References -->
<!-- TODO add copyright -->
            <!-- SECTION Terms and Conditions -->
            <section class="main-section" id="Terms_and_Conditions">
                <header><h2>Terms and Conditions</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>You accept all risk of using the website and content on the website. As far as the law allows, Stephen Ward provides the website as is, without any
                        warranty whatsoever.</p>
                    <p>The website may hyperlink to and integrate websites and services run by others. Stephen Ward does not make any warranty about services run by
                        others, or content they may provide. Use of services run by others may be governed by other terms between you and the one running the service.</p>
                    <h3 id="Notice_of_Non-Affiliation_and_Disclaimer">Notice of Non-Affiliation and Disclaimer</h3>
                    <p>The opinions expressed in this website are those of Stephen Ward and do not represent people, institutions or organizations that Stephen Ward may
                        or not be associated with in a professional or personal capacity, unless otherwise stated. Any views or opinions are not intended to malign any
                        religion, ethnic group, club, organization, company, individual or anyone or anything.</p>
                    <p>Stephen Ward is not affiliated, associated, authorized, endorsed by, or in any way officially connected with Microsoft or any of its subsidiaries
                        or its affiliates.</p>
                    <p>Microsoft, Visual C#, Visual Studio, IntelliSense and Windows are trademarks of the Microsoft group of companies.</p>
                </article>
            </section>
            <!-- !SECTION Terms and Conditions -->

        </main>
<!-- TODO Uncomment FreeCodeCamp script-->
        <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
    </body>
</html>