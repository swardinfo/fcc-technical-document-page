<!DOCTYPE html>
<html lang="en">
    <head>
        <!--meta-->
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!--title-->
        <title>C# Documentation</title>
        <!-- favicons -->
        <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="theme-color" content="#ffffff">
        <!--css-->
        <link rel="stylesheet" href="css/style.css">
    </head>
    <body>
        <!-- SECTION Main menu -->
        <!-- project requirement - nav element with a corresponding id="navbar" -->
        <nav id="navbar">
            <!-- project requirement - navbar should contain one header element with text describing topic of technical documentation -->
            <!-- project requirement - header element in navbar must come before any link elements -->
            <header><h1>C# Guide</h1></header>
            <ul>
                <!-- project requirement - navbar contains link elements with class of nav-link, one for every element with class main-section -->
                <!-- project requirement - each nav-link element should contain text corresponding header text in each section -->
                <!-- project requirement - clicking nav-link element navigates page to the corresponding main-doc section -->
                <li><a class="nav-link" href="#Introduction">Introduction</a></li>
                <li><a class="nav-link" href="#C_Sharp_and_Dot_NET">C Sharp and Dot NET</a></li>
                <li><a class="nav-link" href="#Integrated_Development_Environment">Integrated Development Environment</a></li>
                <li><a class="nav-link" href="#Create_a_Hello_World_Project">Create a Hello World Project</a></li>
                <li><a class="nav-link" href="#Code_Syntax">Code Syntax</a></li>
                <li><a class="nav-link" href="#Comments_and_Task_Lists">Comments and Task Lists</a></li>
                <li><a class="nav-link" href="#Errors_and_Exception_Handling">Errors and Exception Handling</a></li>
                <li><a class="nav-link" href="#Variables,_Constants,_Types_and_Literals">Variables, Constants, Types and Literals</a></li>
                <li><a class="nav-link" href="#Characters_and_Strings">Characters and Strings</a></li>
                <li><a class="nav-link" href="#Expressions_and_Operators">Expressions and Operators</a></li>
                <li><a class="nav-link" href="#Decision_Making_Statements">Decision Making Statements</a></li>
                <li><a class="nav-link" href="#Iteration_Statements">Iteration Statements</a></li>
                <li><a class="nav-link" href="#Arrays_and_Data_Structures">Arrays and Data Structures</a></li>
                <li><a class="nav-link" href="#Enumerators_and_tuples">Enumerators and tuples</a></li>
                <li><a class="nav-link" href="#Classes_and_Other_User_Defined_Types">Classes and Other User Defined Types</a></li>
                <li><a class="nav-link" href="#Anonymous_functions">Anonymous functions</a></li>
                <li><a class="nav-link" href="#Dependencies_and_Namespaces">Dependencies and Namespaces</a></li>
                <li><a class="nav-link" href="#Scope_and_Modifiers">Scope and Modifiers</a></li>
                <li><a class="nav-link" href="#Object-oriented_Programming">Object-oriented Programming</a></li>
                <li><a class="nav-link" href="#Keywords_and_Specifications">Keywords and Specifications</a></li>
                <li><a class="nav-link" href="#References">References</a></li>
                <li><a class="nav-link" href="#Terms_and_Conditions">Terms and Conditions</a></li>
            </ul>
        </nav>
        <!-- !SECTION Main menu -->

        <!-- project requirement - main element with id="main-doc" -->
        <main id="main-doc">
            <!-- project requirement - several section elements, each with a class of main-section. There should be a minimum of 5 -->
            <!-- project requirement - section with class of main-section, id corresponds to header text, spaces replaced with underscores -->
            <!-- TODO rewrite Introduction -->
            <!-- SECTION Introduction -->
            <section class="main-section" id="Introduction">
                <header><h2>Introduction</h2></header>
                <!-- project requirement -  first element in each .main-section is a header element which contains text that describes the topic -->
                <article>
                    <!-- project requirement - .main-section elements should contain at least 10 p elements total, not each -->
                    <p>The purpose of this guide is to give you an idea of what C# is about and the tools it provides for writing an application. What this is not is a
                        step by step guide into computer programming. Whilst someone with no programming skills may get some benefit, this guide it is aimed at those who
                        have experience with other languages and want to see what C# has to offer.</p>
                    <p>So what do you need to know. Firstly, developing an application in almost any programming language will require some basic maths skills, such as,
                        logical thinking, basic algebra, knowing the difference between integers and floating point numbers, etc. You should also know how to install and
                        upgrade software and operating systems on a computer, and have an internet connection. It would also be useful to know some of the basics of how a
                        computer works such as CPU's, memory, file systems, etc.</p>
                    <p>Lastly and perhaps most importantly is theory of mind, what the user maybe thinking when they use your program.
                        This should be a constant consideration as you create your application. For example, entering a letter in a program when a number is required may
                        be invalid. But then having a popup error message with each wrong keystroke that needs to be cancelled will quickly lead to frustration and your
                        program ending up in the trash.</p>
                </article>
            </section>
            <!-- !SECTION Introduction -->
            <!-- SECTION C# Language -->
            <section class="main-section" id="C_Sharp_and_Dot_NET">
                <header><h2>C Sharp and Dot NET</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p><em>Note:</em><i> The correct title for this section is <b>C# and .NET</b> but has been changed due to technical limitations</i></p>
                    <!-- SECTION The C# language -->
                    <h3 id="The_C_sharp_language">The C# language</h3>
                    <p>C# is a high level computer language created and maintained by Microsoft for the purpose of developing computer programs. A computer uses binary,
                        the language of ones and zeros. To put it at its simplest all a computer can do is like a light switch turn things on or off, albeit at billions
                        of times a second. For any person trying to write in ones and zeros, this soon becomes an impossible task. A high level programming language is a
                        type of shorthand that is human readable making it easier for a developer to read and write code.</p>
                    <!-- !SECTION The C# language -->
                    <!-- SECTION .NET -->
                    <h3 id="dot_NET">.NET</h3>
                    <p>.NET is an open-source, cross platform framework created and maintained by Microsoft. It provides the <i>Common Language Runtime</i>(CLR) which
                        will run our code and other services such as memory management, debugging, garbage collection, etc, making our job of writing code easier. The
                        phrase <i>during runtime</i>, is often used to refer to the time in which the code is running.</p>
                    <p>.NET also provides a large quantity of pre written code we can use that provides many of the basic functions such as file I/O, network access,
                        collections, user interfaces, etc, so we don't have to write our own. Whenever a console, WinForms or WPF application is created the .NET
                        framework is added by default and can be accessed through the System namespace.</p>
                    <p> The .Net version used throughout this guide is 5.0 and the C# version is 9.0.</p>
                    <p>Links to the reference documentation for C# and .NET can be found in <a href="#References">References</a></p>
                    <!-- !SECTION .NET -->
                </article>
            </section>
            <!-- !SECTION C# Language -->
            <!-- SECTION Integrated Development Environment -->
            <section class="main-section" id="Integrated_Development_Environment">
                <header><h2>Integrated Development Environment</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>An Integrated Development Environment or <i>IDE</i> is an application that contains various tools that assist the developer to write, run and
                        test a program. The IDE used in this guide is
                        <a href="https://visualstudio.microsoft.com/" rel="external nofollow noopener noreferrer" target="_blank">
                        Microsoft's Visual Studio 2019</a>. While Visual Studio has many tools, the three most important are the:</p>
                    <ul>
                        <!-- project requirement -.main-section elements should contain at least 5 li items total, not each -->
                        <li>Code editor</li>
                        <li>Compiler</li>
                        <li>Debugger</li>
                    </ul>
                    <p>The code editor, like a word processor, provides many tools that help in writing code. These include indication of
                        <a href="#Syntax_errors">syntax errors</a> shown with a <u class="error">red wavy underline</u> that may prevent the program from running, and
                        warnings shown with a <u class="warning">green wavy underline</u> that won't stop the program from running but should be addressed. It also
                        provides code auto completion, called IntelliSense in Visual Studio, that provides suggestions with documentation and formatting tools that help
                        keep the code consistent with coding conventions.</p>
                    <p>The compiler is used by C# to convert the code the developer writes into the language the computer requires and using it is known as building the
                        program. On completion, the compiler will report if the result was successful or produce a list of errors that must be corrected before the code
                        can be run.</p>
                    <p>The debugger aids the developer in finding errors in the code. Not every program will be written perfectly first time and the errors that prevent
                        it from functioning correctly are known as bugs. If we were just to write, compile and run the program, then we would not have much to go on as to
                        where a bug may exist. The debugger allows you to step through the code one line at a time to find the problem. This is known as running the
                        program with the debugger attached.</p>
                    <p>At the time of this writing there are three versions of Visual Studio.</p>
                    <ul>
                        <li>Community</li>
                        <li>Professional</li>
                        <li>Enterprise</li>
                    </ul>
                    <p>All examples in this document can be created and run on the community version which can be downloaded and installed free from the
                        <a href="https://visualstudio.microsoft.com/" rel="external nofollow noopener noreferrer" target="_blank"> Visual Studio</a> web page.</p>

                    <p><em>Note:</em> <i>Whilst the code editor in Visual Studio provides color coding for different elements of the code only the
                        <u class="error">red wavy underline</u> used to indicate syntax errors will be shown in this guide.</i></p>
                </article>
            </section>
            <!-- !SECTION Integrated Development Environment -->
            <!-- SECTION Create a Hello World Project -->
            <section class="main-section" id="Create_a_Hello_World_Project">
                <header><h2>Create a Hello World Project</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>This guide assumes that the IDE has already been installed, updated and the default settings have not been changed.</p>
                    <p>To create a new project</p>
                    <ol>
                        <li>Start the IDE then click <b>Create a new project</b>.</li>
                        <li> On the <span class="nowrap"><b>Create a new project</b></span> page in the search box at the top type
                            <span class="nowrap"><b>'console core'</b></span>.</li>
                        <li>A project template titled <span class="nowrap"><b>Console Application</b></span> should appear at the top of the list. It
                            has an icon that looks like a document with C# in the top right corner. Select <span class="nowrap"><b>Console Application</b></span> then
                            choose <b>Next</b>. (Hint: if <span class="nowrap"><b>Console Application</b></span> is not at the top, click <b>Clear all</b> and search
                            again)</li>
                        <li>On the <span class="nowrap"><b>Configure your new project</b></span> page type <b>'HelloWorld'</b>
                            in the <span class="nowrap"><b>Project name</b></span> box. Leave the <b>Location</b> and <span class="nowrap"><b>Solution name</b></span> as
                            filled in by the IDE and choose <b>Next</b>.</li>
                        <li>In the <span class="nowrap"><b>Additional information</b></span> page make sure <b>.NET5.0(Current)</b> is selected in the dropdown selector
                            then choose <b>Create</b></li>
                    </ol>
                    <p>The main window of the IDE opens with <i>Solution Explorer</i> open on the right and the code editor on the left. The <i>Program.cs</i> code file
                        should be open in the code editor with the code as per the following example. Not shown here are the line numbers in the left column visible in
                        the code editor. These are not part of the program and are purely for reference.</p>
<!-- Warning, pre and code tags require html to be formatted here which makes it look like crap in the code editor! -->
<pre><code>using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
</code></pre>
                    <p>To run the program press <kbd>F5</kbd>.</p>
                    <p>The console, a <i>command window</i> in Windows, opens displaying the words <b>'Hello World!'</b>. Congratulations, you have now created and run
                        your first C# program. The remainder of the text tells you the program finished but the IDE has kept the console open so that you can see the
                        result. Press any key to close the console.</p>
                    <p>By pressing <kbd>F5</kbd> the compiler built then ran the program with the debugger attached known as running in <i>debug mode</i>. The program
                        starts running at the line <code>static void Main(string[] args)</code>. This is known as the <i>entry point</i> and there are several
                        <a href="#Code_Syntax">code&nbsp;syntax</a> rules it must follow. <code>static void Main(string[] args)</code> is also the start of a
                        <a href="#Methods">method</a>.</p>
                    <p>Following <code>static void Main(string[] args)</code> is a pair of braces <code>{ }</code> that form a
                        <a href="#Code_Syntax">code block</a>. The program runs or <i>executes</i> all the <a href="#Code_Syntax">statements</a> it finds within these.
                        Statements are executed from top to bottom in the order they appear unless a statement directs execution to another part of the program. Here
                        there is only one, <code>Console.WriteLine("Hello World!");</code>. This tells the computer to write a line followed by a carriage return to the
                        <i>command window</i> and that the text to be written is located within the round brackets <code>( )</code>, which in this case is
                        <span class="nowrap"><b>'Hello World!'</b></span>. As there are no further lines in our code before the closing brace <code>}</code>, the
                        program exits. At this point the window of a program would normally close but the Visual Studio has an option to keep console application windows
                        open so that you can see the results. This option is turned on by default.</p>
                </article>
            </section>
            <!-- !SECTION Create a Hello World Project -->
<!-- TODO rewrite this -->
<!-- TODO add expression bodied members -->
<!-- TODO add syntax errors when uncommenting -->
<!-- TODO add local function syntax -->
            <!-- SECTION Code Syntax -->
            <section class="main-section" id="Code_Syntax">
                <header><h2>Code Syntax</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Some of the terms that will be mentioned in this section have not yet been covered and links are provided to their details, so consider this as a
                        reference to come back to as you become more familiar with them.</p>
                    <p>C# consists of text and symbols each of which tells the compiler how to convert our code into a program. The <i>syntax</i> is the set of rules that
                        governs how our code must be put together, i.e. which word or symbol goes where. Together these words and symbols are combined to form statements,
                        declarations and directives that are the instructions used to create a C# program.</p>
                    <p>First a quick look at the structure of the code which we'll go to into detail throughout this guide. In general a program takes the form of a list
                        of instructions with one per line, though C# allows for an instruction to span multiple lines if required. C# also allows for multiple
                        instructions to be enclosed within a pair of braces <code>{ }</code> (<i>also known as curly brackets</i>) called a <i>code block</i>. A code
                        block can be empty or it can contain any combination of statements, declarations, directives, comments and other code blocks. Each instruction,
                        depending on its type, must be followed by either a code block, a semicolon <code>;</code> or a carriage return. The compiler ignores comments and
                        whitespace other than as separators for words and symbols.</p>
                    <p>There are varying conventions on how to format code. The one used throughout this guide is to place code blocks containing instructions directly
                        under the beginning of the instruction they belong to and indent everything within them. An empty code block may be placed on the same line after
                        the instruction. The IDE has tools to aid with code formatting styles such as this.</p>
                    <p>A statement is the part of the code that becomes the instructions in the program that tells the computer what to do. A declaration instructs the
                        compiler to create a placeholder for an <a href="#Object">object</a> that is to exist and become part of the program. In some cases a declaration
                        can also be a statement. The object must then be initialized if it is a value type or instantiated if it is a reference type before it can be
                        used. A directive is an instruction for the compiler that while not directly part of our program will effect how our program will be built and
                        run.</p>
                    <p>For someone with no experience in C#, reading a list of rules and specifications is likely to lead to more confusion than understanding, so the
                        best way forward is to dive into some examples and see what's going on.</p>
                    <p>The following example illustrates both valid and invalid syntax</p>
<pre><code>// This is a comment.

// using directive.
using System;

// namespace declaration.
namespace CodeSyntax
{
    // class declaration
    public class MyClass
    {
        // Constructor declaration with empty code block.
        MyClass() { }

        // Method declaration.
        static void Main(string[] args)
        {
            // Single statement.
            Console.WriteLine("Hello World!");

            // Single statements, declaring and assigning variables.
            int k;
            k = 0;
            int j = 0;
            bool a = true;

            // while statement with code block.
            while (true)
            {
                k = 1;
                break;
                // Unreachable code.
                j = 2;
            }

            // These two 'if' statements are equivalent.
            if (a)
            {
                k = 1;
            }

            if (a)
                k = 1; // Embedded statement.

            // The  Console.WriteLine("Hello World!"); from above rearranged.
            // Whilst this is a  valid statement human readability is poor.
            Console
                .
                    WriteLine

                ("Hello World")
                                ;  // The semicolon here determines the end of the statement.

            // OK string statement, can put line break in verbatim string.
            //
            Console.WriteLine(@"Hello
World!");

            // This produces.
            // Hello
            // World

            // Creating or instantiating an object
            // using a constructor.
            AnotherClass class1 = new();

            // Creating or instantiating an object
            // using a constructor and assign a value
            // to Property in an object initializer.
            AnotherClass class2 = new()
            {
                Property = 1
            };

            // The following results in the error.

            if (a)
                var y = 1; // Invalid, embedded statement cannot be a declaration.

            // Invalid statement, can't put space in keyword.
            Con sole.WriteLine("Hello World");

            // Invalid statement, can't put line break in keyword.
            Con
                sole.WriteLine("Hello World");

            // Invalid string statement, can't put line break in regular string.
            Console.WriteLine("Hello
                                World!");
        }
    }

    // Declare a nested class within MyClass.
    public class AnotherClass
    {
        // Declare a property.
        public int Property { get; set; }
    }
}
</code></pre>
                    <p>In the example above, the first line is a <a href="#Comments_and_Task_Lists">comment</a>. The two forward slashes <code>//</code> at the beginning
                        indicates that this is a single line comment.</p>
                    <p>The line <code>using System;</code> is a using directive and must always end with a semicolon <code>;</code>. The first word <code>using</code> is
                        a reserved word called a <i>keyword</i> in C#. <a href="#Keywords_and_Specifications">Keywords</a> are directly used by the compiler as
                        instructions. The next word <code>System</code> is an <i>identifier</i>. Identifiers are used to name types such as
                        <a href="#Classes_and_Other_User_Defined_Types">classes, interfaces, structs, records,</a>
                        <a href="#Anonymous_functions">delegates,</a> <a href="#Enumerators">enums</a>, <a href="#tuple">tuples</a> and their
                        <a href="#Classes_and_Other_User_Defined_Types">members</a>, and <a href="#Variables,_Constants,_Types_and_Literals">variables</a> or
                        <a href="#Namespaces">namespaces</a>.</p>

                    <p>The rules for identifiers are</p>
                    <ul>
                        <li>Identifiers must begin with a letter or the <code>_</code> character</li>
                        <li>Identifiers can only contain letters, numbers or the <code>_</code> character</li>
                        <li>Identifiers shouldn't contain two or more consecutive <code>_</code> characters as these are reserved for
                            compiler generated identifiers</li>
                        <li>Identifiers are case sensitive</li>
                        <li>Identifiers can only be declared once within the same <a href="#Scope">scope</a></li>
                        <li>A keyword can't be used as an identifier</li>
                    </ul>
                    <p>By being case sensitive it is valid for two identifiers to differ by case only, e.g. <code><b>n</b>ame</code> and <code><b>N</b>ame</code> are two
                        different identifiers.</p>
                    <p>There may also be situations where using a specific identifier may result in a <i>naming conflict</i> with an identifier in built-in types. In
                        particular all types, even those you define yourself, are provided by .NET with a number of standard <a href="Members">members</a>. Unless these
                        are specifically being overridden the identifiers, <code>Equals</code>, <code>GetHashCode</code>, <code>GetType</code> and <code>ToString</code>
                        should be avoided. </p>
                    <p>More recently C# has introduced the discard variable which is used when the output of an expression is not required. This is an advanced subject
                        that won't be discussed in this guide but is mentioned here for completeness. The identifier for the discard variable is the <code>_</code>
                        character by itself. Unlike other variables, multiple discard variable identifiers can be declared within the same scope.</p>
                    <p><code>namespace MyProgram</code> is a namespace declaration. Namespaces are used to organize objects into logical groups. Details of the
                        <code>using</code> directive and namespaces are in (<a href="#Namespaces_and_References">Namespaces and References</a>).</p>
                    <p>Following the namespace declaration is an opening brace <code>{</code> which is the beginning of a code block and its closing brace
                        <code>}</code> is the last line in the example. All code blocks must have an opening and closing brace. Nested within this code block is a
                        <a href="#class">class</a> as declared by <code>public class MyClass</code> and its associated code block. Nested within this is a
                        <a href="#Constructor">constructor</a> declaration <code>MyClass() { }</code> , a <a href="#Methods">method</a> declaration
                        <code>static void Main(string[] args)</code> and their code blocks.</p>
                    <p>There are two main ways in which a program can be compiled for use. The first is as a class library to be used by other applications and the second
                        as an application that can be started directly. For the latter the program must have an entry point method and as mentioned in
                        (<a href="#Create_a_Hello_World_Project">Create a Hello World Project</a>), for C# it is the method <code>static void Main(string[] args)</code>.
                        There are several rules that it must follow but the main ones that are of concern are</p>
                    <ul>
                        <li>There can only be one <code>static void Main(string[] args)</code> method within the program</li>
                        <li>It must have the <code> static </code> keyword </li>
                    </ul>
                    <p><code>Console.WriteLine("Hello World!");</code> , a single line statement, is the first in the <code>public void MyMethod()</code> code block. In
                        this context, the dot <code>.</code> between <code>Console</code> and <code>WriteLine ("Hello World")</code> is called the Member access operator.
                        It allows access to a <a href="">member</a>, here a method called <code>WriteLine</code> in a class called <code>Console</code>. The round
                        brackets <code>( )</code> allow parameters to be passed into the method, here the <a href="#Characters_and_Strings">string</a> literal
                        <code>"Hello World!"</code>. All single line statements must end with a semicolon <code>;</code> . Following are three further examples of single
                        line statements showing how <a href="#Variables,_Constants,_Types_and_Literals">variables</a> can be declared and assigned.</p>
                    <p> The <code>while (true)</code> statement also called a <a href="#while_statement">while</a> loop, together with the braces and enclosed code form a
                        code block. No semicolon is required after the closing brace. Within the code block is first an assignment statement, followed by a
                        <code>break</code> statement then another assignment statement. As the <a href="#break">break</a> statement causes the program to leave the while
                        loop before reaching the second assignment statement and, it can't be executed and is known as unreachable code. This won't prevent the program
                        from being built or run but will cause a warning in the the code editor and should be rectified.</p>
                    <p>Next are two <code>if</code> statements. An if statement is a <a href="#Decision_Making_Statements">decision making statement</a>. Some statements
                        allow for a single statement known as an embedded statement, such as <code>x = 1;</code> in the example, to be placed directly after it without
                        the need for braces. Together they form a compound statement so the first two <code>if</code> statements are equivalent. An embedded statement
                        cannot be a declaration or labelled statement so the last <code>if</code> statement example is invalid.</p>
                    <p>As mentioned above, but for a few exceptions, the compiler ignores line breaks, tabs and whitespace, so a statement does not need to be on a single
                        line. <code>Console.WriteLine ("Hello World");</code> can be rearranged to produce the following valid code example as it's the semicolon that
                        instructs the compiler where the end of the statement is. <a href="#keywords">Keywords</a> and identifiers can't contain whitespace or line breaks
                        so the following two examples are invalid. For the remainder of this guide, <i>statement</i> will refer to a statement that ends with a semicolon,
                        even if that statement spans multiple lines.</p>
                    <p>Regular <a href="#Characters_and_Strings">string</a> literals such as "Hello World!" can't contain line breaks so the first string statement
                        example is invalid. Verbatim <a href="#Characters_and_Strings">string</a> literals, prefixed with an <code>@</code> symbol, as in the second
                        example can contain line breaks and produces the result as shown.</p>
                </article>
            </section>
            <!-- !SECTION Code Syntax -->
            <!-- SECTION Comments and Task Lists - Section -->
            <!-- NOTE Ignore all TODO in this section -->
            <section class="main-section" id="Comments_and_Task_Lists">
                <header><h2>Comments and Task Lists</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Comments have several purposes, they provide information to developers as to what the code does and can also aid in debugging. Comments are ignored
                        by the compiler when building the application.</p>
                    <p>Following are some examples of comments.</p>
<pre><code>using System;

namespace Comments
{
    class Program
    {
        static void Main(string[] args)
        {
            // This is a single line comment
            int i = 1; // This starts after the statement

            /*
                this is
                    a multi-line comment
                */
            // this is a better way
            // to do a multi-line comment

            // Program execution can be temporarily changed in
            // order to debug and determine where a fault may lie.
            // The following statement will be ignored when the program runs
            // suspectedError++;

            // See the description in the main text on how to comment out
            // multiple lines of code such as the following 3 lines
            Console.WriteLine("Hello World!");
            Console.WriteLine("Hello World!");
            Console.WriteLine("Hello World!");

            // TODO: This comment will be added to the tasks list
        }
    }
}
</code></pre>
                    <p>Comments can be in two forms. Single line comments start with <code>//</code> and extend to the end of the line. Delimited comments start with
                        <code>*/</code> end with <code>*/</code> and can span multiple lines. For technical reasons that won't be detailed here it is preferred to use
                        multiple single line rather than delimited comments and the code editor has tools that assist with this. To comment out multiple lines, first select
                        all
                        the lines by placing the cursor in front of the first statement, then while pressing the <kbd>Ctrl</kbd> key, drag the mouse diagonally down to
                        the end of the last statement. Then while still pressing <kbd>Ctrl</kbd> press and release <kbd>K</kbd> then press <kbd>C</kbd> to comment out the
                        selected lines. To uncomment, again with all lines selected, press <kbd>Ctrl</kbd> + <kbd>K</kbd> then while still pressing <kbd>Ctrl</kbd>
                        release <kbd>K</kbd> then press <kbd>U</kbd>.</p>
                    <p>The last comment in the example, <code>// TODO: A task list comment</code>, is interpreted by the code editor as a task to be added to the Task
                        List. There are four predefined task tokens, <code>HACK</code>, <code>TODO</code>, <code>UNDONE</code>, <code>UnresolvedMergeConflict</code> and
                        custom tokens can also be added. Task tokens are not case sensitive. To see the task list, in the menu click <b>View</b> then <b>Task List</b>.
                    </p>
                </article>
            </section>
            <!-- !SECTION Comments and Task Lists - Section -->
            <!-- SECTION Errors and Exception Handling -->
            <section class="main-section" id="Errors_and_Exception_Handling">
                <header><h2>Errors and Exception Handling</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <!-- SECTION Errors types -->
                <article class="main-article">
                    <p>As the program code grows the likelihood that a error will be introduced grows with it. C# provides tools for handling these depending on the kind
                        of error that is encountered.</p>
                    <h3 id="Error_types">Error types</h3>
                    <p>There are three different kinds of errors, syntax errors, runtime errors and logical errors.</p>
                    <h4 id="Syntax_errors">Syntax error</h4>
                    <p>As the title suggests, syntax errors occur when the syntax is wrong and this will prevent the code from being compiled. This could be caused by a
                        spelling mistake, a missing semi colon, an incorrect use of a language element, etc. The code editor will identify such errors with a
                        <u class="error">red wavy underline</u>. These are the easiest errors to fix as in most cases, hovering the mouse over the error will result in a
                        popup dialog in the code editor, identifying the issue along with suggestions on how to fix it.</p>
                    <h4 id="Runtime_errors">Runtime error</h4>
                    <p>A runtime error occurs after the program has been compiled and run. Whilst syntactically correct, when the code is executed it will result
                        in an error that causes the program to crash, most often in the form of an unhandled <a href="#Exception_Handling">exception</a>. As such errors
                        are at a fixed point in the code, these can be usually be fixed fairly easily by either correcting the error through debugging or by providing
                        appropriate <a href="#Exception_Handling">exception handling</a>.</p>
                    <h4 id="Logical_errors">Logical error</h4>
                    <p>These are errors that occur while the program is running but don't cause the program to crash. Instead the program will produce an unexpected
                        result. For example the sum of a list of numbers may be far more than expected because an expression may mistakenly multiplies instead of adding
                        the values. These are often the hardest errors to debug as they most often they result from incorrect assumptions on what the program is doing.
                    </p>
                <!-- !SECTION Errors types -->
                    <!-- SECTION Exception handling -->
                    <h3 id="Exception_Handling">Exception handling</h3>
                    <p>An <code>exception</code> is an error from which the program cannot recover. C# has a number of built in exceptions that are thrown for various
                        error conditions. Following is an example that shows the result of attempting to divide by zero. By pressing <kbd>F5</kbd> the program will start
                        running in debug mode and then stop and highlight the statement <code>var z = x / y;</code> and display an <i>Exception Unhandled</i> dialog box
                        with the message <i>System.DivideByZeroException: 'Attempted to divide by zero.'</i> of which <code>DivideByZeroException</code> is the exception.
                        To stop the program and clear the exception press <kbd>Shift</kbd> + <kbd>F5</kbd>.</p>
<pre><code>using System;

namespace Exception
{
    class Program
    {
        static void Main(string[] args)
        {
            var x = 1;
            var y = 0;
            var z = x / y;
        }
    }
}

// When run, the example results in a DivideByZeroException
</code></pre>
                    <!-- !SECTION Exception handling -->
                    <!-- SECTION throw -->
                    <h3 id="throw_statement">throw statement</h3>
                    <p>Sometimes you may wish to check for invalid conditions specific to your own program. When these occur you can respond by throwing an exception of
                    your own choice using the <code>throw</code> keyword. You can also include a custom message with the exception. The following throws an
                    <code>ArgumentException</code> with the message <i>y cannot be zero</i>.</p>
<pre><code>using System;

namespace Throw
{
    class Program
    {
        static void Main(string[] args)
        {
            int y = 0;
            throw new ArgumentException("y cannot be zero");
        }
    }
}

// When run, the example results in
// System.ArgumentException: 'y cannot be zero'
</code></pre>
                    <!-- !SECTION throw -->
                    <!-- SECTION try-catch -->
                    <h3 id="try-catch">try-catch</h3>
                    <p>The try-catch provides a mechanism to safely handle exceptions and consists of a <code>try</code> code block followed by a <code>catch</code>
                        code block. Code that has the possibility of resulting in an exception is placed within the <code>try</code> block and if an exception occurs
                        program execution stops before any further code within the <code>try</code> block is run. Program execution then passes to a catch block that
                        targets the exception. If none is found, program execution passes back to the calling code until an appropriate catch block is found. If a
                        <code>catch</code> block is not found then the program ends with an <i>unhandled exception</i></p>.
                    <p>Following shows how the <code>DivideByZeroException</code> in the previous example could be handled. When run, instead of resulting in an unhandled
                        exception dialog box, <i>Attempted to divide by zero.</i> is written to the console.</p>
<pre><code>using System;

namespace TryCatch
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 1;
            int y = 0;
            try
            {
                int z = x / y;
            }
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}

// The example writes the following to the console
// Attempted to divide by zero.
</code></pre>
                    <p>It is important to note that catching exceptions should not be used just to control program flow. In the previous example an
                        <a href="#if_statement">if statement</a> could be used to test the value of <code>y</code> and only allow the division to take place if it is not
                        zero. An example of where a try-catch could be employed is writing to a file as is not possible to test prior whether the action will succeed.</p>
                    <!-- !SECTION try-catch -->
                    <!-- SECTION multiple catch blocks -->
                    <h3 id="multiple_catch_blocks">multiple catch blocks</h3>
                    <p>It is possible to have multiple catch blocks so as to catch different exceptions. An exception is only caught by the first catch block that
                        can handle it. If there is the possibility that the exception could be caught by more than one, the catch blocks should be ordered most to least
                        specific. In the following example the first block catches the <code>DivideByZeroException</code> and the second <code>Exception</code>
                        catches all exceptions. This means that if <code>DivideByZeroException</code> code block had not been present then the divide by zero exception
                        would have been caught by the <code>Exception</code> code block.</p>
<pre><code>using System;

namespace MultipleCatchBlocks
{
    class Program
    {
        static void Main(string[] args)
        {
            int x = 1;
            int y = 2;
            try
            {
                int z = x / y;
                throw new Exception("A second exception");
            }
            catch (DivideByZeroException ex)
            {
                Console.WriteLine(ex.Message);
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }
}

// The example writes the following to the console
// A second exception
</code></pre>
                    <!-- !SECTION multiple catch blocks -->
                </article>
            </section>
            <!-- !SECTION Errors and Exception Handling -->
            <!-- SECTION Variables, Constants, Types and Literals -->
            <section class="main-section" id="Variables,_Constants,_Types_and_Literals">
                <header><h2>Variables, Constants, Types and Literals</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Variables are used to represent data in memory using a symbolic name. Every variable has a <i>type</i> that determines what type of data can be
                        stored and a <i>value</i> which is the actual data. C# is a strongly typed language which means the variable's type must be declared before it can
                        be used and cannot be changed later. The compiler then checks if the value stored in the variable is of the correct type and will tell you if it
                        is wrong. A <i>constant</i> is similar to a variable, except it must be assigned a value when declared and that value cannot be changed. A
                        <i>literal</i> is the representation in code of the data that is assigned to a variable. Variables and constants can only be declared once within
                        the same <a href="#Scope">scope</a></p>
                    <p>C# has two basic categories of variables, the <i>value type</i> and the <i>reference type</i>, into which all variables are grouped. A value type
                        stores its own data where as a reference type stores the address to where its data is located. You can think of these as a house and a contact in
                        an address book. The value type is like the house which has an address and physically stores its own contents where as the reference type is like
                        the contact that only stores the address to where the house is located. .</p>
                    <!-- SECTION Value type -->
                    <h3 id="Value_type">Value type</h3>
                    <p>C# allocates memory based on the smallest size unit of an 8 bit byte. For efficiency reasons, each value type uses a fixed number of bytes. For an
                        integer C# provides a number of options based on size and whether negative values are allowed. The most commonly used is the <i>int</i> which has
                        a memory allocation of 4 bytes or 32 bits and can have negative values. It has a range from -2147483648 to 2147483647. When you write
                        <code>int i = 1;</code> you are telling the compiler to reserve a 4 byte section of memory, that its address will be referred to by the variable
                        with the identifier <code>i</code> and to store the value <code>1</code> in it. But for a few exceptions, operations on one value type variable
                        cannot affect the data of another. A value type variable cannot be changed to refer to data in another memory location.</p>
                    <!-- !SECTION Value type -->
                    <!-- SECTION Reference type -->
                    <h3 id="Reference_type">Reference type</h3>
                    <p>Providing it is of the same type a reference type can be changed to refer to a different location in memory and its size in memory can change. A
                        reference type can only refer to one location at a time but two reference type variables can refer to the same location. The result is that
                        changing the contents of one will affect the contents of the other.</p>
                    <p>Another important distinction is equality when comparing two variables of the same type. In most cases if the two are value types then they will be
                        equal if the values they contain are the same whereas two reference types will be the same if they both refer to the same location in memory. A
                        notable exception is the <a href="#record">record</a> which is a reference type with value type equality.</p>
                    <p><em>Note:</em><i> Various type <a href="#Classes_and_Other_User_Defined_Types">members</a> allow the
                        <a href="#Signatures,_parameters_and_overloading">passing in</a> of a variable as an argument. When this occurs, what can happen to the variable
                        depends on whether it is a value or reference type and whether any keywords are present to change this behavior</i></p>
                    <p>C# has a number of built-in types of which each has a dedicated <a href="#Value_type_keywords">keyword</a>.</p>
                    <!-- !SECTION Reference type -->
                    <!-- SECTION Variable declaration and assignment -->
                    <h3 id="Variable_declaration_and_assignment">Variable declaration and assignment</h3>
                    <p>The following applies to variables</p>
                    <ul>
                        <li>A variable must be declared with a type before it can be used</li>
                        <li>A <a href="#Scope">local variable</a> can only be declared once within the same scope</li>
                        <li>A <a href="#Scope">local variable</a> must be assigned a value before it can be used</li>
                        <li>A variable's type cannot be changed</li>
                        <li>A constant must be assigned a value when declared</li>
                        <li>A constant's type and value cannot be changed</li>
                        <li>A <a href="#Scope">local variable</a> can be implicitly or explicitly declared</li>
                        <li>A <a href="#Access_modifiers">local variable's accessibility</a> cannot be changed with an <a href="#Access_modifiers">access modifier
                        </a></li>
                    </ul>
                    <p>In the following the first few examples demonstrate explicit declaration where you tell the editor what the variable's type is before it is used.
                        The first statement <code>int i;</code> declares the variable <code>i</code> to be a type of integer and then in <code>i = 1;</code> the
                        <code>=</code> <a href="#Assignment_operator">operator</a> assigns the literal value 1 to it. In <code>double j = 2.4</code> both the floating
                        point type <code>double j</code> is declared and the value 2.4 is assigned to it. In <code>int k = i + 3;</code> first the
                        <a href="#Expressions_and_Operators">expression</a> <code>i + 3</code> is evaluated then the resultant value 4 is assigned to <code>k</code>. In
                        <code>const double pi = 3.1415;</code> the constant <code>pi</code> is declared as a type <code>double</code> and is assigned the value 3.1415.
                    </p>
                    <p>C# also allows for <i>implicit</i> declaration through the use of the <code>var</code> keyword. This tells the compiler to determine the type of
                        variable to store based on the expression on the right side of the <code>=</code> operator. In the statement <code>var n = 3;</code> the compiler
                        interprets the 3 as an integer and based on its size assigns <code>n</code> a type of <code>int</code> and the value 3. In
                        <code>var d = 3.0</code> 3.0 is interpreted as a floating point number and <code>d</code> is assigned a type of <code>double</code> with a value
                        <code>3.0</code> . With <code>var x = i + n;</code> summing an <code>int</code> with an <code>int</code> results in an <code>int</code> so
                        <code>x</code> will be an <code>int</code>. In <code>var y = i + d;</code>summing an <code>int</code> with a <code>double</code> will result in a
                        <code>double</code> so <code>y</code> is a <code>double</code>. As can be seen care must be taken when using <code>var</code> as it is easy to end
                        up with a type that was not expected. It should also be mentioned that there is much debate as to the use of the <code>var</code> keyword which
                        will be left for the reader to research.</p>
                    <p>The next eight <code>Console.WriteLine</code> statements write the values of i, j, k, pi, n, d, x and y to the console. Note that the default
                        behavior of <code>Console.WriteLine</code> is to truncate a number if the fractional part is zero so <code>d</code> and <code>y</code> are written
                        as 3 and 4 respectively. The four statements that follow introduce the <code>GetType()</code> <a href="#Methods">method</a>. As the name suggests this method gets the
                        type of the variable supplied. <code>Console.WriteLine</code> then writes these to the console. When run, the program will write the result as
                        shown in the example to the console. For <code>n</code> and <code>x</code> this will be <code>System.Int32</code> and for <code>d</code> and
                        <code>y</code> <code>System.Double</code> where <code>System</code> is a <a href="#Namespaces">namespace</a>. C# has a number of
                        <a href="#Keywords_and_Specifications">keywords</a> for commonly used types. In this example <code>int</code> is the keyword for
                        <code>System.Int32</code> and <code>double</code> the keyword <code>System.Double</code> (note the capital 'D'). Both can be used in code but in
                        general the keyword is favoured by most.</p>
<pre><code>using System;

namespace Variables
{
    class Program
    {
        static void Main(string[] args)
        {
            // First declare an integer i then assign the value 1 to it
            int i;
            i = 1;

            // Both declare and assign 2.4 to double variable j
            double j = 2.4;

            // Evaluate the expression i + 3 right and assign it to k
            int k = i + 3;

            // Declare a double type constant pi
            // and assigns it the value 3.1415
            const double pi = 3.1415;

            // In the following the 'var' keyword tells the compiler to
            // select the type dependent on the operand being assigned

            // 3 is interpreted as an integer and assigned to integer variable n
            var n = 3;

            // 3.0 is interpreted as a double and assigned to double variable d
            var d = 3.0;

            // The sum of the two integers i and n is evaluated
            // and the resultant integer 4 is assigned to x
            var x = i + n;

            // The sum of the integer i and the double d is evaluated
            // and the resultant double 4.0 is assigned to y
            var y = i + d;

            // Writes the value of variables i, j and k to the console
            Console.WriteLine(i);
            Console.WriteLine(j);
            Console.WriteLine(k);

            // Writes the value of const double pi to the console
            Console.WriteLine(pi);

            // Writes the value of variables n, d, x and y to the console
            // Note - d and y will be written as 3 and 4 respectively as
            // Console.WriteLine does not include the fractional part
            // if it is zero
            Console.WriteLine(n);
            Console.WriteLine(d);
            Console.WriteLine(x);
            Console.WriteLine(y);

            // Determines the type of variables n, d, x and y
            // and writes it to the console
            Console.WriteLine(n.GetType());
            Console.WriteLine(d.GetType());
            Console.WriteLine(x.GetType());
            Console.WriteLine(y.GetType());
        }
    }
}
// The example writes the following to the console
// 1
// 2.4
// 4
// 3.1415
// 3
// 3
// 4
// 4
// System.Int32
// System.Double
// System.Int32
// System.Double
</code></pre>
                    <!-- !SECTION Variable declaration and assignment -->
                    <!-- SECTION Variable declaration and assignment syntax errors -->
                    <h3 id="Variable_declaration_and_assignment_syntax_errors">Variable declaration and assignment syntax errors</h3>
                    <p>Syntax errors that occur when declaring and assigning variables will prevent the application from being compiled. The editor identifies these
                        errors and notifies you by placing a <u class="error">red wavy underline</u> under the part of the statement that is causing them. By moving the
                        the mouse over the line a message will popup detailing the error. Some errors can be quite cryptic so following are a few examples and an
                        explanation of what they mean.</p>
                    <p><i>The name 'p' does not exist in the current context</i> - Before a variable can be used, it must first be declared either explicitly with
                        the use of a type followed by an identifier <code>int p;</code> or implicitly by use of the <code>var</code> keyword <code>var p = 0;</code></p>
                    <p><i>A local variable or function 'i' is already defined in this scope</i> - Only one unique instance of a variable can exist within a
                        <a href="#Scope">scope</a>. As <code>int i = 1;</code> has already declared variable <code>i</code>, the next statement
                        <code>int <u class="error">i</u> = 2;</code> is evaluated by the editor as an attempt to declare a second variable <code>i</code>.</p>
                    <p><i>Cannot use variable 'b' before it is declared</i> - C# executes statements in the order they appear in the code from top down. In this case
                        <code><u class="error">b</u> = 1;</code> has been written above <code>int b;</code>. Reversing the order of these two statements will resolve
                        this error.</p>
                    <p><i>Use of unassigned local variable 'k'</i> - C# requires variables declared within a local <a href="#Scope">scope</a> to be assigned a value
                        before they can be used. Here <code>int k;</code> declares that a variable <code>k</code> of type <code>int</code> but does not assign it a value.
                        When declaring a variable a value can simultaneously be assigned to it through the used of the <code>=</code>
                        <a href="#Assignment_operator">operator</a> as in <code>int k = 1;</code>. Alternatively a variable can be assigned a value after being declared
                        and before being used such as adding <code>k = 1;</code> after <code>int k;</code> and before <code>j = i + k;</code> Note that it is only
                        variables on the right side of the <code>=</code> operator that need to have a value assigned so the use of the <code>j</code> which is declared
                        but not assigned a value on the left side is valid. C# also has has the <code>default</code> keyword which allows any variable to be assigned its
                        default value such as <code>int k = default;</code>.  In this case <code>k</code>  would have a value of 0.</p>
                    <p><i>Cannot implicitly convert type 'double' to 'int'. An explicit conversion exists (Are you missing a cast?)</i> - In all the following cases
                        an attempt is being made to assign a variable of type <code>int</code> a value of type <code>double</code>. C# does not allow the assignment of a
                        value to a variable that could unwittingly result in a conversion that produces a loss of information. By assigning a floating point
                        <code>double</code> to an <code>int</code>, the fractional part after the decimal point could be lost. As can be seen from the examples it may not
                        be obvious at first that a conversion is occurring.</p>
                    <p><code>i = <u class="error">d</u>;</code> an attempt is being made to assign the value in <code>d</code> which was declared a
                        <code>double</code> to <code>i</code> which was declared an <code>int</code>.</p>
                    <p><code>i = <u class="error">3.0</u>;</code> the variable <code>i</code> which was declared as an <code>int</code> is being assigned the literal
                        <code>3.0</code> which is interpreted as a <code>double</code> by the editor.</p>
                    <p><code>b = <u class="error">i + d</u>;</code> as <code>i</code>is an <code>int</code> and <code>d</code> a <code>double</code> the result of
                     <code>i + d</code> is first evaluated by the editor to be a <code>double</code> so assigning this to <code>b</code> produces the error.</p>
                    <p><code>b = <u class="error">i + x</u>;</code> in the previous statement <code>var x = i + d;</code> <code>i + d</code> was evaluated by the editor
                        to be a <code>double</code> and is allowed to be assigned to <code>x</code> through the use of the <code>var</code> keyword. This results in
                        <code>i + x</code> also being interpreted as a <code>double</code> so assigning it to the int <code>b</code> produces the error.</p>
                    <p><code>d = i;</code> there is no possibility of information loss from an <code>int</code> to a <code>double</code> so this is allowed.</p>
                    <p><em>Note:</em> <i>C# has a number of explicit methods that allow for a <a href="#Type_conversion">conversion</a> that results in information loss
                        without resulting in an error.</i></p>
                    <p><i>The left-hand side of an assignment must be a variable, property or indexer</i> - Here <code>pi</code> is a constant and as its value can't be
                        changed so attempting to results in this error.</p>
                    <p><i>The expression assigned to 'area' must be constant</i> - As <code>area</code> has been declared a <code>const</code> the use of the variable
                        <code>i</code> in <code>i * 3 * 3</code> produces this error.</p>
                    <p><i>Operator '+' cannot be applied to operands of type 'int' and 'bool'</i> - C# does not allow the conversion of a boolean value to a number so
                        attempting a numeric addition between an <code>int</code> and a <code>bool</code> produces this error.</p>
<pre><code>using System;

namespace VariableSyntaxErrors
{
    class Program
    {
        static void Main(string[] args)
        {
            // A red wavy line under parts of the following statements
            // indicate that a syntax error is present. When the mouse
            // is placed over the line a message will pop up with
            // details of the error. The message has been included
            // as a comment above each example

            // The name 'p' does not exist in the current context
            <u class="error">p</u> = 1;

            int i = 1;

            // A local variable or function 'i' is already defined in this scope
            int <u class="error">i</u> = 2;

            // Cannot use variable 'b' before it is declared
            <u class="error">b</u> = 1;
            int b;

            int j;
            int k;

            // Use of unassigned local variable 'k'
            j = i + <u class="error">k</u>;

            // The next four statements would creates an implicit conversion
            // that would result in the fractional part of the double
            // being lost which is not allowed and so produce a syntax error

            double d = 0;

            // Cannot implicitly convert type 'double' to 'int'.
            // An explicit conversion exists (Are you missing a cast?)
            i = <u class="error">d</u>;

            // Cannot implicitly convert type 'double' to 'int'.
            // An explicit conversion exists (Are you missing a cast?)
            i = <u class="error">3.0</u>;

            d = i + 3;

            // Cannot implicitly convert type 'double' to 'int'.
            // An explicit conversion exists (Are you missing a cast?)
            b = <u class="error">i + d</u>;

            var x = i + d;

            // Cannot implicitly convert type 'double' to 'int'.
            // An explicit conversion exists (Are you missing a cast?)
            b = <u class="error">i + x</u>;

            // This is allowed as there is no loss of information
            d = i;

            const double pi = 3.1415;

            // The left-hand side of an assignment must be a variable, property or indexer
            <u class="error">pi</u> = 4;

            // The expression assigned to 'area' must be constant
            const double area = <u class="error">i * 3 * 3</u>;

            bool t = true;

            // Operator '+' cannot be applied to operands of type 'int' and 'bool'
            b = <u class="error">i + t</u>;
        }
    }
}
</code></pre>
                    <!-- !SECTION Variable declaration and assignment syntax errors -->
                    <!-- SECTION Type conversion -->
                    <h3 id="Type_conversion">Type conversion</h3>
                    <p>Following are examples of the different tools C# provides to convert built in types.</p>
<pre><code>using System;

namespace CastingAndConversion
{
    class Program
    {
        static void Main(string[] args)
        {
            int i;
            double d = 3.9;

            // This casts the double d with a value of 3.9 to int i
            // The cast truncates the value so 3.9 becomes 3
            // The value in d remains unaffected
            i = (int)d;

            Console.WriteLine(i);
            Console.WriteLine(d);

            // This converts the double d with a value of 3.9 to int i
            // Here the value in i is rounded up to 4
            i = Convert.ToInt32(d);
            Console.WriteLine(i);

            // When the value is half way between to integers the
            // value is rounded to the nearest even integer so
            // 3.5 is rounded up to 4 and 4.5 down to 4
            // Here the value in i is rounded up to 4

            i = Convert.ToInt32(3.5);
            Console.WriteLine(i);

            i = Convert.ToInt32(4.5);
            Console.WriteLine(i);

            // The math class provides a number of math functions
            // one of which is Math.Round. The default rounding here
            // is the same as for Convert.ToInt32. The result is
            // a double so a cast to an int is also required

            i = (int)Math.Round(3.5);
            Console.WriteLine(i);

            i = (int)Math.Round(4.5);
            Console.WriteLine(i);

            // Math.Round with option to always round down
            // this time 3.5 becomes 3

            i = (int)Math.Round(3.5, MidpointRounding.ToZero);
            Console.WriteLine(i);
        }
    }
}

// The example writes the following to the console
// 3
// 3.9
// 4
// 4
// 4
// 4
// 4
// 3
</code></pre>
                    <p>To perform an explicit conversion between types, use the cast expression <code>(T)E</code>. If no conversion exists from <code>E</code> to
                        <code>T</code> a compile error will occur. It also may be possible that a conversion error is not detected until the code containing it is
                        executed during runtime in which case an <a href="#Exception">exception</a> will be thrown.</p>
<pre><code>using System;

namespace ExplicitConversion
{
    class Program
    {
        static void Main(string[] args)
        {
            // conversion from double to int results in truncation
            int number = (int)7 / 2; // number has value of 3

            Console.WriteLine(number);

            // Syntax error, cannot convert type 'int' to 'string'
            // string s = (string)number;
        }
    }
}

// The example writes the following to the console
// 3
</code></pre>
                    <!-- !SECTION Type conversion -->
                </article>
            </section>
            <!-- !SECTION Variables, Constants, Types and Literals -->
            <!-- SECTION Characters and Strings -->
            <section class="main-section" id="Characters_and_Strings">
                <header><h2>Characters and Strings</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION Characters -->
                    <h3 id="Characters">Characters</h3>
                    <p>The <code>char</code> type represents a single Unicode UTF-16 character and can consists of one of:</p>
                    <ul>
                        <li>Single character literal</li>
                        <li>Simple escape sequence</li>
                        <li>Unicode character escape sequence</li>
                        <li>ASCII character escape sequence in octal notation</li>
                        <li>ASCII character escape sequence in hexadecimal notation</li>
                        <li>Unicode character escape sequence in hexadecimal notation</li>
                    </ul>
                    <p>Character literals consists of a single character in a pair of single quotes, such as <code>'a'</code>. Escape sequences consist of a single
                        backslash followed by a sequence fo characters as defined in <a href="#Character_specifications">Character specifications</a>.</p>
                    <p>The following example demonstrates declaring and using a character</p>
<pre><code>using System;

namespace Characters
{
    class Program
    {
        static void Main(string[] args)
        {
            // character1 is declared and assigned the character 'a'
            char character1 = 'a';

            // tab is declared and assigned the simple escape
            // character for the horizontal tab character
            char tab = '\t';

            // character2 is declared and assigned the character 'b'
            // by using the Unicode escape sequence for 'b'
            char character2 = '\u0062';

            // Write all characters to the console
            Console.Write(character1);
            Console.Write(tab);
            Console.Write(character2);
        }
    }
}

// The example writes the following to the console
// a       b
</code></pre>
                    <!-- !SECTION Characters -->
<!-- TODO Add info somewhere about creating datetime and ToString("C", CultureInfo.CurrentCulture) -->
                    <!-- SECTION Strings -->
                    <h3 id="Strings">Strings</h3>
                    <p>A string is a sequence of Unicode (UTF-16) characters that represent text. The maximum length of a string is based on a memory size of 2GB which
                        is approximately 1 billion characters. String literals can be regular or verbatim and/or interpolated. Each can contain zero or more characters
                        enclosed in a pair of double quotes.</p>
                    <p>Regular string literals can contain escaped characters. They can't span multiple lines so to split a statement with a long string literal across
                        two or more lines, each part of the string on each line must first be enclosed in a pair of double quotes. The <code>+</code> concatenation
                        operator is then placed between each string to join them together.</p>
                    <p>Verbatim string literals are prefixed with the verbatim identifier <code>@</code>. Any escaped character will be interpreted verbatim except
                        <code>'\"'</code> which will be interpreted as one double quote. Verbatim string literals can span multiple lines. There must be no white space
                        between the <code>@</code> character and the string.</p>
                    <p>Interpolated strings are prefixed with the interpolation identifier <code>$</code> which indicates that they may contain <i>interpolation
                        expressions</i>. These can contain variables and other special characters that instruct the compiler how to format the string at
                        <span class="nowrap">runtime</span>. Interpolation expressions are wrapped in a pair of braces. There must be no white space between the
                        <code>$</code> identifier and the string. To use a brace as a character in an interpolated string two braces <code>{{</code> or
                        <code>}}</code> must be used. Interpolation expressions include a vast range of options, information of which can be found in the
                        <a href="#References">Microsoft Reference Documentation</a></p>
                    <p>The interpolation identifier can be used in conjunction with the verbatim identifier and the order of the identifiers doesn't matter.</p>
                    <p>Following are examples of string usage.</p>
<pre><code>using System;

namespace CharactersAndStrings
{
    class Program
    {
        static void Main(string[] args)
        {
            // Get the current date and time
            var now = DateTime.Now;
            Console.WriteLine("Regular string");
            Console.WriteLine(@"Verbatim string");
            Console.WriteLine("Regular string with an escaped \t tab");
            Console.WriteLine(@"Verbatim string with an escaped \t tab");
            Console.WriteLine("Sally said to say \"Hi\" to you");
            Console.WriteLine(@"Sally said to say ""Hi"" to you");
            Console.WriteLine("\\\\server\\folder\\file.exe");
            Console.WriteLine(@"\\server\folder\file.exe");
            // The following three lines are concatenated
            // through use of the + operator
            Console.WriteLine("Regular string " +
                "Hello " +
                        "world");
            Console.WriteLine(@"The verbatim string
        will appear as it is
                    written in code");
            int number = 123;
            Console.WriteLine($"The number is {number}");
            Console.WriteLine($"Opening brace {{ closing brace }}");
            Console.WriteLine(@$"Today is {now.DayOfWeek}
its now {now:HH:mm}");

            //// Compile error: Can't split regular string across two lines
            //var k = "Hello
            //            world";

            // Create a variable that is set to Environment.NewLine
            // and use it in an interpolated string to write a
            // blank line before the next line of text
            var nl = Environment.NewLine;
            Console.WriteLine($"{nl}This sentence is written after a blank line");
        }
    }
}

// The example writes the following to the console
// Regular string
// Verbatim string
// Regular string with an escaped   tab
// Verbatim string with an escaped \t tab
// Sally said to say "Hi" to you
// Sally said to say "Hi" to you
// \\server\folder\file.exe
// \\server\folder\file.exe
// Regular string Hello world
// The verbatim string
//         will appear as it is
//                     written in code
// The number is 123
// Opening brace { closing brace }
// Today is Saturday
// its now 19:32

// This sentence is written after a blank line
</code></pre>
                    <!-- !SECTION Strings -->
                    <!-- SECTION String immutability and StringBuilder -->
                    <h3 id="String_immutability_and_StringBuilder">String immutability and StringBuilder</h3>
                    <p>Strings are immutable, that is once created they cannot be changed. C# operators that appear to change a string actually creates a new modified
                        copy of the original string. This means that the performance of a program can suffer when a string is repeatedly manipulated. In these cases
                        C# provides StringBuilder which like a string, also represents a sequence of characters but unlike a string is mutable allowing changes to the
                        sequence. When the operations to the StringBuilder sequence have been completed it can be converted to a string.</p>
                    <p>The following example demonstrates how to use StringBuilder</p>
<pre><code>using System;
using System.Text;

namespace StringBuilderExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // Create a new instance of StringBuilder
            StringBuilder builder = new();
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");
            builder.AppendLine("Hello World");

            // Convert the StringBuilder sequence to a string
            String message = builder.ToString();

            // Write the string to the console;
            Console.WriteLine(message);
        }
    }
}

// The example writes the following to the console
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World
</code></pre>
                    <!-- !SECTION String immutability and StringBuilder -->
                </article>
            </section>
            <!-- !SECTION Characters and Strings -->
            <!-- SECTION Expressions and Operators -->
            <section class="main-section" id="Expressions_and_Operators">
                <header><h2>Expressions and Operators</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>An expression is a collection of operands and operators that together can be evaluated and assigned to a variable. If the evaluation is invalid the
                        result won't be assigned and the variable's value will remain unchanged. This may also result in an exception that can end the program. Following
                        are examples of expressions and operators.</p>
                    <!-- SECTION Expression example -->
                    <h3 id="Expression_example">Expression example</h3>
                    <p>Here <code>1</code> and <code>2</code> are operands and <code>+</code> is the operator</p>
<pre><code>int i = 1 + 2;
</code></pre>
                    <p>Following is a list of expressions that demonstrates the result of the operators. The examples are shown in order of arithmetic precedence.
                        Round brackets <code>( )</code> can be used to change the order.</p>
                    <!-- !SECTION Expression example -->
                    <!-- SECTION Assignment operator -->
                    <h3 id="Assignment_operator">Assignment operator <code>=</code></h3>
                    <p>Assigns a value to a variable</p>
<pre><code>using System;

namespace AssignmentOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            // assigns literal value 1 to int type variable a
            int a = 1;
            Console.WriteLine($"a = {a}");
        }
    }
}

// The example prints the following to the console
// a = 1
</code></pre>
                    <!-- !SECTION Assignment operator -->
                    <!-- SECTION Equality operators -->
                    <h3 id="Equality_operators">Equality operators</h3>
                    <p>Evaluates whether two operands are equal</p>
<pre><code>using System;

namespace EqualityOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            int b = 1;

            // equality operator: ==
            // evaluates if two value types are equal
            bool x = a == b;
            Console.WriteLine($"x = {x}");

            // inequality operator: !=
            // evaluates if two value types are not equal
            bool y = a != b;
            Console.WriteLine($"y = {y}");
        }
    }
}

// The example prints the following to the console
// x = True
// y = False
</code></pre>
                    <!-- !SECTION Equality operators -->
                    <!-- SECTION Comparison operators -->
                    <h3 id="Comparison_operators">Comparison operators</h3>
                    <p>Compares the values of two operands</p>
<pre><code>using System;

namespace ComparisonOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            int b = 2;

            // less than operator: &lt;
            // evaluates if the left operand is less than the right
            bool w = a &lt; b;
            Console.WriteLine($"w = {w}");

            // greater than operator: &gt;
            // evaluates if the left operand is greater than right
            bool x = a &gt; b;
            Console.WriteLine($"x = {x}");

            // less than or equal to operator: &lt;=
            // evaluates if the left operand is less than or equal to the right
            bool y = a &lt;= b;
            Console.WriteLine($"y = {y}");

            // greater than or equal to operator: &gt;=
            // evaluates if the left operand is greater than or equal to the right
            bool z = a &gt;= b;
            Console.WriteLine($"z = {z}");
        }
    }
}

// The example prints the following to the console
// w = True
// x = False
// y = True
// z = False
</code></pre>
                    <!-- !SECTION Comparison operators -->
                    <!-- SECTION Arithmetic operators -->
                    <h3 id="Arithmetic_operators">Arithmetic operators</h3>
                    <p>Appliers an arithmetical operation between two operands</p>
<pre><code>using System;

namespace ArithmeticOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 3;
            int b = 3;
            int c = 3;
            int d = 3;

            // postfix increment operator: x++
            // after assigning a's value to e adds 1 to a
            int e = a++;
            Console.WriteLine($"a = {a}, e = {e}");

            // postfix decrement operator: x--
            // after assigning b's value to f subtracts 1 from b
            int f = b--;
            Console.WriteLine($"b = {b}, f = {f}");

            // prefix increment operator: ++x
            // adds 1 to c then assigns c's value to g
            int g = ++c;
            Console.WriteLine($"c = {c}, g = {g}");

            // prefix decrement operator: --x
            // subtracts 1 from d then assigns d's value to h
            int h = --d;
            Console.WriteLine($"d = {d}, h = {h}");

            // unary minus operator: -
            // sign of -2 is changed and i has value 2
            int i = - -2;
            Console.WriteLine($"i = {i}");

            // multiplication operator: *
            // multiplies 3 by 2
            int j = 3 * 2;
            Console.WriteLine($"j = {j}");

            // The division operator rounds towards 0 when both operators are integers

            // division operator: /
            // divides 3 by 2
            double k = 3 / 2;
            Console.WriteLine($"k = {k}");

            // division operator: /
            // divides 3 by 2
            double l = -3 / 2;
            Console.WriteLine($"l = {l}");

            // division operator: /
            // divides 3 by double 2
            double m = 3 / 2d;
            Console.WriteLine($"m = {m}");

            // remainder operator, also called the modulus operator: %
            // returns the remainder after dividing 3 by 2
            int n = 3 % 2;
            Console.WriteLine($"n = {n}");

            // addition operator: +
            // adds 2 to 3
            int o = 3 + 2;
            Console.WriteLine($"o = {o}");

            // subtraction operator: -
            // subtracts 2 from 3
            int p = 3 - 2;
            Console.WriteLine($"p = {p}");
        }
    }
}

// The example prints the following to the console
// a = 4, e = 3
// b = 2, f = 3
// c = 4, g = 4
// d = 2, h = 2
// i = 2
// j = 6
// k = 1
// l = -1
// m = 1.5
// n = 1
// o = 5
// p = 1
</code></pre>
                    <!-- !SECTION Arithmetic operators -->
                    <!-- SECTION Boolean logic operators -->
                    <h3 id="Boolean_logic_operators">Boolean logic operators</h3>
                    <p>Appliers an boolean logic operation between two operands</p>
<pre><code>using System;

namespace BooleanLogicOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            bool a = true;
            bool b = false;

            // negation operator: !
            // inverts the boolean value
            bool c = !a;
            Console.WriteLine($"c = {c}");
            bool d = !b;
            Console.WriteLine($"d = {d}");

            // and operator: &
            // returns true only if both operands are true
            bool e = a &amp; a;
            Console.WriteLine($"e = {e}");
            bool f = a &amp; b;
            Console.WriteLine($"f = {f}");
            bool g = b &amp; a;
            Console.WriteLine($"g = {g}");
            bool h = b &amp; b;
            Console.WriteLine($"h = {h}");

            // exclusive or operator: ^
            // returns true if only one operand is true
            bool i = a ^ a;
            Console.WriteLine($"i = {i}");
            bool j = a ^ b;
            Console.WriteLine($"j = {j}");
            bool k = b ^ a;
            Console.WriteLine($"k = {k}");
            bool l = b ^ b;
            Console.WriteLine($"l = {l}");

            // or operator: |
            // returns true if either operand is true
            bool m = a | a;
            Console.WriteLine($"m = {m}");
            bool n = a | b;
            Console.WriteLine($"n = {n}");
            bool o = b | a;
            Console.WriteLine($"o = {o}");
            bool p = b | b;
            Console.WriteLine($"p = {p}");
        }
    }
}

// The example prints the following to the console
// c = False
// d = True
// e = True
// f = False
// g = False
// h = False
// i = False
// j = True
// k = True
// l = False
// m = True
// n = True
// o = True
// p = False
</code></pre>
                    <!-- !SECTION Boolean logic operators -->
                    <!-- SECTION Compound assignment operators -->
                    <h3 id="Compound_assignment_operators">Compound assignment operators</h3>
                    <p>An expression using an operator <code>op</code> in the form <code>x op= y</code> is equivalent to <code>x = x op y</code></p>
<pre><code>using System;

namespace CompoundAssignmentOperators
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 6;
            int b = 6;
            int c = 6;
            int d = 6;

            // compound operator: +=
            // adds 1 to a's current value 6 and assigns it back to a
            a += 1;
            Console.WriteLine($"a = {a}");

            // compound operator: -=
            // subtracts 1 from b's current value 6 and assigns it back to b
            b -= 1;
            Console.WriteLine($"b = {b}");

            // compound operator: *=
            // multiplies c's current value 6 by 2 and assigns it back to c
            c *= 2;
            Console.WriteLine($"c = {c}");

            // compound operator: /=
            // divides d's current value 6 by 2 and assigns it back to d
            d /= 2;
            Console.WriteLine($"d = {d}");

            bool e = true;
            bool f = true;
            bool g = true;

            // compound operator: &=
            // evaluates a logical 'and' with r's current value assigns it back to b
            e &= false;
            Console.WriteLine($"e = {e}");

            // compound operator: |=
            // evaluates a logical 'or' with f's current value assigns it back to b
            f |= true;
            Console.WriteLine($"f = {f}");

            // compound operator: ^=
            g ^= false;
            Console.WriteLine($"g = {g}");
        }
    }
}

// The example prints the following to the console
// a = 7
// b = 5
// c = 12
// d = 3
// e = False
// f = True
// g = True
</code></pre>
                    <!-- !SECTION Compound assignment operators -->
                    <!-- SECTION Conditional operator -->
                    <h3 id="Conditional_operator">Conditional operator <code>?:</code></h3>
                    <p>The conditional operator <code>?:</code>, also known as the ternary conditional operator takes the form <code>x = predicate ? a : b</code>. If the
                        predicate is true then the expression returns <code>a</code> else it returns <code>b</code>. Both <code>a</code> and <code>b</code> must be of the
                        same type. The conditional operator can also be used as a shorthand way to replace combined <code>if</code> and <code>else</code> statements.
                        Conditional statements can be nested though doing so can make the code hard to read.</p>
<pre><code>using System;

namespace ConditionalOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;

            string x = a == 1 ? "Yes" : "No";
            Console.WriteLine($"x = {x}");

            string y = a == 2 ? "Yes" : "No";
            Console.WriteLine($"y = {y}");
        }
    }
}

// The example prints the following to the console
// x = Yes
// y = No
</code></pre>
                    <!-- !SECTION Conditional operator -->
                    <!-- SECTION Conditional and operator -->
                    <h3 id="Conditional_and_operator">Conditional 'and' operator <code>&&</code></h3>
                    <p>In the expression <code>x = a && b</code> <code>x</code> is true if both <code>a</code> and <code>b</code> are true otherwise <code>x</code> is
                        false. If <code>a</code> is false <code>b</code> is not evaluated. This is useful in a situation where, if <code>a</code> is false evaluating
                        <code>b</code> would produce an invalid condition that could result in an exception.</p>
<pre><code>using System;

namespace ConditionalAndOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            int b = 1;
            int c = 0;

            // a == 1 is true so b == 1 is also evaluated
            bool x = a == 1 && b == 1;
            Console.WriteLine($"x = {x}");

            // c == 1 is true so b == 1 is not evaluated
            bool y = c == 1 && b == 1;
            Console.WriteLine($"y = {y}");

            // c != 0 is false so a == b / c is not evaluated
            // which prevents a divide by 0 exception
            bool z = c != 0 && a == b / c;
            Console.WriteLine($"z = {z}");
        }
    }
}

// The example prints the following to the console
// x = True
// y = False
// z = False
</code></pre>
                    <!-- !SECTION Conditional and operator -->
                    <!-- SECTION Conditional or operator -->
                    <h3 id="Conditional_or_operator">Conditional 'or' operator <code>||</code></h3>
                    <p>In the expression <code>x = a || b</code>, <code>x</code> is true if either <code>a</code> or <code>b</code> are true otherwise <code>x</code> is
                        false. If <code>a</code> is true <code>b</code> is not evaluated. This is useful in a situation where, if <code>a</code> is true evaluating
                        <code>b</code> would produce an invalid condition that could result in an exception.</p>
<pre><code>using System;

namespace ConditionalOrOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            int b = 1;
            int c = 0;

            // a == 1 is true so b == 1 is not evaluated
            bool x = a == 1 || b == 0;
            Console.WriteLine($"x = {x}");

            // c == 1 is false so b == 1 is evaluated
            bool y = c == 1 || c == 1;
            Console.WriteLine($"y = {y}");

            // c == 0 is true so a == b / c is not evaluated
            // which prevents a divide by 0 exception
            bool z = c == 0 || a == b / c;
            Console.WriteLine($"z = {z}");
        }
    }
}

// The example prints the following to the console
// x = True
// y = False
// z = True
</code></pre>
                    <!-- !SECTION Conditional or operator -->
                    <!-- SECTION The null-coalescing operator -->
                    <h3 id="The_null-coalescing_operator">The null-coalescing operator <code>??</code></h3>
                    <p>The null-coalescing operator <code>??</code> returns the left-hand operand if it not null otherwise it evaluates the right-hand expression and
                        returns the result</p>
<pre><code>using System;

namespace NullCoalescingOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int? a = null;
            int x = a ?? 2;
            Console.WriteLine($"x = {x}");

            int? b = 1;
            int y = b ?? 2;
            Console.WriteLine($"y = {y}");
        }
    }
}

// The example prints the following to the console
// x = 2
// y = 1
</code></pre>
                    <!-- !SECTION The null-coalescing operator -->
                    <!-- SECTION The null-coalescing assignment operator -->
                    <h3 id="The_null-coalescing_assignment_operator">The null-coalescing assignment operator <code>??=</code></h3>
                    <p>The null-coalescing assignment operator <code>??=</code> evaluates and assigns the-right hand expression to the left-hand variable only if the
                        variable is null</p>
<pre><code>using System;

namespace NullCoalescingAssignmentOperator
{
    class Program
    {
        static void Main(string[] args)
        {
            int? a = null;
            a ??= 2;
            Console.WriteLine($"a = {a}");

            int? b = 1;
            b ??= 2;
            Console.WriteLine($"b = {b}");
        }
    }
}

// The example prints the following to the console
// a = 2
// b = 1
</code></pre>
                    <!-- !SECTION The null-coalescing assignment operator -->
                    <!-- SECTION The Lambda and expression body definition operator -->
                    <h3 id="The_lambda_and_expression-body_definition_operator">The lambda and expression-body definition operator <code>=&gt;</code></h3>
                    <p>The <code>=&gt;</code> operator has two uses, as part of a <i>lambda expression</i> or an <i>expression-bodied member</i> definition.</p>
                    <p>A lambda expression is comprised of a set of input parameters on the left which are then passed into the body on the right which are separated
                        using the <code>=&gt;</code> operator. They are used to create <a href="#Anonymous_functions">anonymous functions</a>.</p>
                    <p>An expression-bodied member definition provides a shorthand method of writing the body of a member. In this case the <code>=&gt;</code> operator is
                        used to separate the name of the member and its body which can only contain a single expression. Supported members are:</p>
                    <ul>
                        <li><a href="#Constructors">Constructors</a></li>
                        <li><a href="#Properties">Read-only Properties</a></li>
                        <li><a href="#Properties">Property accessors</a></li>
                        <li><a href="#Indexers">Indexers</a></li>
                        <li><a href="#Methods">Methods</a></li>
                        <li><a href="#Finalizers">Finalizers</a></li>
                    </ul>
                    <!-- !SECTION The Lambda and expression body definition operator -->
<!-- TODO add info about operator -->
                    <!-- SECTION Namespace alias qualifier operator -->
                    <h3 id="Namespace_alias_qualifier_operator">Namespace alias qualifier operator ::</h3>
                    <p>Explanation</p>
                    <p>CodeExample</p>
<pre><code>using System;

namespace Namespace
{
    class Program
    {
        static void Main()
        {

        }
    }
}
</code></pre>
                    <!-- !SECTION Namespace alias qualifier operator -->
                </article>
            </section>
            <!-- !SECTION Expressions and Operators -->
            <!-- SECTION Decision Making Statements -->
            <section class="main-section" id="Decision_Making_Statements">
                <header><h2>Decision Making Statements</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION if else statements -->
                    <h3 id="if_else_statements">if else statements</h3>
                    <p>The <code>if</code> and <code>else</code> statements allow the program execution to branch in one of two directions based on a condition.</p>
<pre><code>using System;

namespace IfElse
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 1;
            if (a == 1)
            {
                Console.WriteLine("a equals 1");
            }
            else
            {
                Console.WriteLine("a does not equal 1");
            }
        }
    }
}

// The example prints the following to the console
// a equals 1
</code></pre>
                    <!-- !SECTION if else statements -->
                    <!-- SECTION switch statement -->
                    <h3 id="switch_statement">switch statement</h3>
                    <p>The <code>switch</code> statement allows for program execution to branch in one of multiple directions based on a condition.</p>
<pre><code>using System;

namespace Switch
{
    class Program
    {
        static void Main(string[] args)
        {
            int a = 5;
            switch (a)
            {
                case 0:
                    Console.WriteLine("none");
                    break;
                case 1:
                    Console.WriteLine("one");
                    break;
                default:
                    Console.WriteLine("many");
                    break;
            }
        }
    }
}

// The example prints the following to the console
// many
</code></pre>
                    <!-- !SECTION switch statement -->
                </article>
            </section>
            <!-- !SECTION Decision Making Statements -->
            <!-- SECTION Iteration Statements -->
            <section class="main-section" id="Iteration_Statements">
                <header><h2>Iteration Statements</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Iteration statements, also known as loop statements, allow the execution of a code block to be repeated until an exit condition is met.</p>
                    <!-- SECTION while statement -->
                    <h3 id="while_statement">while statement</h3>
                    <p>The <code>while</code> statement iterates until a condition is met. If the condition already exists, program execution won't enter the
                        <code>while</code> loop.</p>
<pre><code>using System;

namespace WhileLoop
{
    class Program
    {
        static void Main(string[] args)
        {
            int i = 0;
            while (i &lt; 10)
            {
                Console.Write(i);
                i++;
            }
        }
    }
}

// The example prints the following to the console
// 0123456789
</code></pre>
                    <!-- !SECTION while statement -->
                    <!-- SECTION do statement -->
                    <h3 id="do_statement">do statement</h3>
                    <p>The <code>do</code> statement iterates until a condition is met. At least one iteration of the <code>do</code> loop is guaranteed to be executed
                        before testing for the condition.</p>
<pre><code>using System;

namespace DoWhileLoop
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Type some text then press enter to repeat what you wrote");
            Console.WriteLine("Press enter without typing text to end the program");
            Console.WriteLine();
            string s = "";
            do
            {
                s = Console.ReadLine();
                Console.WriteLine(s);
                Console.WriteLine();
            } while (!string.IsNullOrEmpty(s));
        }
    }
}

// Repeats text until enter is pressed after not writing text
</code></pre>
                    <!-- !SECTION do statement -->
                    <!-- SECTION for statement -->
                    <h3 id="for_statement">for statement</h3>
                    <p>The <code>for</code> statement iterates a set number of times based on an exit condition.</p>
<pre><code>using System;

namespace ForLoop
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i &lt; 10; i++)
            {
                Console.Write(i);
            }
        }
    }
}

// The example prints the following to the console
// 0123456789
</code></pre>
                    <!-- !SECTION for statement -->
                    <!-- SECTION foreach statement -->
                    <h3 id="foreach_statement">foreach statement</h3>
                    <p>The <code>foreach</code> statement iterates through all members of a collection.</p>
<pre><code>using System;

namespace ForEachLoop
{
    class Program
    {
        static void Main(string[] args)
        {
            string s = "Hello world!";
            foreach (char c in s)
            {
                Console.Write(c + " ");
            }
        }
    }
}

// The example prints the following to the console
// H e l l o   w o r l d !
</code></pre>
                    <!-- !SECTION foreach statement -->
                    <!-- SECTION break -->
                    <h3 id="break">break</h3>
                    <p>The <code>break</code> keyword gives you a way of conditionally exiting a loop before completion.</p>
<pre><code>using System;

namespace Break
{
    class Program
    {
        static void Main(string[] args)
        {
            string s = "Hello world!";
            foreach (char c in s)
            {
                Console.Write(c + " ");
                if (c == ' ')
                    break;
            }
        }
    }
}

// The example prints the following to the console
// H e l l o
</code></pre>
                    <!-- !SECTION break -->
                    <!-- SECTION continue -->
                    <h3 id="continue">continue</h3>
                    <p>The <code>continue</code> keyword gives you a way of conditionally skipping an iteration. The following example uses the <code>%</code> operator in
                        conjunction with the <code>continue</code> keyword to skip all even numbers.</p>
<pre><code>using System;

namespace Continue
{
    class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i &lt; 10; i++)
            {
                // for loop skips current iteration if i is 5
                if (i % 2 == 0)
                    continue;
                Console.Write(i);
            }
        }
    }
}

// The example prints the following to the console
//  13579
</code></pre>
                    <!-- !SECTION continue -->
                </article>
            </section>
            <!-- !SECTION Iteration Statements -->
            <!-- SECTION Arrays and Data Structures -->
            <section class="main-section" id="Arrays_and_Data_Structures">
                <header><h2>Arrays and Data Structures</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Arrays and data structures store multiple variables together in ways that allows them to be handled and manipulated more efficiently.</p>
                    <!-- SECTION Array -->
                    <h3 id="Array">Array</h3>
                    <p>An array is like a box with separate compartments in which only one item called an <i>element</i> can be stored in each. They can be
                        single-dimensional,  multi-dimensional or jagged and all items must be of the same type. A single-dimensional array is like  one row  of
                        compartments. A multidimensional array can contain rows, columns or more up to a maximum of 32 dimensions. A jagged array is like storing a
                        separate box within each compartment of the first where each one could have its own set of dimensions with different sizes. A jagged array is
                        sometimes called an array of arrays. In addition to the examples shown here C# also provides the <i>Array</i> class which provides a set of
                        methods for manipulating arrays, information of which can be found in the <a href="#References">C# reference documentation</a>.</p>
                    <!-- !SECTION Array -->
                    <!-- SECTION Declaring, creating and initializing arrays -->
                    <h3 id="Declaring,_creating_and_initializing_arrays">Declaring, creating and initializing arrays</h3>
                    <p>An array is immutable which means that the number of dimensions and elements or <i>Length</i> of an array must be declared when the array is
                        created and can't be changed. An array can be recreated by using the <code>new</code> keyword which deletes and replaces the existing array
                        <em>and its data</em> with a new one. There are a number of different ways in which to create an array which can also include initializing the
                        element values. If not initialized the default value for the elements in a single-dimensional or multi-dimensional array will be 0 for numeric
                        types and null for reference types. As a jagged array stores other arrays the default type is always null.</p>
                        <p>The following example demonstrates the declaration and initialization of an array.</p>
<pre><code>using System;

namespace Arrays
{
    class Program
    {
        static void Main(string[] args)
        {
            // Declare an array of type 'string' with the name stringArray
            // stringArray will be null
            string[] stringArray;

            // Declare an array of type 'int' with the name arr1
            // arr1 will be null
            int[] arr1;

            // Create a new array arr1 with 5 elements
            // Each element will have the default value 0
            arr1 = new int[5];

            // Create a new array arr1 of length 6
            // Each element will have the default value 0
            // The previous array with 5 elements and their
            // values are deleted from memory
            arr1 = new int[6];

            // Declare and create an array of length 7.
            // Each element will have the default value of 0
            int[] arr2 = new int[7];

            // Declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 3 and 4 respectively
            int[] arr3 = new int[2] { 3, 4 };

            // Another syntax to declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 8 and 9 respectively
            int[] arr4 = new[] { 8, 9 };

            // Yet another syntax to declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 10 and 11 respectively
            int[] arr5 = { 10, 11 };

            // var can be used in place of int[] in the syntax of
            // arr2, arr3 and arr4 but not arr5

            // Declare and create an array of length 7.
            // Each element will have the default value of 0
            var arr6 = new int[7];

            // Declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 3 and 4 respectively
            var arr7 = new int[2] { 3, 4 };

            // Another syntax to declare, create and initialize an array of length 2.
            // Elements at indexes 0 and 1 will have the values 8 and 9 respectively
            var arr8 = new[] { 8, 9 };

            // Syntax error, 'var' can't be used with an array initializer
            //var arr9 = { 11, 12 };

            // Declare, create and initialize an array of type 'string'
            // called with a length of 3
            string[] arr10 = new string[3] { "red", "green", "blue" };

            // Several ways to declare an empty array. The array will not be null
            // but will not be able to store any elements. An empty array has
            // very little uses and most can now replaced by newer data structure types
            int[] emptyArray1 = { };
            int[] emptyArray2 = new int[] { };
            int[] emptyArray3 = new int[0];
            int[] emptyArray4 = Array.Empty&lt;int&gt;();

            // Declare a multi-dimensional array with 2 dimensions
            int[,] arr11;

            // Create a 2 dimensional array of length 4 in the first
            // and length 2 in the second. You can think of this as having
            // 4 rows and 2 columns
            arr11 = new int[4, 2];

            // Create and initialize a 2 dimensional array
            arr11 = new int[4, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };

            // Create and initialize a 2 dimensional array
            // Here the lengths are inferred from
            // from the block inside the braces
            arr11 = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 }, { 7, 8 } };

            // Declare, create and initialize a 2 dimensional string array
            string[,] arr12 = new string[3, 2] { { "red", "cyan" }, { "green", "magenta" }, { "blue", "yellow" } };

            // Declare, create and initialize a 3 dimensional 'int' array
            // This will create an array with dimensions [2, 2, 3]
            int[,,] arr13 = new int[,,] { { { 1, 2, 3 }, { 4, 5, 6 } }, { { 7, 8, 9 }, { 10, 11, 12 } } };

            // Declares and creates a jagged array. The first array
            // is a single-dimensional array with 3 elements
            // each of which is a 2 dimensional array
            int[][,] arr14 = new int[3][,];

            // Each single-dimensional element of arr13 must also
            // be created before it can be used
            arr14[0] = new int[1, 2];
            arr14[1] = new int[2, 3];
            arr14[2] = new int[4, 5];

            // An array within a jagged array can also be initialized
            arr14[1] = new int[2, 3] { { 1, 2, 3 }, { 4, 5, 6 } };

            // Yet another syntax for initializing a jagged array
            int[][] arr16 =
            {
                new int[] { 1, 2, 3, 4 },
                new int[] { 5, 6, 7 },
                new int[] { 8, 9 }
            };
        }
    }
}
</code></pre>
                    <!-- !SECTION Declaring, creating and initializing arrays -->
                    <!-- SECTION Accessing arrays -->
                    <h3 id="Accessing_arrays">Accessing arrays</h3>
                    <p>Arrays are normally zero index based so the elements in a dimension of length n will be accessed by index values of 0 through n-1. Whilst it is
                        possible to create an array that is not zero based its use is rare.</p>
                    <p>The following example demonstrates how to access an array.</p>
<pre><code>using System;

namespace ArrayAccess
{
    class Program
    {
        static void Main(string[] args)
        {
            // Each element in array is accessed using an 'int' type
            // index which is zero based. For an array of length 3
            // the index values for the elements are 0, 1 and 2.
            // To obtain and element specify the index  within
            // square brackets
            string[] colors = { "red", "green", "blue" };
            Console.WriteLine($"{colors[0]}, {colors[1]}, {colors[2]}");

            // To assign a value to an element use the assignment operator '='
            colors[0] = "cyan";
            colors[1] = "magenta";
            colors[2] = "yellow";

            // The total number of elements of an array can be found by using
            // the Length property 'array.Length'.
            Console.WriteLine($"The array colors has {colors.Length} elements");

            // Attempting to access an array with an index value less than 0
            // or more than the length - 1 will result in an
            // IndexOutOfRange exception and the program will stop
            // Uncomment the following line will demonstrate this error
            // Console.WriteLine(colors[3]);

            // As the array indexes
            // are 0 based the elements can be accessed using a 'for' loop
            for (int i = 0; i &lt; colors.Length; i++)
            {
                Console.Write($"{colors[i]} ");
            }
            Console.WriteLine();

            // Additionally the elements can be accessed using a 'foreach' loop
            foreach (var color in colors)
            {
                Console.Write($"{color} ");
            }
            Console.WriteLine();

            // Accessing the elements within a multi-dimensional array
            // is similar to a single-dimensional array using one
            // 'int' type index for each dimension
            int[,] numbers = new int[3, 2] { { 1, 2 }, { 3, 4 }, { 5, 6 } };
            Console.WriteLine($"{numbers[0, 0]} {numbers[0, 1]} {numbers[1, 0]} " +
                                $"{numbers[1, 1]} {numbers[2, 0]} {numbers[2, 1]}");

            // Assigning values to elements in a multi-dimensional
            // is also similar to a single-dimensional array using one
            // 'int' type index for each dimension
            numbers[0, 0] = 6;
            numbers[0, 1] = 5;
            numbers[1, 0] = 4;
            numbers[1, 1] = 3;
            numbers[2, 0] = 2;
            numbers[2, 1] = 1;

            // Looping through a multi-dimensional array can be
            // done using nested for loops, one for each dimension
            // To obtain the length for a given dimension the
            // GetLength() is used 'array.GetLength(dimensionIndex)'
            for (int i = 0; i &lt; numbers.GetLength(0); i++)
            {
                for (int j = 0; j &lt; numbers.GetLength(1); j++)
                {
                    Console.Write($"{numbers[i, j]} ");
                }
            }
            Console.WriteLine();

            // The foreach loop can also be used for multi-dimensional arrays
            // however nested for loops allow you traverse an array in any
            // order you require
            foreach (var number in numbers)
            {
                Console.Write($"{number} ");
            }
            Console.WriteLine();

            // The number of dimensions of an array
            // can be found using the Rank property 'array.Rank'.
            Console.WriteLine($"numbers has {numbers.Rank} dimensions");
            var total = 1;
            for (int i = 0; i &lt; numbers.Rank; i++)
            {
                Console.WriteLine($"numbers[{i}] has {numbers.GetLength(i)} elements");
                total *= numbers.GetLength(i);
            }
            Console.WriteLine($"Numbers has a total {total} of elements which is the same as Numbers.Length: {numbers.Length}");

            // Accessing a jagged array is similar to a multi-dimensional
            // This prints 7 to the console which is the third element [2]
            // of the second array [1] of jaggedArray
            int[][] jaggedArray =
            {
                new int[] {1, 2, 3, 4},
                new int[] {5, 6, 7},
                new int[] {8, 9}
            };
            Console.WriteLine($"{jaggedArray[1][2]}");

            // Assigning values is also similar to multi-dimensional arrays
            // This assigns 42 to the third element [2] of the second array [1]
            // then prints it to the console
            jaggedArray[1][2] = 42;
            Console.WriteLine($"{jaggedArray[1][2]}");

            // This demonstrates looping though a jagged array with for loops
            for (int i = 0; i &lt; jaggedArray.Length; i++)
            {
                Console.Write($"The values in jaggedArray[{i}] are: ");
                for (int j = 0; j &lt; jaggedArray[i].Length; j++)
                {
                    Console.Write($" {jaggedArray[i][j]}");
                }
                Console.WriteLine();
            }

            // Looping through a jagged array with a foreach loop is a bit more
            // complicated as an outer loop is required to get the arrays and an
            // inner loop to get the actual values
            foreach (var arr in jaggedArray)
            {
                foreach (var i in arr)
                {
                    Console.Write($"{i} ");
                }
            }
            Console.WriteLine();
            // This demonstrates the types that are stored in a jagged array
            // The first line prints Int32[] where the square brackets indicate
            // that it is an array of type 'int' whereas the second prints
            // Int32 without square brackets indicating the actual type stored in
            // each array is an 'int'
            Console.WriteLine(jaggedArray[0].GetType().Name);
            Console.WriteLine(jaggedArray[0][0].GetType().Name);
        }
    }
}

// The example prints the following to the console
// red, green, blue
// The array colors has 3 elements
// cyan magenta yellow
// cyan magenta yellow
// 1 2 3 4 5 6
// 6 5 4 3 2 1
// 6 5 4 3 2 1
// numbers has 2 dimensions
// numbers[0] has 3 elements
// numbers[1] has 2 elements
// Numbers has a total 6 of elements which is the same as Numbers.Length: 6
// 7
// 42
// The values in jaggedArray[0] are: 1 2 3 4
// The values in jaggedArray[1] are: 5 6 42
// The values in jaggedArray[2] are: 8 9
// 1 2 3 4 5 6 42 8 9
// Int32[]
// Int32
</code></pre>
                    <!-- !SECTION Accessing arrays -->
                    <!-- SECTION Collections -->
                    <h3 id="Collections">Collections</h3>
                    <p>.NET provides a number of data structures grouped under the category of collections. They provide common functionality such as to add, remove and
                        modify either individual elements or a range of elements.</p>
                    <p>There are two main types of collections, generic an non-generic. Generic collections take in a type parameter making them type safe at compile time
                        which allows IntelliSense to indicate syntax errors. Non-generic collections store items as type <i>object</i> which requires casting when
                        accessing the data within them. Because of this non-generic collections are less commonly used today and are mostly found in legacy code.</p>
                    <p>Following is a list of some common collection types but only examples of <i>List&lt;T&gt;</i> and <i>Dictionary&lt;TKey, TValue&gt;</i>
                        will be discussed in this article.</p>
                    <ul>
                        <li><i>List&lt;T&gt;</i> - A collection of items stored by index</li>
                        <li><i>Dictionary&lt;TKey, TValue&gt;</i> - Used to store items as key/value pairs</li>
                        <li><i>Queue&lt;T&gt;</i> - Items are accessed first in first out (FIFO)</li>
                        <li><i>Stack&lt;T&gt;</i> - Items are accessed last in first out (LIFO)</li>
                        <li><i>LinkedList&lt;T&gt;</i> - Items are accessed sequentially</li>
                        <li><i>ObservableCollection&lt;T&gt;</i> - Provides notification through events when items are added or removed</li>
                        <li><i>SortedList&lt;TKey, TValue&gt;</i> - A sorted collection</li>
                        <li><i>HashSet&lt;T&gt;</i> - A set for mathematical functions</li>
                        <li><i>SortedSet&lt;T&gt;</i> - A sorted set for mathematical functions</li>
                    </ul>
                    <!-- !SECTION Collections -->
<!-- TODO correct anonymous expression and link note -->
                    <!-- SECTION List<T> -->
                    <h4 id="List_T">List&lt;T&gt;</h4>
                    <p>A <i>List&lt;T&gt;</i> is a strongly typed generic collection of objects accessed by an int type <i>index</i>. Unlike an array, a list does
                        not have a fixed size and as such does not have to be declared. It provides a number of useful methods for manipulating its data such as add,
                        remove, sort, find and clear.</p>
                    <p><em>Note:</em> <i>The Find method uses an anonymous expression details of which are in
                            <a href="#Anonymous_functions">Anonymous functions</a></i></p>
                    <p>The following example demonstrates List declaration and use </p>
<pre><code>using System;
using System.Collections.Generic;

namespace Lists
{
    class Program
    {
        static void Main(string[] args)
        {
            var nl = Environment.NewLine;

            // Create a list of strings
            List&lt;string&gt; animals = new();

            // Add items to the list
            animals.Add("dog");
            animals.Add("cat");
            animals.Add("lizard");
            animals.Add("ball");
            animals.Add("emu");
            animals.Add("emu");
            animals.Add("boat");
            animals.Add("salmon");

            // Use a foreach loop to print the items to the console
            Console.WriteLine("A list of animals");
            foreach (var item in animals) { Console.Write(item + " "); }

            // The 'Find' method returns the first item that
            // matches the conditions specified by the
            // predicate in the anonymous expression.
            // (See Anonymous function expressions)
            // If not the default value for type T is returned.
            // 'Remove' removes the specified item
            // This searches for 'boat' and if found removes it
            // from the list
            var notAnAnimal = animals.Find(item =&gt; item == "boat");
            if (notAnAnimal != null)
                animals.Remove(notAnAnimal);
            Console.WriteLine($"{nl}{nl}Find 'boat' then remove it");
            foreach (var item in animals) { Console.Write(item + " "); }

            // Create a variable to store the index value
            int index = 0;

            // 'Contains' returns true is the list contains the item
            // 'IndexOf' returns the index of an item if found
            // or -1 if not. This first confirms the list has 'lizard'
            // then changes 'lizard' to 'duck'
            if (animals.Contains("lizard"))
            {
                index = animals.IndexOf("lizard");
                animals[index] = "duck";
            }
            Console.WriteLine($"{nl}{nl}If list has 'lizard' replace it with 'duck'");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Insert' inserts an item at a specific index
            // This inserts 'shark' at the current index of 'duck'
            // as found from the previous example. All items after
            // and including 'duck' are moved after 'shark'
            animals.Insert(index, "shark");
            Console.WriteLine($"{nl}{nl}Insert 'shark' before 'duck'");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'RemoveAt' removes an at a specified index
            // The following removes 'ball'
            index = animals.IndexOf("ball");
            if (index != 0)
                animals.RemoveAt(index);
            Console.WriteLine($"{nl}{nl}Remove 'ball'");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Remove' removes the first occurrence of a specific item
            // It returns false if the removal was unsuccessful or the
            // item wasn't found. The following removes the first 'emu'
            // then prints the updated list to the console
            var removed = animals.Remove("emu") ? "'emu' was removed" : "'emu' was NOT removed";
            Console.WriteLine($"{nl}{nl}{removed}");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Sort' sorts the list based on the comparer argument
            // passed in. If none is supplied then the default
            // comparer is used. The following alphabetically sorts the list
            animals.Sort();
            Console.WriteLine($"{nl}{nl}Sort the list");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Reverse' reverses the order of the list
            animals.Reverse();
            Console.WriteLine($"{nl}{nl}The list has been reversed");
            foreach (var item in animals) { Console.Write(item + " "); }

            // 'Clear' removes all items from the list
            // The 'Count' property is the number of items the list.
            animals.Clear();
            Console.WriteLine($"{nl}{nl}Clear the list");
            Console.WriteLine($"There are {animals.Count} items in the list");
            Console.WriteLine();
        }
    }
}

// The example writes the following to the console
// dog cat lizard ball emu emu salmon

// If list has 'lizard' replace it with 'duck'
// dog cat duck ball emu emu salmon

// Insert 'shark' before 'duck'
// dog cat shark duck ball emu emu salmon

// Remove 'ball'
// dog cat shark duck emu emu salmon

// 'emu' was removed
// dog cat shark duck emu salmon

// Sort the list
// cat dog duck emu salmon shark

// The list has been reversed
// shark salmon emu duck dog cat

// Clear the list
// There are 0 items in the list
</code></pre>
                    <!-- !SECTION List<T> -->
                    <!-- SECTION Dictionary<TKey, TValue> -->
                    <h4 id="Dictionary_TKey_TValue">Dictionary&lt;TKey, TValue&gt;</h4>
                    <p>A <i>Dictionary&lt;TKey, TValue&gt;</i> is a strongly typed generic collection of <i>KeyValuePair&lt;TKey, TValue&gt;</i> accessed by a <i>key</i>
                        index.  Like a List, a Dictionary does not have a fixed size and as such does not have to be declared. Methods include add, remove, contains,
                        clear.</p>
                    <p>The following example demonstrates Dictionary declaration and use</p>
<pre><code>using System;
using System.Collections.Generic;

namespace Dictionaries
{
    class Program
    {
        static void Main(string[] args)
        {
            var nl = Environment.NewLine;

            // Create a list of strings
            Dictionary&lt;string, int&gt; fruit = new();

            // Add some items
            fruit.Add("Oranges", 6);
            fruit.Add("Pears", 4);
            fruit.Add("Apples", 8);
            fruit.Add("Bananas", 7);
            fruit.Add("Lemons", 3);
            fruit.Add("Peaches", 6);
            fruit.Add("Plums", 6);

            // 'Count' returns the number of items in a Dictionary
            Console.WriteLine($"There are {fruit.Count} fruit items");

            // To use a Dictionary in a foreach loop use
            // KeyValuePair&lt;TKey, TValue&gt;. The types must be the same
            // as that used in the declaration of the dictionary
            foreach (KeyValuePair&lt;string, int&gt; item in fruit)
                Console.Write($"{item.Key} : {item.Value}{nl}");

            // Syntax error, Each item must have a unique 'key'
            //fruit.Add("Plums", 3);

            // 'TryAdd' unlike 'Add' won't result in an
            // exception but will return false if the
            // item could not be added.
            var added = fruit.TryAdd("Plums", 3) ?
                "'Another Plums entry' was added" :
                "'Another Plums entry' could NOT be added";
            Console.WriteLine($"{added}");

            // 'Keys' returns a 'KeyCollection' of all the keys
            // in the Dictionary and will have the same type that
            // was used when declaring it
            var keys = fruit.Keys;
            foreach (var key in keys)
                Console.Write($"{key} ");

            // 'Values' returns a 'ValueCollection' of all the values
            // in the Dictionary and will have the same type that
            // was used when declaring it
            var values = fruit.Values;

            int total = 0;
            foreach (var value in values)
                total += value;
            Console.WriteLine($"{nl}There is a total of {total} fruit");

            // Individual items can be accessed using the 'Key' index
            Console.WriteLine($"There are {fruit["Pears"]} 'Pears'");
            fruit["Pears"] = 3;
            Console.WriteLine($"There are now {fruit["Pears"]} 'Pears'");

            // Syntax error, The 'Key' index must exist to access an item.
            // var mangoes = fruit["Mangoes"];

            // 'TryAdd' unlike accessing a Dictionary with the 'Key' index
            // won't result in an exception but will return false if the
            // Key does not exist. If found result will be the value for
            // the item. If not found result will be the type's default value
            if (fruit.TryGetValue("Mangoes", out var result))
            {
                Console.WriteLine($"There are {result} 'Mangoes'");
            }
            else
            {
                Console.WriteLine($"There is no 'Mangoes' item in 'fruit'");
            }

            // 'ContainsKey' returns true if the Dictionary contains
            // the specified 'Key'
            if (fruit.ContainsKey("Bananas"))
            {
                Console.WriteLine($"There are {fruit["Bananas"]} 'Bananas'");
            }
            else
            {
                Console.WriteLine($"There are no 'Bananas' item in fruit");
            }

            // 'ContainsValue' returns true if the Dictionary contains
            // the specified 'Value'
            if (fruit.ContainsValue(6))
            {
                Console.WriteLine($"There is at least 1 item with the value '6'");
            }
            else
            {
                Console.WriteLine($"There are no items with the value '6'");
            }

            // 'Remove' removes the specified 'Key' from the Dictionary
            fruit.Remove("Oranges");
            if (fruit.ContainsKey("Oranges"))
            {
                Console.WriteLine($"There are {fruit["Oranges"]} 'Oranges'");
            }
            else
            {
                Console.WriteLine($"There is no longer an 'Oranges' item in fruit");
            }

            // 'Clear' removes all KeyValuePair&lt;TKey, TValue&gt; items from
            // the Dictionary
            fruit.Clear();
            Console.WriteLine($"There are {fruit.Count} fruit items");
        }
    }
}

// The example writes the following to the console
// There are 7 fruit items
// Oranges : 6
// Pears: 4
// Apples: 8
// Bananas: 7
// Lemons: 3
// Peaches: 6
// Plums: 6
// 'Another Plums entry' could NOT be added
// Oranges Pears Apples Bananas Lemons Peaches Plums
// There is a total of 40 fruit
// There are 4 'Pears'
// There are now 3 'Pears'
// There is no 'Mangoes' item in 'fruit'
// There are 7 'Bananas'
// There is at least 1 item with the value '6'
// There is no longer an 'Oranges' item in fruit
// There are 0 fruit items
</code></pre>
                    <!-- !SECTION Dictionary<TKey, TValue> -->
                </article>
            </section>
            <!-- !SECTION Arrays and Data Structures -->
            <!-- SECTION Enumerators and tuples -->
            <section class="main-section" id="Enumerators_and_tuples">
                <header><h2>Enumerators and tuples</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION Enumerators -->
                    <h3 id="Enumerators">Enumerators</h3>
                    <p>The <code>enum</code> keyword is used to declare an enumerator which provides a list of named constants. The code editor allows you to use these
                        names to assign the underlying constant values to variables. You can declare the type and value of each constant or allow the editor to declare
                        them for you. The default type for the value is an integer and the list is zero based. A value in an enum is accessed through the enums
                        identifier, followed by a period, followed by the the name of one of the constants. An enum is a value type.</p>
                    <p>The following example demonstrates enumerator declaration and use.</p>
<pre><code>using System;

namespace Enumerators
{
    class Program
    {
        // The default underlying type is an 'int'
        enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat }

        // This declares that the underlying month type is declared as 'long'
        enum Month : long { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }

        static void Main(string[] args)
        {
            var day = Day.Tue;
            var dayType = day.GetType();
            var underlyingDayType = Enum.GetUnderlyingType(dayType);
            Console.WriteLine($"Day is {day}, value is {(int)day}," +
                $" Type is {dayType.Name}, underlying type is {underlyingDayType}");
            var month = Month.Nov;
            var monthType = month.GetType();
            var underlyingMonthType = Enum.GetUnderlyingType(monthType);
            Console.WriteLine($"Month is {month}, value is {(long)month}," +
                $" Type is {monthType.Name}, underlying type is {underlyingMonthType}");
        }
    }
}

// The example prints the following to the console
// Day is Tue, value is 2, Type is Day, underlying type is System.Int32
// Month is Nov, value is 10, Type is Month, underlying type is System.Int64
</code></pre>
                    <!-- !SECTION Enumerators -->
                    <!-- SECTION tuple -->
                    <h3 id="tuple">tuple</h3>
                    <p>A <code>ValueTuple</code> type, commonly called a <i>tuple</i>, is a mutable value type that provides a concise syntax for creating a structure
                        that groups multiple different types together. It does this by creating a <a href="#Access_modifiers">public</a> <a href="#Fields">field</a>
                        element for each type.</p>
                    <p>The tuple syntax is in the from of a set of round brackets containing a comma separated list of at least two <i>elements</i>, with optional
                        identifiers. The compiler provides each element with a default identifier in the form <code>Itemn</code> where n is the position of the element in
                        the list. Optional identifiers are in addition to default identifiers such that an element of a tuple called <code>t</code> can be accessed in the
                        form of either <code>t.Itemn</code> or <code>t.OptionalName</code>. An element can't be optionally named  with a default identifier that is
                        normally used for another element, i.e. naming the the first element <code>Item2</code> results in a syntax error. Additionally, tuples contain a
                        number of <a href="#Members">members</a> and the use of their identifiers will also result in an error. By convention, as the elements are public,
                        they are normally named using <i>PascalCase</i>. Elements can also be assigned values when being declared. A common use for a tuple is the return
                        type for a <a href="#Methods">method</a> where only a single type is allowed, as multiple types can be returned wrapped in the one
                        <code>ValueTuple</code> type.</p>
                    <p><em>Note:</em><i> If an optional identifier is provided IntelliSense won't provide an option for the default identifier but it can still be entered
                        manually.</i></p>
                    <p>There are a number of different ways to declare and assign values to a tuple as demonstrated in the following example.</p>
<pre><code>using System;

namespace TupleDeclaration
{
    class Program
    {
        static void Main(string[] args)
        {
            // Explicitly declare a tuple with
            // 2 elements of type string and int.
            (string, int) t1;

            // Assign values to t1.
            t1 = ("Some text", 1);
            Console.WriteLine($"Item1: {t1.Item1}, Item2: {t1.Item2}");

            // Implicitly declare a tuple with 2 elements of
            // type string and int and assign values to it.
            var t2 = ("My dog has fleas", true);
            Console.WriteLine($"{t2.Item1}: {t2.Item2}");

            // Explicitly declare a tuple with named elements and assign values to them
            (string Name, int Age) person1 = ("Andrew", 21);
            Console.WriteLine($"Person name: {person1.Name}, Age: {person1.Age}");

            // The default element name can also be used
            Console.WriteLine($"Person name: {person1.Item1}, Age: {person1.Item2}");

            // Both names and values can be implicitly assigned in the definition
            var vehicle = (Color: "Red", Wheels: 3);
            Console.WriteLine($"Vehicle color: {vehicle.Color}, Wheels: {vehicle.Wheels}");

            var windows = 6;
            var doors = 2;

            // The types, values and names can be inferred from existing variables.
            var house = (windows, doors);
            Console.WriteLine($"My house has {house.windows} windows and {house.doors} doors");

            // A tuple can be assigned types and values from another provided that
            // both tuples have the same number of elements and for each element
            // the types are implicitly convertible. The names are not assigned.
            (string A, double B) person2 = person1;
            Console.WriteLine($"Person name: {person2.A}, Age: {person2.B}");
        }
    }
}

// The example writes the following to the console.
// Item1: Some text, Item2: 1
// My dog has fleas: True
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Vehicle color: Red, Wheels: 3
// My house has 6 windows and 2 doors
// Person name: Andrew, Age: 21
</code></pre>

                    <p>Deconstruction allows the elements of a tuple to be separated into separate variables through use of the
                        <a href="#Assignmet_operator">assignment operator</a> <code>=</code>.</p>

<pre><code>using System;

namespace TupleDeconstruction
{
    class Program
    {
        static void Main(string[] args)
        {
            var person = ("Andrew", 21);

            // Deconstruction makes available for use
            // the individual elements of a tuple

            // The vales of each element can be individually extracted.
            // Note that the original element names are not available
            var name1 = person.Item1;
            var age1 = person.Item2;
            Console.WriteLine($"Person name: {name1}, Age: {age1}");

            // The types of each variable can be explicitly declared.
            (string name2, int age2) = person;
            Console.WriteLine($"Person name: {name2}, Age: {age2}");

            // The types can be implicitly inferred using var.
            var (name3, age3) = person;
            Console.WriteLine($"Person name: {name3}, Age: {age3}");

            // Individual elements can be implicitly inferred using var.
            (string name4, var age4) = person;
            Console.WriteLine($"Person name: {name4}, Age: {age4}");

            var name5 = string.Empty;
            var age5 = 0;

            // Existing variables of the correct type can be used.
            (name5, age5) = person;
            Console.WriteLine($"Person name: {name5}, Age: {age5}");

            // Discards can be used for elements that are not required
            var (name6, _) = person;
            Console.WriteLine($"Person name: {name6}");
        }
    }
}

// The example writes the following to the console
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Person name: Andrew, Age: 21
// Person name: Andrew
</code></pre>
                    <p><a href="#Equality_operators">Equality operators</a> can be used to compare two tuples provided that both tuples have the same number of elements
                        and the type of each element in each corresponding position is the same.</p>
<pre><code>using System;

namespace TupleEquality
{
    class Program
    {
        static void Main(string[] args)
        {
            (string Name, int Age) person1 = ("Andrew", 21);

            (string Name, int Age) person2 = ("Andrew", 21);
            Console.WriteLine($"person1 == person2: {person1 == person2}");
            Console.WriteLine($"person1 != person2: {person1 != person2}");

            (string Name, int Age) person3 = ("John", 33);
            Console.WriteLine($"person1 == person 3: {person1 == person3}");
            Console.WriteLine($"person1 != person 3: {person1 != person3}");

            (int id, string Name, int Age) person4 = (1, "Andrew", 21);
            // Syntax error, the number of elements are different
            //Console.WriteLine($"person1 == person4: {person1 == person4}");
            //Console.WriteLine($"person1 == person4: {person1 != person4}");

            (string Name, string Age) person5 = ("Andrew", "21");
            // Syntax error, person1.Item2 is an int and person5.Item is a string
            //Console.WriteLine($"person1 == person5: {person1 == person5}");
            //Console.WriteLine($"person1 == person5: {person1 != person5}");
        }
    }
}

// The example writes the following to the console
// person1 == person2: True
// person1 != person2: False
// person1 == person 3: False
// person1 != person 3: True
</code></pre>

                    <!-- !SECTION tuple -->
                </article>
            </section>
            <!-- !SECTION Enumerators and tuples -->
            <!-- SECTION Classes and Other User Defined Types -->
            <section class="main-section" id="Classes_and_Other_User_Defined_Types">
                <header><h2>Classes and Other User Defined Types</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION User defined types -->
                    <h3 id="User_defined_types">User defined types</h3>
                    <p>C# is an <a href="#Object-oriented_Programming">Object-oriented programming language (OOP)</a> and objects can be created using types. A type is a
                        kind of template and when a program runs, objects, also called instances, can be created based on a type. This allows multiple instances to be
                        created each with their own state. Within a C# project, types can be combined with other resources such as media and text files, which are then
                        compiled to create an <a href="#Dependencies_and_Namespaces"><i>assembly</i></a> in the form of either an executable(.exe) or library(.dll) file.
                    </p>
                    <p>The types that can be used to define an object with a state include</p>
                    <ul>
                        <li><a href="#class">classes</a> are reference types used to define complex objects and usually accounts for the majority of types in an
                            assembly</li>
                        <li><a href="#struct">struct (structures)</a> are value types used to define simple data focused objects with little behavior
                        </li>
                        <li><a href="#record">records</a> are reference types that can behave like a value type and are used mostly with immutable data</li>
                        <li><a href="#delegate">delegates</a> are a type used to represent a reference to a method that can be passed as an argument to another method
                        </li>
                        <li><a href="#interface">interfaces</a> can't be instantiated but instead are used to define behaviors that can be implemented by other types
                        </li>
                    </ul>
                    <p>A type can contain <a href="#Members">members</a> which include <a href="#Methods">methods</a>, <a href="#Constructors">constructors</a>,
                        <a href="#Fields">fields</a>, <a href="#Constant_fields">constant fields</a>, <a href="#Properties">properties</a>,
                        <a href="#Indexers">indexers</a>, <a href="#Events">events</a>, <a href="#Finalizers">finalizers</a> and other
                        nested types. Combined these are used to define an object through encapsulation and storage of its data and by providing the object's behavior. A
                        type can contain multiple members with the same identifier, known as <a href="#Signatures,_parameters_and_overloading">overloading</a>, provided
                        that each has a unique <a href="#Signatures,_parameters_and_overloading">signature</a>. Accessibility to a type from code outside of the assembly,
                        and to members both from outside the assembly and from other types within the assembly, is controlled through the use of
                        <a href="#Access_Modifiers">access modifier</a> keywords.</p>
                    <p></p>
                    <p>Classes, structs and records can be instantiated with use of the <code>new</code> keyword. That is multiple instances of these types can be
                        created, each with its own state. A class can also be made <a href="#static">static</a> in which case it cannot be instantiated using the
                        <code>new</code> keyword but instead a single instance of the class is automatically created at runtime and is shared throughout the assembly. A
                        child class, record or interface can <a href="#Inheriting_types">inherit</a> from a parent class, record or interface respectively. In
                        C# a parent type is called a base type and a child a derived type. Classes and records can be marked as <a href="#abstract">abstract</a> requiring
                        a derived class for instantiation or <a href="#sealed">sealed</a> to prevent inheritance. Use of the static, abstract and sealed keywords is
                        mutually exclusive. As well as inheritance a class, struct or record can implement an interface.</p>
                    <!-- !SECTION User defined types -->
                    <!-- SECTION class -->
                    <h3 id="class">class</h3>
                    <p>A class within a namespace is declared by specifying an optional <a href="#Access_Modifiers">access modifier</a> keyword, followed by the
                        <code>class</code> keyword, followed by an identifier that is unique within the same <a href="#Dependencies_and_Namespaces">namespace</a>,
                        followed by a code block defined by a pair of braces. If the access modifier keyword is omitted the default access is internal. A class can also
                        be marked with either the <a href="#static">static</a>, <a href="#abstract">abstract</a> or <a href="#sealed">sealed</a> keywords. Whilst multiple
                        classes can be added to a single file, unless a class is nested, the convention is that each should occupy its own
                        file.</p>
                    <p>To add a class file in Visual Studio</p>
                    <ol>
                        <li>In the <b>Solution Explorer</b> right click the project or a folder within it that you wish to add the class to.</li>
                        <li>In the context menu hover the mouse over <b>Add</b> then in the new context menu that opens, click <b>Class</b> and the <b>Add New Item</b>
                            dialog will open.</li>
                        <li><b>Class</b> should be selected at the top of the list but if it isn't, type <i>class</i> in the search bar in the top right of the dialog and
                            then select <i>class</i> in the list.</li>
                        <li>At the bottom of the dialog in the name text box type the name of the class then click <b>Add</b> and the new class file will be added to the
                            project and then opened in the code editor.</li>
                    </ol>
                    <p></p>
                    <p><em>Note:</em><i> The Class template provided by Visual Studio in the Add New Item dialog creates a file with a class without an access modifiers.
                        The file will also include using directives for various namespaces dependent on the project's type. Adding a class to a folder will result in a
                        <a href="#Dependencies_and_Namespaces">namespace</a> of the form <code>namespace ProjectName.FolderName</code>.</i></p>
<!-- TODO finish the following -->
<!-- TODO add brief about overriding and virtual -->
<!-- TODO add brief about polymorphism -->

                    <p>The following example demonstrates ways in which a class can be declared. </p>
<pre><code>using System;

namespace ClassDeclaration
{
    // The syntax for declaring a class is first
    // an optional access modifier followed by
    // the keyword class then a unique identifier
    // followed by a pair of braces within
    // which are the classes members

    // Public class declaration. This class can be
    // accessed both by the the assembly that
    // contains it and any assembly that references it
    public class PublicClass
    {

    }

    // internal class declaration.  This class can
    // only be accessed both by the assembly that
    // contains it
    internal class InternalClass
    {

    }

    // Without the optional access modifier this
    // class is internal by default
    class DefaultClass
    {
        // Without an access modifier this
        // class is private by default
        class NestedClass
        {

        }
    }
}
</code></pre>
                    <p>The following example defines a <code>Square</code> class with <a href="#Constructors">constructors</a>, <a href="#Methods">methods</a>,
                        <a href="#Fields">fields</a>,
                        <a href="#Properties">properties</a> and <a href="#Events">events</a>. There are two constructors, the first has a
                        <a href="#Parameters_signatures_and_overloading">signature</a> with one parameter and the second with three in which the third parameter is
                        optional. The <code>Program</code> class creates three instances of the <code>Square</code> class. The first uses the first constructor, the
                        second the second constructor without passing an argument to the third parameter. The third also uses the second constructor but does pass an
                        argument. It also adds the <code>Square_AreaChanged</code> event handler to handle the <code>AreaChanged</code> event of both the
                        <code>square2</code> and <code>square3</code> instances. When the program is run, after writing the initial area values to the console it then
                        changes the <code>Width</code> property directly on the <code>square2</code> instance and <code>Height</code> on <code>square3</code> through the
                        <code>SetHeight</code> method. This triggers the <code>AreaChanged</code> event in each which then calls the <code>Square_AreaChanged</code> event
                        handler which in turn writes the updated values to the console.</p>
<pre><code>using System;

namespace ClassExample
{
    class Square
    {
        // Declare 2 fields a constant to initialize the width and a
        // variable to use as a backing field for the Width property
        const int DEFAULT_VALUE = 1;
        private int _Width;

        // A constructor that sets the Height
        // and Width to the default value internally
        // The name and height must be set
        public Square(string name)
        {
            Name = name;
            Height = DEFAULT_VALUE;
            Width = DEFAULT_VALUE;
        }

        // A constructor that allows the Width to optionally be set
        // if a value is not provided it is set to the default value
        // The name and height must be set
        public Square(string name, int height, int width = DEFAULT_VALUE)
        {
            Name = name;
            Height = height;
            Width = width;
        }

        // An event that fires when there are changes
        // This uses the Expression-bodied member syntax
        public event EventHandler AreaChanged = (sender, e) =&gt; { };

        // The name property has a private setter
        // It can only be set from within the class
        // This is an Auto Property as the compiler
        // automatically creates a hidden private
        // backing field
        public string Name { get; private set; }

        // The Height property can be set both from inside
        // and from outside the class but does not trigger
        // the AreaChanged event. This is also an
        // Auto Property
        public int Height { get; set; }

        // The Width property can be set both from inside
        // and from outside the class and triggers
        // the AreaChanged event by calling the
        // OnAreaChanged method
        public int Width
        {
            get =&gt; _Width;
            set
            {
                if (_Width == value)
                    return;
                _Width = value;
                OnAreaChanged();
            }
        }

        // The SetHeight method changes the height and
        // triggers the area changed event by calling the
        // OnAreaChanged method. This method's return
        // type is set to void which means that it does
        // not return a value. It accepts a parameter
        // of type int called height
        public void SetHeight(int height)
        {
            Height = height;
            OnAreaChanged();
        }

        // The GetArea method calculates the area from the
        // Height and Width values and returns the result
        // as an int
        public int GetArea()
        {
            return Height * Width;
        }

        // This is the expression-bodied member syntax for the GetArea method
        // and performs the same function. It is useful when only one line
        // of code is to be entered within the braces
        public int GetArea2() =&gt; Height * Width;

        // An overloaded GetArea2 method. When selecting this method
        // IntelliSense will show there are two versions of this
        // method to choose from
        public int GetArea2(int doesNothing) =&gt; Height * Width;

        // The OnAreaChanged method first checks if an event handler exists
        // and if so calls the event through the invoke command passing on
        // the arguments in this case this class instance by using the this
        // keyword and an empty EventArgs
        // This method also uses Expression-bodied member syntax
        private void OnAreaChanged() =&gt; AreaChanged?.Invoke(this, EventArgs.Empty);
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Three squares are created using the new keyword and alternative
            // constructors
            Square square1 = new("Square 1");
            Square square2 = new("Square 2", 5);
            Square square3 = new("Square 3", 5, 10);
            // The Square_AreaChanged event handler is added to both the
            // square2 and square3 AreaChanged events
            square2.AreaChanged += Square_AreaChanged;
            square3.AreaChanged += Square_AreaChanged;
            // The initial area values are written to the console
            Console.WriteLine($"{square1.Name} area is {square1.GetArea().ToString()}");
            Console.WriteLine($"{square2.Name} area is {square2.GetArea().ToString()}");
            Console.WriteLine($"{square3.Name} area is {square3.GetArea().ToString()}");
            // Changing the width triggers the square2 AreaChanged event
            square2.Width = 3;
            // Changing the height triggers the square3 AreaChanged event
            square3.SetHeight(10);

        }

        // This is the Square_AreaChanged event handler which has been added to both the
        // square1 and square2 AreaChanged events
        private static void Square_AreaChanged(object sender, EventArgs e)
        {
            var square = sender as Square;
            Console.WriteLine($"{square.Name} area changed and is now {square.GetArea().ToString()}");
        }
    }
}

// The example writes the following to the console
// Square 1 area is 1
// Square 2 area is 5
// Square 3 area is 50
// Square 2 area changed and is now 15
// Square 3 area changed and is now 100
</code></pre>
                    <!-- !SECTION class -->
                    <!-- SECTION Members -->
                    <h3 id="Members">Members</h3>
                    <p>The state of an object is held by the members it contains. These provide <a href="#Encapsulation">encapsulation</a> and storage of its data,
                        as well as the object's behavior.</p>
                    <p>Following is a list of all possible members</p>
                    <ul>
                        <li><a href="#Methods">methods</a> that provide the behavior of the object</li>
                        <li><a href="#Constructors">constructors</a> which initialize the state of an object</li>
                        <li><a href="#Fields">fields</a> that store data about the object and can be changed at runtime</li>
                        <li><a href="#Constant_fields">constant fields</a> that store data when declared, cannot be changed at runtime and are inherently
                            <a href="static">static</a></li>
                        <li><a href="#Properties">properties</a> that provide controlled access to an object's data</li>
                        <li><a href="#Indexers">indexers</a> that allows an object to be indexed like an array</li>
                        <li><a href="#Events">events</a> that communicate changes in the object's state to other objects or to itself</li>
                        <li><a href="#Operators">operators</a> that when overloaded are considered a type member</li>
                        <li><a href="#Finalizers">finalizers</a> that performs cleanup of an object when it is no longer in use </li>
                        <li>nested type which is the declaration of another type within the containing type</li>
                    </ul>
                    <p>Members are declared within the type that defines the object. All members within an object can access each other irrespective of the location at
                        which they are declared. Access to members external to the object is controlled through the use of
                        <a href="#Access_Modifiers">access modifier</a> keywords and the access level of the object that contains them. If omitted a member's
                        access level will be private by default. Members can also be marked with the <a href="#static">static</a>,
                        <a href="#abstract">abstract</a> or <a href="#sealed">sealed</a> keywords which are mutually exclusive. A calling object accesses the member of
                        another in the same <a href="#namespace">namespace</a> through the object's identifier if it is an instance, or the type's identifier if it is
                        static, followed by a period, followed by the member's identifier such as <code>object.Member</code> or <code>Type.Member</code> respectively. If
                        an object needs to access a static member of an object in another namespace then the fully qualified name is required in the form of
                        <code>Namespace.Type.Member</code>. This can be negated through the use of a <a href="#using">using</a> directive. Some members also
                        require the passing in of arguments to parameters contained in round brackets that follow the member identifier. Visual Studio's IntelliSense can
                        assist you as it will display a suggestion box that lists the namespaces, types and members to choose from as you enter them.</p>
                    <p>All members except fields, constant fields and events that have a single expression support implementation through the use of
                        <a href="#The_lambda_and_expression-body_definition_operator">expression-bodied members which makes for a much more concise code</a>.
                        Constructors, indexers and methods can be <a href="#Signatures,_parameters_and_overloading">overloaded</a>. That is a type can contain multiple
                        versions with the same identifier provided that they overload a member of the same type and each overload has a unique signature.</p>
                    <p>Properties, indexers, methods and events in a <a href="#Inheriting_types">base</a> type can be marked marked
                        <a href="#abstract">abstract</a> or <a href="#virtualo">virtual</a> though marking an event a virtual is not recommended as the
                        C# compiler does not handle them correctly producing unpredictable results. In a <a href="#Inheriting_types">derived</a> type a virtual base
                        member can optionally be <a href="#override">overridden</a> where as an abstract base member <em>must</em> be overridden by a
                        member with the same signature that is marked with the <code>override</code> keyword. A type that contains an abstract member must also be marked
                        abstract. A member marked as <code>override</code> can also be marked with the <code>sealed</code> keyword preventing it from being overridden in
                        any further derived type. Where members in both a base and derived type have the same identifier under certain conditions the derived member may
                        hide the base member, please see <a href="#Inheriting_types">Inheriting types</a>.
                    </p>
                    <!-- !SECTION Members -->
                    <!-- TODO add passing array to a method -->
                    <!-- TODO add local function syntax -->
                    <!-- SECTION Methods -->
                    <h3 id="Methods">Methods</h3>
                    <p>A method provides the behavior of an object. This could be reading a file, calculating a value, writing to the screen, etc. It does this by acting
                        as a container for one or more <a href="#Code_Syntax">statements</a>. Statements elsewhere in the program can pass the execution flow to a method
                        known as <i>invoking</i> or <i>calling</i> a method and statements within a method can call other methods.</p>
                    <p>A method consists of two parts, the <a href="#Signatures,_parameters_and_overloading">signature</a> and the body that contains the statements. The
                        signature defines the methods name, values known as <i>parameters</i> that can be <i>passed in</i> to the method for processing by the statements
                        it contains and a return type for returning a value back to the statement that called it. If a method is not required to return a value then the
                        type is replaced with the <code>void</code> keyword. Optional <a href="#Modifiers">modifiers</a> can be applied to a method and its parameters
                        that can change accessibility and behavior.</p>
                    <p>For a method that returns a value, the statements in the body are executed until a return statement is reached. This is defined by the
                        <code>return</code> keyword followed by a variable or literal of the type in the method declaration followed by a semicolon. Program execution,
                         along with the returned value  will then be passed back to the statement that called the method.</p>
                    <p>For a method that does not return a value, execution will be passed back to the calling statement, either when a return statement or the closing brace is
                        reached. In this case a return statement is defined just with the <code>return</code> keyword followed by a semicolon.</p>
                    <p>In both cases a method can contain multiple return statements allowing for multiple exit points from different paths back to the calling code. In
                        this case, a method that has a return type but that does not have a return statement for all possible paths will produce a syntax error. Methods
                        with a single expression can be implemented in the form of an an <a href="#The_lambda_and_expression-body_definition_operator">expression-bodied
                        member</a> and a class can contain multiple <a href="#Signatures,_parameters_and_overloading">overloads</a> of a method.</p>
                    <p>Access to a method by code external to the type is in the form of <code>instance.Method(parameters)</code> for an instance of a type and
                       <code>TypeName.Method(parameters)</code> for a <a href="static">static</a> type.</p>
                    <p>The following shows examples of method declaration and use.</p>
<pre><code>using System;

namespace Methods
{
    public class MyClass
    {
        // A method that takes in an argument
        // through a string parameter which it
        // then writes to the console. As the
        // return type is void it does not
        // return a value
        public void PrintMessage(string value)
        {
            Console.WriteLine(value);
        }

        // A method that calls another method
        // from within the class and then
        // prints the returned value
        public void PrintProduct(int a, int b)
        {
            var product = Multiply(a, b);
            Console.WriteLine(product);
        }

        // A public method that returns an int
        // value of the sum of the parameters
        public int Add(int x, int y)
        {
            return x + y;
        }

        // A method that uses an expression body
        public int Subtract(int x, int y) =&gt; x - y;

        // A private method that can only
        // that can only be accessed from
        // within the enclosing type
        private int Multiply(int x, int y)
        {
            return x * y;
        }

        // Syntax error, a method with a return type must have a return statement
        //public int Sum(int a, int b, int c, int d)
        //{
        //    var result = a + b + c + d;
        //}

        // Syntax error, the if statement does not return a value if x == 0
        //public int Sum(int a, int b, int c, int d)
        //{
        //    if (x != 0)
        //     return  a + b + c + d;
        //}
    }

    class Program
    {
        static void Main(string[] args)
        {
            MyClass myClass = new MyClass();
            var sum = myClass.Add(2, 3);
            var difference = myClass.Subtract(7, 4);
            Console.WriteLine($"2 + 3 = {sum}");
            Console.WriteLine($"7 - 4 = {difference}");
            Console.Write("5 x 6 = ");
            myClass.PrintProduct(5, 6);
        }
    }
}

// The example writes the following to the console
// 2 + 3 = 5
// 7 - 4 = 3
// 5 x 6 = 30
</code></pre>
                    <!-- !SECTION Methods -->
                    <!-- SECTION Constructors -->
                    <h3 id="Constructors">Constructors</h3>
                    <p>When an object is created a constructor is called that can be used to set its data and provide other actions that initialize the object's
                        state. The syntax for a constructor is similar to that of a <a href="#Methods">method</a> in that it has a
                        <a href="#Signatures,_parameters_and_overloading">signature</a> that can take in parameters and is a container for one or more
                        <a href="#Code_Syntax">statements</a>. Unlike a method it cannot return a value, its identifier is always that of the type that contains it and
                        it can only be called once when the object is created.</p>
                    <p>A constructor can be marked with with various <a href="#Modifiers">modifiers</a> that change its behavior and an instance constructor can be
                        <a href="#Signatures,_parameters_and_overloading">overloaded</a>. By using the <code>this</code> keyword, a constructor can call another
                        overloaded constructor when an object is created. In an instance type, if no constructors are declared the compiler will provide a default
                        parameterless constructor with an empty code block. If constructors are declared then the compiler will not declare the default constructor, so in
                        this case if a parameterless constructor is required it will need to be explicitly declared. To create an instance of a type the <code>new</code>
                        keyword is used to call an instance constructor. Constructors with a single expression can be implemented in the form of an an
                        <a href="#The_lambda_and_expression-body_definition_operator">expression-bodied member</a></p>
                    <p>Both instance and static constructors can be declared in <a href="#class">classes</a>, <a href="#struct">structs</a> and
                        <a href="#record">records</a> whereas only static constructors can be declared in an <a href="#interface">interface</a>. A class or record can
                        declare both parameterless and parameterized constructors whereas a struct can only declare parameterized constructors (<em>Note:</em> <i>
                        parameterized constructors will be allowed in structs beginning with C# 10.0</i>). An instance constructor cannot access a field marked static
                        readonly and a static class cannot contain an instance constructor. An instance type can contain a static constructor but a static constructor
                        cannot be used to create an instance of a type.</p>
                    <p>The following example demonstrates the declaration and usage of constructors. The first class called <code>DefaultClass</code> does not explicitly
                        declare a constructor so the compiler declares a default parameterless constructor that can be called to instantiate it.
                        <code>ParameterizedClass</code> explicitly declares a single parameterized constructor. As this prevents the compiler from implicitly declaring a
                        parameterless constructor, when an attempt is made to instantiate the class using one, it results in a syntax error. The <code>Person</code> class
                        has four explicitly declared overloaded constructors. The first is parameterless so creating an instance of <code>Person</code>using a
                        parameterless constructor is permitted and it sets the values of the two <a href="#Fields">fields</a> <code>_firstName</code> and
                        <code>_lastName</code> to <i>First name</i> and <i>Last name</i> respectively. The second constructor has two parameters and sets
                        <code>_firstName</code> and <code>_lastName</code> to the values passed in. The third constructor has one parameter and makes use of the
                        expression-bodied member syntax setting only the value of the <code>_firstName</code> field. The fourth constructor has three parameters,
                        <code>id</code>, <code>firstName</code> and  <code>lastName</code>. Using the <code>this</code> keyword it calls the second constructor, passing
                        in <code>firstName</code> and <code>lastName</code> then uses <code>id</code> to set the <code>_id</code> field using expression-bodied syntax.</p>
<pre><code>using System;

    namespace Constructors
    {
        // If no constructors are declared the compiler
        // implicitly declares a default parameterless constructor
        public class DefaultClass { }

        // If a constructor is explicitly declared the
        // compiler won't declare a default constructor
        public class ParameterizedClass
        {
            public ParameterizedClass(int value) { }
        }

        // The 'Person' class declares three overloaded constructors
        public class Person
        {
            private string _firstName;
            private string _lastName;
            private int _id;

            // An explicitly declared parameterless
            // constructor that initializes both fields
            public Person()
            {
                _firstName = "First name";
                _lastName = "Last name";
            }

            // A constructor with two parameters that initializes
            // both fields using the arguments passed in
            public Person(string firstName, string lastName)
            {
                _firstName = firstName;
                _lastName = lastName;
            }

            // A constructor that uses expression-bodied syntax which
            // initializes one field only using the argument passed in
            public Person(string firstName) =&gt; _firstName = firstName;

            // Calls the constructor with two parameters and then
            // sets the '_id' field using expression-bodied syntax
            public Person(int id, string firstName, string lastName)
                : this(firstName, lastName) =&gt; _id = id;
        }

        class Program
        {
            static void Main(string[] args)
            {
                // This object is instantiated using
                // the default parameterless constructor
                DefaultClass defaultClass = new();

                // Syntax error, this class has only one
                // constructor that requires a constructor
                //ParameterizedClass parameterizedClass = new();

                // Instantiated using the explicitly
                // declared parameterless constructor
                Person person1 = new();

                // A second instance using the overloaded
                // constructor with two parameters
                Person person2 = new("John", "Smith");

                // A third instance using the overloaded
                // constructor with one parameter
                Person person3 = new("Susan");

                // A fourth instance using the overloaded
                // constructor with four parameters
                Person person4 = new(1, "Susan", "Smith");
            }
        }
    }

    // This example does not write anything to the console
</code></pre>
                    <!-- !SECTION Constructors -->
                    <!-- SECTION Fields -->
                    <h3 id="Fields">Fields</h3>
                    <p>A variable declared inside a type but outside any other member is called a field and is used to store data about an object. They are declared using
                        an optional <a href="#Access_modifiers">access modifier</a>, followed by the field's type, followed by an identifier that is unique within the
                        field's containing type. Fields are normally declared either private or protected. This provides <a href="#Encapsulation">encapsulation</a> and
                        access to a field is achieved through other members within the type including <a href="#Properties">properties</a>,
                        <a href="#Methods">methods</a>, <a href="#Indexers">indexers</a> and <a href="#Constructors">constructors</a>. This has the advantage of allowing
                        for data validation and performing other tasks before or after changing its value. Most commonly, external access to a field is through a property
                        and when this is done the field is called a <i>backing field</i>.</p>
                    <p>A variable field does not have to be initialized with a value and if not, will be initialized by the compiler to the default value for its type.
                        When the program is run, field initialization occurs in the order of</p>
                    <p><i>declaration &gt; constructor &gt; object initializer</i>.</p>
                    <p>This means that setting a field's value in a constructor will overwrite a value set in the declaration and setting it's value in an
                        object-initializer will overwrite the value set both in the field declaration, a constructor or an init accessor of a property.</p>
                    <p>A variable field can be made readonly through the use of the <code>readonly</code> keyword in which case it can only be initialized either by
                        declaration or in a constructor. How this effects a variable though depends on whether it is a value or a reference type. As a value type contains
                        its data it can't be changed after being initialized. As a reference type only stores the address in memory of the data, it is only this reference
                        that can't be changed and not the data itself. For example, if a <code>List&lt;T&gt;</code> is declared as a public read-only field, code outside
                        the class can still add and remove items from the list.</p>
                    <p><em>Note:</em><i> Whilst a <a href="#Strings">string</a> is a reference type as it is immutable declaring it <code>readonly</code> prevents it
                        from being assigned to after initialization.</i></p>
                    <p>By convention fields are normally declared at the top of a class before any other code. Access to a field by code external to the type is in the
                        form of <code>instance.Field</code>.</p>
                    <p>The following example demonstrates field declaration and use.</p>
<pre><code>using System;
using System.Collections.Generic;

namespace Fields
{
    public class Person
    {
        // NOTE: instance fields should never be declared public
        // and are only shown here for demonstrative purposes

        // This field has been declared public and can be accessed
        // from any code outside this class both in and outside
        // the assembly that contains it. As it has not been initialized
        // it will have the default string value i.e. an empty string
        public string ID;

        // A private field with default string value i.e. an empty string
        private string _name;

        // With no access modifier this field is private
        // It has the default value of 0
        int _age;

        // A private field of type double which is initialized to 55.4
        private double _weight = 55.4;

        // A public read only field of type string. Its
        // value can only be set through the constructor
        public readonly string Details;

        // A public read only field of type List&lt;T&gt;. As it is a mutable
        // reference type the data it contains can still be modified
        // from any code outside this class both in and outside
        // the assembly that contains it
        public readonly List&lt;string&gt; Skills;

        // A parameterless constructor that sets the Details field
        // using the default values of the other fields
        public Person()
        {
            Details = $"ID: {ID}, Name: {_name}, Age: {_age}, Weight: {_weight}kg";
            Skills = new();
        }

        // This constructor takes in arguments to set the
        // Id, _Name, _Age and _Weight fields. These values
        // are then used to set the value of the Details field
        public Person(string id, string name, int age, double weight)
        {
            ID = id;
            _name = name;
            _age = age;
            _weight = weight;
            Details = $"ID: {ID}, Name: {_name}, Age: {_age}, Weight: {_weight}kg";
            Skills = new();
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Person person1 = new();
            Person person2 = new("Person2", "John Smith", 23, 50);
            Person person3 = new("Person3", "Andrew Smith", 23, 50)
            {
                ID = "Other"
            };

            // Each instance contains its own copy of the fields
            Console.WriteLine($"person1 details - {person1.Details}");
            Console.WriteLine($"person2 details - {person2.Details}");
            Console.WriteLine($"person3 details - {person3.Details}");

            // person3.Id contains 'Other' as it was changed in the object initializer
            Console.WriteLine($"person3 ID: {person3.ID}");

            // As person3.Id is public direct access is allowed that cannot be
            // validated. Changes to person3.Id don't affect person3.Details
            person3.ID = "Invalid ID";
            Console.WriteLine($"person3 ID: {person3.ID}");
            Console.WriteLine($"person3 details - {person3.Details}");

            // Syntax error, a readonly field value type variable
            // can't be assigned to after initialization
            //person3.Details = "Change details";

            // As readonly Skills is a reference type its data can still be modified
            person3.Skills.Add("C# programming");
            Console.WriteLine($"person3 hobbies: {person3.Skills[0]}");
        }
    }
}

// The example writes the following to the console
// person1 details - ID: , Name: , Age: 0, Weight: 55.4kg
// person2 details - ID: Person2, Name: John Smith, Age: 23, Weight: 50kg
// person3 details - ID: Person3, Name: Andrew Smith, Age: 23, Weight: 50kg
// person3 ID: Other
// person3 ID: Invalid ID
// person3 details - ID: Person3, Name: Andrew Smith, Age: 23, Weight: 50kg
// person3 hobbies: C# programming
</code></pre>
                    <!-- !SECTION Fields -->
                    <!-- SECTION Constant fields -->
                    <h3 id="Constant_fields">Constant fields</h3>
                    <p>Like a variable field, a constant field is declared inside a type but outside any other member. They are declared using an optional
                        <a href="#Access_modifiers">access modifier</a>, followed by the <code>const</code> keyword, followed by the constant field's type, followed by an
                        identifier that is unique within the constant field's containing type. A constant field can only and <em>must have</em> its value initialized when
                        it is declared. As with variable fields, constant fields are normally declared at the top of the type. By convention a constant field's identifier
                        is written in all capitals such as <code>CONSTANT</code>.</p>
                        <p>A constant field is already effectively <a href="#static">static</a> so the <code>static</code> keyword cannot be applied to it. Like static
                            members, a constant field cannot be accessed by code through an instance of the type but through the type itself.</p>
                        <p>Access to a property by code external to the type is in the form of <code>Type.CONSTANT</code>.</p>
                        <p>The following example demonstrates constant field declaration and use.</p>
<pre><code>using System;

    namespace ConstantFields
    {
        public class MathConstants
        {
            // A public constant of type double. Its value must be
            // initialized within the declaration and cannot be changed
            // Convention for naming constants is to use all capitals
            public const double PI = 3.1415;

            // A member within an instance of MathConstants can access
            // constant field PI without the need for the Type identifier
            public double Area(double r)
            {
                return PI * r * r;
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                // A constant accessed using type's identifier 'MathConstants'
                var area1 = MathConstants.PI * 2 * 2;
                Console.WriteLine($"The area of circle 1 with a radius of 2 is {area1}");

                MathConstants mathConstants = new();

                // Syntax error, a constant field cannot be accessed through an instance
                //var pi = mathConstants.PI;

                var area2 = mathConstants.Area(3);
                Console.WriteLine($"The area of circle 2 with a radius of 3 is {area2}");
            }
        }
    }

    // The example writes the following to the console

    // The area of circle 1 with a radius of 2 is 12.566
    // The area of circle 2 with a radius of 3 is 28.2735
</code></pre>
                    <!-- !SECTION Constant fields -->
                    <!-- SECTION Properties -->
                    <h3 id="Properties">Properties</h3>
                    <p>A property is a way of allowing external code to have controlled access to data within an object. It does this by providing special methods
                        that can read from and write to the data, most often a single field which in this context is known as a <i>backing field</i>. The data the
                        property accesses must be of the same type as the property's declared type. Whilst the
                        default access level for a property is private, an optional <a href="#Access_modifiers">access modifier</a> is normally applied to allow for
                        access outside its containing type. Declaration of a property can take one of two forms, <i>manually-implemented</i> or
                        <i>auto-implemented</i>.</p>
                    <p>Manually-implemented properties can be declared using an optional access modifier, followed by the property's type,
                        followed by an identifier that is unique within the property's containing type, followed by a pair of braces that define a code block which is the
                        body of the property. This can contain one or both of two special methods which include a <i>getter</i> declared using the <code>get</code>
                        keyword to read data from the object and a <i>setter</i> declared using either the <code>set</code> or <code>init</code> keywords to write
                        data to the object. Collectively <code>get</code>, <code>set</code> and <code>init</code> are called <i>accessors</i> with <code>set</code> and
                        <code>init</code> being mutually exclusive. A property can be made read/write by using both a getter and a setter, read-only by only using a
                        getter or write-only by only using a setter, though the latter is an extremely rare situation.  </p>
                    <p>Both the getter and the setter each have their own code block. Within the setter code block the <code>value</code> keyword is used to hold the
                        value passed in to the property which is to be assigned
                        to the data, in the form of <code>data = value;</code>. Other statements can be placed in the setter to to
                        validate the value before it is written to the data or to perform an action before or after this is done. This could include
                        <a href="#Events">raising an event</a> to communicate to other objects that the property's value has changed.  Within getter code block  this usually
                         takes the form of <code>return backingField</code>. As
                        with <code>set</code>, other code can also be placed within the <code>get</code> code block. In both cases such code should be limited and where
                        more complex procedures are required a <a href="#Methods">method</a> should be utilized. An alternative to <code>set</code> is <code>init</code>
                        which can only be called by the constructor or an object-initializer, which makes the property read-only after it has been initialized during the
                        objects instantiation. As with <code>set</code> a property can be made write-only by only using <code>init</code>. The <code>set</code> and
                        <code>init</code> keywords are mutually exclusive. Collectively <code>set</code>,
                        <code>init</code> and <code>get</code> are called <i>accessors</i>. An accessor that has a single expression can be implemented in the form of an
                        <a href="#The_lambda_and_expression-body_definition_operator">expression-bodied member</a>.</p>
                    <p>The default access for accessors is that of the property containing them, but can be changed through the use of access modifiers provided
                        that</p>
                    <ul>
                        <li>the property is read/write</li>
                        <li>only one of the accessors has the access modifier applied</li>
                        <li>the access modifier is more restrictive than the property container</li>
                    </ul>
                    <p>This means for example, if a property is public and and the <code>set</code> accessor is made private then the property can be read from outside
                         the class but
                         ony set by other members
                        within it. </p>
                    <p><em>Note:</em><i> Applying an access modifier to a <code>get</code> accessor is not recommended and making an <code>init</code> accessor private
                         has the effect that the property can only be initialized in a constructor and <b>not</b> an
                        object-initializer. </i></p>
                    <p>Auto-implemented properties have accessors that are declared without an implementation code block and without declaring a separate  backing field
                        allowing the
                        property to be written with one line of code. During runtime the compiler creates a hidden private backing field that can only be accessed through
                         the
                        property. An advantage of an auto-implemented property is that it can be initialized through the declaration. For a read/write property either
                        both accessors must be manually-implemented or auto-implemented. An auto-implemented property must always have a <code>get</code> accessor so
                        it cannot be write-only.</p>
                    <p>Whilst the order of getters and setters in both manually-implemented or auto-implemented properties doesn't matter, by convention getters are
                        normally declared first. Access to a property by code external to the type is in the form of <code>instance.Property</code> for an instance of
                         a type and
                        <code>TypeName.Property</code> for a <a href="static">static</a> type.</p>
                    <p>The following example demonstrates property declaration and use.</p>
<pre><code>using System;

    namespace Properties
    {
        public enum SkillLevel { None, Beginner, Intermediate, Expert }

        public class Student
        {
            private string _firstName;
            private string _lastName;
            private int _courseLength;
            private string _password;
            private string _courseName;
            private DateTime _created;

            public Student(long id, string courseName, int courseLength,  DateTime enrollmentDate, string password)
            {
                ID = id;
                CourseName = courseName;
                CourseLength = courseLength;
                EnrollmentDate = enrollmentDate;
                Password = password;
                Created = DateTime.Now;
                Modified = Created;
            }

            // A manually-implemented property with full accessor code blocks.
            public string FirstName
            {
                get
                {
                    return _firstName;
                }
                set
                {
                    _firstName = value;
                }
            }

            // Accessors with a single expression
            // implemented as expression-bodied members
            // The get does not require the return
            // keyword and neither accessor
            // requires braces to define a code block.
            public string LastName
            {
                get =&gt; _lastName;
                set =&gt; _lastName = value;
            }

            // A property with a expression-bodied get and
            // an inti accessor with a full code block accessor.
            public int CourseLength
            {
                get =&gt; _courseLength;
                init
                {
                    if (value &lt;= 0)
                        throw new ArgumentOutOfRangeException(nameof(value), "Must be more than zero");
                    _courseLength = value;
                }
            }

            // A read-only property can only be initialized in the constructor
            // but still allows code within the expression to be run.
            // This property does not use a backing field.
            public DateTime ExpectedCompletionDate =&gt; EnrollmentDate.AddYears(CourseLength);

            // A write only property is actively discouraged
            // within Microsoft's reference documentation.
            public string Password { set =&gt; _password = value; }

            // A read/write property with have an access modifier.
            // It can be read externally but only set within the class.
            public string CourseName
            {
                get =&gt; _courseName;
                private set =&gt; _courseName = value;
            }

            // A manually-implemented property with an init accessor.
            public DateTime Created
            {
                get =&gt; _created;
                init =&gt; _created = value;
            }

            // An auto-implemented property has its own hidden backing
            // field and can be initialized as part of its declaration.
            public SkillLevel ProgrammingSkillLevel { get; set; } = SkillLevel.Beginner;

            // An auto-implemented read-only property.
            public long ID { get; }

            // An auto-implemented read/write property with an access modifier
            public DateTime Modified { get; private set; }

            // An auto-implemented read/write property with an init accessor
            public DateTime EnrollmentDate { get; init; }

            // Syntax error, an auto-implemented property must have a get
            //public string Password2 { set; }

            // Syntax error, only one accessor can have an access modifier
            //public string User { internal get; private set; }

            // Syntax error, an accessor access modifier must be
            // more restrictive than the property containing it
            //public string Password2 { public get; set; }

            public string LogIn(string password)
            {
                // Syntax error, can't read a write only property
                //if (password == Password)

                // This accesses the _password field so is OK
                if (password == _password)
                    return ("login successful");
                return "login failed";
            }

            public void Update(string courseName)
            {
                CourseName = courseName;
                Modified = DateTime.Now;
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                string nl = Environment.NewLine;

                Student student = new(1, "Programming in Java masters", 2, new DateTime(2021, 12, 5), "password")
                {
                    // Assign values to properties in an object initializer
                    FirstName = "Jane",
                    LastName = "Robinson",
                    ProgrammingSkillLevel = SkillLevel.Intermediate,
                    Created = new DateTime(2021, 12, 4)
                };

                Console.WriteLine($"ID: {student.ID}, {student.FirstName} {student.LastName}");
                Console.WriteLine($"Course: {student.CourseName}, Length: {student.CourseLength} years");
                Console.WriteLine($"Enrolled: {student.EnrollmentDate:dd MMM yyyy}");
                Console.WriteLine($"Expected Finish Date: {student.ExpectedCompletionDate:dd MMM yyyy}");
                Console.WriteLine($"Current Skill Level {student.ProgrammingSkillLevel}");
                Console.WriteLine($"Record created: {student.Created:dd MMM yyyy}{nl}");

                student.Update("Programming in C# masters");
                Console.WriteLine($"ID: {student.ID}, {student.FirstName} {student.LastName}");
                Console.WriteLine($"Course: {student.CourseName}, Length: {student.CourseLength} years");
                Console.WriteLine($"Last updated: {student.Modified:dd MMM yyyy}{nl}");

                // Syntax error, can only assign a value to a property with an
                // init accessor in a constructor or an object initializer
                //student1.Created = DateTime.Now;

                Console.WriteLine($"Attempting student login before changing password, {student.LogIn("password")}");
                // Assign a value to a write only property
                student.Password = "NewPassword";
                Console.WriteLine($"Attempting student login after changing password, {student.LogIn("password")}");
            }
        }
    }

    // The example prints the following to the console
    // ID: 1, Jane Robinson
    // Course: Programming in Java masters, Length: 2 years
    // Enrolled: 05 Dec 2021
    // Expected Finish Date: 05 Dec 2023
    // Current Skill Level Intermediate
    // Record created: 04 Dec 2021

    // ID: 1, Jane Robinson
    // Course: Programming in C# masters, Length: 2 years
    // Last updated: 09 Dec 2021

    // Attempting student login before changing password, login successful
    // Attempting student login after changing password, login failed
    </code></pre>
                    <!-- !SECTION Properties -->
                    <!-- SECTION Events -->
                    <h3 id="Events">Events</h3>
                    <p>An event is a way for a class to communicate with other objects that something within it has occurred. This could be a button click, completion of
                        a task, change of state, etc. The class that <i>raises</i> the event is know as a <i>publisher</i> and the objects receiving the event
                        are known as <i>subscribers</i>. When a publisher declares an event, it in turn allows the declaration of a special type of multicast
                        <a href="#delegate">delegate</a> and provides methods that a subscriber can use to add or remove instances of the delegate. When an event is
                        raised the delegate is then used to invoke a method within the subscriber which in this case is known as an <i>event handler</i>. By being
                        multicast the delegate allows multiple objects to subscribe to the same event or for a subscriber to use the same event handler to handle the same
                        type of event from multiple publishers.</p>
                    <p>Whilst a delegate can declare a signature that defines a return type, a multicast delegate only returns a value from the last event handler that
                        was invoked. For this reason the standard event delegate signature is one that returns void and contains two parameters. The first parameter is an
                        object that refers to the instance that raised the event. The second is a type that can optionally contain event data including values that can be
                        changed in the event handler to effectively supply a return value. A common type for containing event data is one that is
                        <a href="#Inheriting_types">derived</a> from the <code>EventArgs</code> class.</p>
                    <p>C# .NET provides many built-in delegates for use with events which are suffixed with <i>EventHandler</i>. There two most common are
                        <code>EventHandler</code> and <code>EventHandler&lt;TEventArgs&gt;</code>.</p>
                    <p><code>EventHandler</code> is used when the event does not include event data. It declares <code>EventArgs</code> as the second parameter which is
                        set to the <code>EventArg.Empty</code> field when invoking the event.</p>
                    <p><code>EventHandler&lt;TEventArgs&gt;</code> can be used to send event data. Originally it was required that the return data type be derived from
                        <code>EventArgs</code> which is why <i>TEventArgs</i> is still mentioned in much of the online documentation, but that constraint has been removed
                        and any type can now be specified. An <code>EventArgs</code> derived type is still advantageous, particularly where more complex types are
                        employed and for reasons of <a href="#Polymorphism_implementation">polymorphism</a>. If there is a requirement to return a value then a reference
                        type should be used.</p>
                    <p>An event can't be invoked from outside the class that contains it so an additional method is required to call the event. It is common that such a
                        method be marked <code>virtual</code> so they can be <a href="#override">overridden</a> if the class can be inherited. The
                        naming convention for such a method is the name of the event prefixed with <i>On</i> such as <code>OnEvent</code>. The naming convention for
                        subscriber event handlers is the instance or type identifier followed by an underscore followed by the event identifier such as
                        <code>instance_SomeEvent</code>. An event handler can also be in the form of a <a href="#Lambda_Expression">lambda expression</a>.</p>
                    <p><em>Note:</em> <i>When an event has multiple subscribers the order in which they receive the event is not always guarantied. A subscriber should
                        not rely on another having already handled the event.</i></p>
                    <p>In the following example the <code>Clock</code> class declares <code>Started</code>, <code>Stopped</code> and <code>Ticked</code> events and the
                        <code>Program</code> class subscribes and declares event handlers to all of them. The <code>Clock</code> class also declares a <code>Timer</code>
                        instance that provides a continuous <code>Timer.Elapsed</code> event at one second intervals which is handled by a <code>Timer_Elapsed</code>
                        event handler. This in turn calls the <code>OnTicked</code> method that then invokes the <code>Ticked</code> event. When the
                        <code>_clock_Tick</code> event handler in <code>Program</code> is invoked it writes the current time to the console. The
                        <code>Clock.Started</code> event takes a <code>DateTime</code> type which is used to pass the start time to the <code>_clock_Started</code> event
                        handler. The <code>Clock.Stopped</code> event takes a custom type <code>StoppedEventArgs</code> derived from <code>EventArgs</code> which is used
                        to pass the stop time to the <code>_clock_Stopped</code> event handler. <code>StoppedEventArgs</code> has a <code>DateTime</code> type
                        <code>Time</code> property that is set by the constructor. The example also employs <code>Console.ReadKey</code> to test whether the user has
                        pressed the <kbd>enter</kbd> key to end the program.</p>
<pre><code>using System;
using System.Timers;

namespace Events
{
    public class Clock
    {
        Timer _timer;

        // An event that can be raised when the clock is started
        // EventHandler&lt;TEventArgs&gt; delegate type is declared
        // The EventArgs parameter is the DateTime type
        public event EventHandler&lt;DateTime&gt; Started;

        // An event that can be raised when the clock is stopped
        // The EventArgs parameter is the custom StoppedEventArgs type
        public event EventHandler&lt;StoppedEventArgs&gt; Stopped;

        // An event that can be raised when the clock ticked. It does
        // not have event data so EventHandler delegate is declared
        // as it declares dataless EventArgs for the second parameter
        public event EventHandler Ticked;

        // A method to call to invoke the Started event
        protected virtual void OnStarted()
        {
            // Create a parameter to pass to the Started event
            DateTime args = DateTime.Now;
            // Raise the Started event
            Started?.Invoke(this, DateTime.Now);
        }

        // A method to call to invoke the Stopped event
        protected virtual void OnStopped()
        {
            // Create an instance of custom StoppedEventArgs
            // to pass as a parameter to pass to the Started event
            StoppedEventArgs stoppedEventArgs = new(DateTime.Now);
            // Raise the Stopped event
            Stopped?.Invoke(this, stoppedEventArgs);
        }

        // A method to call to invoke the Ticked event
        protected virtual void OnTicked()
        {
            // Raise the Ticked event, no EventArgs value is to be passed
            // so it is set to the static read-only EventArgs.Empty field
            Ticked?.Invoke(this, EventArgs.Empty);
        }

        // Event handler for Timer.Elapsed event
        private void Timer_Elapsed(object sender, ElapsedEventArgs e)
        {
            OnTicked();
        }

        public void Start(double interval)
        {
            _timer = new(interval);
            // Subscribe to the Timer.Elapsed event and
            // declare Timer_Elapsed as the event handler
            _timer.Elapsed += Timer_Elapsed;
            _timer.AutoReset = true;
            _timer.Enabled = true;
            OnStarted();
        }

        public void Stop()
        {
            _timer.Stop();
            // The timer object is disposed so that the
            // garbage collector can remove it from memory
            _timer.Dispose();
            OnStopped();
        }
    }

    // Create a custom that inherits from EventArgs
    // to be passed by the Clock.Stopped event
    public class StoppedEventArgs : EventArgs
    {
        public StoppedEventArgs(DateTime time) =&gt; Time = time;
        public DateTime Time { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Clock _clock = new();
            // Subscribe to the Clock.Started event and
            // declare _clock_Started as the event handler
            _clock.Started += _clock_Started;

            // Subscribe to the Clock.Stopped event and declare
            // an event handler using a lambda expression
            _clock.Stopped += (s, e) =&gt;
            {
                Console.WriteLine($"\rThe clock was stopped at {e.Time:T}");
            };

            // Start the clock with a tick interval of 1 second (1000 ms)
            _clock.Start(1000);
            Console.WriteLine("Press enter to stop the clock");

            // Subscribe to the Clock.Ticked event and
            // declare _clock_Ticked as the event handler
            _clock.Ticked += _clock_Ticked;

            // Wait until the user presses the 'enter' key
            while (Console.ReadKey(true).Key != ConsoleKey.Enter) { }

            // Unsubscribe from the Clock.Ticked event
            _clock.Ticked -= _clock_Ticked;
            _clock.Stop();
        }

        // Event handler for Clock.Started event
        private static void _clock_Started(object sender, DateTime e)
        {
            Console.WriteLine($"The clock started at {e:T}");
        }

        // Event handler for Clock.Ticked event
        private static void _clock_Ticked(object sender, EventArgs e)
        {
            Console.Write($"\rCurrent time: {DateTime.Now:T}");
        }
    }
}
</code></pre>
                    <p>There are situations where you may wish to cancel an event. One such scenario is when closing a program and you want to give the user the
                        opportunity to save unsaved data before this occurs. C# .NET provides the <code>CancelEventHandler</code> delegate to achieve this which passes
                        a <code>CancelEventArgs</code> parameter to the event handler. <code>CancelEventArgs</code> has a bool type property <code>Cancel</code> which can
                        be set in the event handler to indicate if the event should be cancelled.</p>
                    <p>In the following example the <code>ApplicationManager</code> class declares an <code>Exiting</code> event that in turn declares a
                        <code>CancelEventHandler</code> type delegate. The <code>Program</code> class subscribes to the <code>Exiting</code> event and declares an event
                        handler for this using a <a href="#Lambda_Expression">lambda expression</a>. Within the <code>Main</code> method are two while loops, one testing
                        if the user presses the <kbd>x</kbd> key, nested in another that tests if the <code>AllowExit</code> property is true. When the <kbd>x</kbd> key is
                        pressed, <code>Exit</code> is called which calls <code>OnExiting</code> which invokes the <code>Exiting</code> event. Within the
                        <code>Exiting</code> event handler in <code>Program</code>, the <code>CancelEventArgs.Cancel</code> property is set <code>true</code> or
                        <code>false</code> depending if the <kbd>y</kbd> key is pressed, then passed back to <code>OnExiting</code> then to <code>Exit</code> where it
                        sets the <code>AllowExit</code> property. Execution passes back to the while loops which it exits if <code>AllowExit</code> is true and the
                        program then terminates.</p>
<pre><code>using System;
using System.ComponentModel;

namespace CancelEvent
{
    public class ApplicationManager
    {
        bool ExitingCalled;

        // An event with CancelEventArgs type parameter
        public event CancelEventHandler Exiting;

        public bool AllowExit { get; set; }

        // The OnExiting method takes a CancelEventArgs parameter
        // so that its Cancel property can be passed back
        protected virtual void OnExiting(CancelEventArgs e)
        {
            Exiting?.Invoke(this, e);
        }

        public void Exit()
        {
            // We don't want to call an event while
            // we're still working on a previous one
            if (!ExitingCalled)
            {
                ExitingCalled = true;
                CancelEventArgs args = new();
                OnExiting(args);
                if (args.Cancel)
                {
                    ExitingCalled = false;
                    return;
                }
                // Use the CancelEventArgs.Cancel property set by the
                // Exiting event handler to set the AllowExit property
                AllowExit = true;
            }
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ApplicationManager _applicationManager = new();
            // Subscribe to the _applicationManager.Exiting event and
            // declare _applicationManager_Exiting as the event handler
            _applicationManager.Exiting += (s, e) =&gt;
            {
                Console.WriteLine("Are you sure you want to exit the program");
                Console.WriteLine("Press y to confirm ending the program or any other key to cancel");
                // Set the CancelEventArgs.Cancel property true if user does not press 'y'
                e.Cancel = Console.ReadKey(true).Key != ConsoleKey.Y;
            };

            // Loop until the user presses the 'y' key which sets AllowExit to true
            // depending on the Exiting event CancelEventArgs.Cancel property
            while (!_applicationManager.AllowExit)
            {
                Console.Clear();
                Console.WriteLine("Press x to exit the program");
                // Wait until the user presses the 'x' key
                while (Console.ReadKey(true).Key != ConsoleKey.X) { }
                _applicationManager.Exit();
            }
            Console.WriteLine("You have exited the program");
        }
    }
}

// The example writes the following to the console
// Press x to exit the program
// Are you sure you want to exit the program
// Press y to confirm ending the program or any other key to cancel
// You have exited the program
</code></pre>

                    <!-- !SECTION Events -->
                    <!-- SECTION Indexers -->
                    <h3 id="Indexers">Indexers</h3>
                    <p>An indexer allows an object to be indexed like an array. It is similar to a <a href="#Properties">property</a> but also takes an index value to set
                        or get a specific instance. To declare an indexer first an array or collection backing field is declared to store the instances to be indexed. The
                        indexer is then declared using an optional <a href="#Access_modifiers">access modifier</a>, followed by the <code>this</code> keyword, followed by
                        the type of indexer, followed by square brackets that contain one or more indexes separated by commas, with each consisting of the type of index
                        and an index identifier. Accessors are then used to set and/or get the instances from the backing field using the indexes that are passed in. The
                        same rules as as those for read/write and accessibility of properties and accessors also apply to indexers except that an indexer cannot be static
                        and an indexer cannot be auto-indexed. Indexers can be <a href="#Signatures,_parameters_and_overloading">overloaded</a>.</p>
                    <p>Access to an indexer by code external to the type is in the form of <code>instance.Indexer[index]</code></p>
                    <p>The following example declares a string collection which uses an indexer to index instances of itself. The <code>Program</code> class creates a new
                        <code>StringCollection</code> instance, assigns the string "Hello World" to the instance at index 0 in the collection, then retrieves the same and
                        finally writes its value to the console.</p>
<pre><code>using System;

namespace Indexers
{
    class StringCollection
    {
        private string[] _strings = new string[10];

        public string this[int i]
        {
            get =&gt; _strings[i];
            set =&gt; _strings[i] = value;
        }
    }

    class Program
    {
        static void Main()
        {
            StringCollection stringCollection = new();
            stringCollection[0] = "Hello world";
            Console.WriteLine(stringCollection[0]);
        }
    }
}

// The example writes the following to the console
// Hello world
</code></pre>
                    <!-- !SECTION Indexers -->
                    <!-- SECTION Finalizers -->
                    <h3 id="Finalizers">Finalizers</h3>
                    <p>A finalizer is used to perform any cleanup of the class when it is no longer in use. The compiler adds a default finalizer to each instance of a
                        class that is created. As implementing a finalizer is a rare and complex subject it won't be discussed in this guide.</p>
                    <p><em>Note:</em><i>In earlier versions of the C# standard a 'finalizer' was called a 'destructor'.</i></p>
                    <!-- !SECTION Finalizers -->
<!-- TODO finish signatures info and add example  -->
<!-- TODO add info about parameters, passing by reference, optional arguments, passing an array -->
                    <!-- SECTION Signatures parameters and overloading -->

                    <h3 id="Signatures,_parameters_and_overloading">Signatures, parameters and overloading</h3>
                    <p>  A method, constructor and indexer have a signature which is declared by its identifier and the type, number, passing mode and left right order of
                        its parameters. Access modifiers and a method's return type are not part of the signature.</p>
                    <p></p>


                    <!-- !SECTION Signatures parameters and overloading -->







                    <!-- SECTION struct -->
                    <h3 id="struct">struct</h3>
                    <p>A <i>structure</i> usually referred to by its keyword <code>struct</code> is similar to a class with the following main differences.</p>
                    <ul>
                        <li>A struct is a value type</li>
                        <li>The static, abstract and sealed modifiers cannot be applied to a struct</li>
                        <li>The readonly modifier can be applied to a struct</li>
                        <li>An instance field or property in a struct can't be initialized when a struct is declared.</li>
                        <li>A constructor in a struct must initialize all instance fields</li>
                        <li>A struct cannot have a parameterless constructor (<em>Note:</em> <i>will be allowed beginning with C# 10.0</i>) </li>
                        <li>A struct cannot have a finalizer</li>
                        <li>A struct cannot inherit or be inherited by a another class or struct</li>
                    </ul>
                    <p>A struct is normally used to create a basic data type with little or no functionality. Within C# <code>int</code>, <code>double</code>,
                        <code>char</code> and <code>bool</code> are all examples of structs. As a struct is a value type so all instance fields it contains must be
                        assigned a value before it can be used. Although a parameterless constructor can't be declared in a struct, the compiler creates one which sets
                        all instance fields to their default values. This can then use this when instantiating a struct with the <code>new</code> keyword. If all instance
                        fields in a struct are accessible then a struct can be instantiated without using the <code>new</code> keyword. For example an integer can be
                        assigned the value 0 either by <code>int x = new();</code> or <code>int x = 0;</code>.</p>
                    <p>The following example declares a struct called <code>Box</code> with <code>Width</code>, <code>Height</code> and <code>Depth</code> fields and a
                        method called <code>GetVolume</code>. It demonstrates several ways to declare and assign values to a struct and then writes the values to the
                        console.</p>
<pre><code>using System;

namespace Structs
{
    public struct Box
    {
        public Box(int width, int height, int depth)
        {
            Width = width;
            Height = height;
            Depth = depth;
        }

        // Syntax error, a struct cannot contain a parameterless constructor
        //public Box() { }

        // Syntax error, a structs constructor must assign values to all instance fields
        //public Box(double width)
        //{
        //    Width = width;
        //    Height = 1;
        //}

        // This is OK as all instance fields have been assigned a value
        public Box(int width)
        {
            Width = width;
            Height = 1;
            Depth = 1;
        }

        public int Width;

        public int Height;

        public int Depth;

        public int GetVolume()
        {
            return Width * Height * Depth;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Create a new box then set its field values
            Box box1 = new();
            box1.Width = 1;
            box1.Height = 2;
            box1.Depth = 3;

            // Create a box and set its field values in the constructor
            Box box2 = new(2, 3, 4);

            // Create a box using an alternate constructor
            Box box3 = new(2);

            // Create a box and set its field values with an object-initializer
            Box box4 = new()
            {
                Width = 4,
                Height = 5,
                Depth = 6
            };

            Console.WriteLine($"Box1 Width: { box1.Width}, Height: {box1.Height}, Length: {box1.Depth}, Volume: {box1.GetVolume()}");
            Console.WriteLine($"Box2 Width: { box2.Width}, Height: {box2.Height}, Length: {box2.Depth}, Volume: {box2.GetVolume()}");
            Console.WriteLine($"Box3 Width: { box3.Width}, Height: {box3.Height}, Length: {box3.Depth}, Volume: {box3.GetVolume()}");
            Console.WriteLine($"Box4 Width: { box4.Width}, Height: {box4.Height}, Length: {box4.Depth}, Volume: {box4.GetVolume()}");

            // If all instance fields are accessible a struct can be instantiated
            // without the new keyword but instance fields must be set before it can be used
            Box box5;

            // Syntax error, use of unassigned variable 'box5'
            //var v = box5.GetVolume();

            box5.Width = 5;
            box5.Height = 6;
            box5.Depth = 7;

            Console.WriteLine($"Box5 Width: { box5.Width}, Height: {box5.Height}, Length: {box5.Depth}, Volume: {box5.GetVolume()}");

            // Although you can't declare a parameterless constructor the compiler always creates one that assigns all instance
            // fields their default values. When displayed box6 will have all fields set to 0 resulting in a volume of 0
            Box box6 = new();

            Console.WriteLine($"Box6 Width: { box6.Width}, Height: {box6.Height}, Length: {box6.Depth}, Volume: {box6.GetVolume()}");
        }
    }
}

// The example writes the following to the console
// Box1 Width: 1, Height: 2, Length: 3, Volume: 6
// Box2 Width: 2, Height: 3, Length: 4, Volume: 24
// Box3 Width: 2, Height: 1, Length: 1, Volume: 2
// Box4 Width: 4, Height: 5, Length: 6, Volume: 120
// Box4 Width: 5, Height: 6, Length: 7, Volume: 210
// Box6 Width: 0, Height: 0, Length: 0, Volume: 0
</code></pre>
                    <!-- !SECTION struct -->
<!-- TODO add content about records -->
                    <!-- SECTION record -->
                    <h3 id="record">record</h3>
                    <p>A <code>record</code> provides all the same functionality of a class with some notable differences. It is a
                        <a href="#Reference_type">reference type</a> with <a href="#Value_type">value type</a> equality. Two record variables are equal if their
                        definitions are identical and all field values are the same. A record also provides <i>positional syntax</i> for declaring immutable
                        <a href="#Properties">properties</a> through the use of <i>positional parameters</i>. This results in the compiler automatically creating a
                        <a href="#Access_modifiers">public</a> auto-implemented property with an <code>init</code> setter for each parameter and a constructor that sets
                        the properties from the parameters. This allows for a much more concise syntax.  </p>

                    <!-- !SECTION record -->

                    <!-- SECTION delegate -->
                    <h3 id="delegate">delegate</h3>
                    <p>A delegate allows you to create a reference to a method that can then be passed as a parameter. It does this by declaring the
                        <a href="Signatures,_parameters_and_overloading">signature</a> of the method which in this case includes the return type. It is declared using an
                        optional <a href="#Access_modifiers">access modifier</a>, followed by the <code>delegate</code> keyword, then the <i>return type</i>, then an
                        identifier that is unique within the <a href="#Dependencies_and_Namespaces">namespace</a>, followed by a pair of round brackets that can
                        optionally contain <a href="#Signatures,_parameters_and_overloading">parameters</a>. Delegates are created using the delegate's identifier,
                        followed by an identifier unique within the local scope and then assigning it a named method which can be either an instance or static. This can
                        then be used to invoke the method as if it was called directly. The <code>delegate</code> keyword can also be used as an operator to create
                        <a href="#Anonymous_functions">anonymous methods</a> that don't require the declaration of a named method for assignment.</p>
                    <p>A common use for delegates is in <a href="#Events">events</a> in which a method known as an <i>event handler</i> is invoked by a special kind of
                        multicast delegate that is declared by the event.</p>
                    <p>The following example demonstrates delegate declaration and use.</p>
<pre><code>using System;

namespace Delegates
{
    // A 'delegate' declares the method signature including return type
    // Delegate 'Calculate' takes in two int's and returns an int
    public delegate int Calculate(int value1, int value2);

    public class MathFunctions
    {
        // A static method 'Add' with the same return type
        // and signature as the delegate Calculate is declared
        public static int Add(int x, int y)
        {
            return x + y;
        }

        // An instance method 'Multiply' with the same return type
        // and signature as the delegate Calculate is declared
        public int Multiply(int x, int y)
        {
            return x * y;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Create an instance of 'Calculate' that assigns Add
            Calculate add = MathFunctions.Add;

            // Create an instance of 'Calculate' that assigns Multiply
            // As Multiply is an instance method an instance of
            // MathFunctions is required to access it
            Calculate multiply = new MathFunctions().Multiply;

            // Using the add delegate to invoke Add
            Console.WriteLine($"2 + 3 = {add(2, 3)}");

            // Using the multiply delegate to invoke Multiply
            Console.WriteLine($"5 x 3 = {multiply(5, 3)}");
        }
    }
}

// The example writes the following to the console
// 2 + 3 = 5
// 5 x 3 = 15
</code></pre>
                    <!-- !SECTION delegate -->
<!-- TODO add inheriting interfaces and records -->
                    <!-- SECTION Inheriting types -->
                    <h3 id="Inheriting_types">Inheriting types</h3>
                    <p>Inheritance is one of the main concepts in Object Oriented Programming. It allows you to create a parent type with common features that multiple
                        different child types can inherit and expand upon. In C# a parent type is called a base type, a child a derived type and
                        <a href="#class">classes</a>, <a href="#record">records</a> and <a href="#interface">interfaces</a> can be inherited. C# only allows
                        single inheritance, that is a derived type can only inherit from one base type but it does allow for multiple generations which means a base
                        type can be inherited by a second which it turn can inherited by a third and so on. As a result, members that are in the base type will be
                        available in each generation of derived types with the following exceptions.</p>
                    <ul>
                        <li>Static constructors</li>
                        <li>Instance constructors</li>
                        <li>Finalizers</li>
                    </ul>
                    <p>Events can only be invoked from within the type they are declared so to <a href="#Raising_base_class_events_in_a_derived_class">raise a base type
                        event from a derived type</a> a common pattern is to declare a method in the base type that can be called from the derived type to invoke the
                        event. The availability of all other members in a derived type is dependent on the <a href="#Scope_and_Modifiers">accessibility</a> of a member in
                        the base type. Where members in both a base and derived type have the same identifier, where neither are marked as either virtual or override and
                        where the member in the base type has an accessibility modifier other than private, the the derived member will hide the base member. The two
                        members don't have to be of the same type or have the same <a href="#Signatures,_parameters_and_overloading">signature</a>. For example a property
                        in a base type can be hidden by a method. Access to a hidden member can still be obtained through use of the <a href="#base_keyword">base</a>
                        keyword. When a member is hidden the code editor will indicate this on the hiding member in the derived type with a
                        <u class="warning">warning</u>. This can be removed by marking the member with the <code>new</code> keyword. A class that is marked as
                        <a href="#static">static</a> or <a href="#sealed">sealed</a> can't be inherited.</p>
                    <p>The following example demonstrates the syntax for inheriting a class. First base class <code>A</code> is declared as normal. Derived Class
                        <code>B</code> is then declared followed by a colon, then the name of the class to be inherited, followed by the code block for class
                        <code>B</code>.</p>
<pre><code>using System;

namespace InheritanceSyntax
{
    // Base class A is fist declared
    class A { }

    // Derived class B inherits class A
    class B : A { }
}
</code></pre>
                    <p>It is important to note that a derived class cannot be made more accessible than a base class. In this next example base class <code>A</code>
                        does not have an accessibility keyword applied so it will be internal by default. When derived public class <code>B</code> then attempts to
                        inherit internal class <code>A</code> this results in a syntax error. Following this base public class <code>C</code> is declared then derived
                        class <code>D</code> inherits class <code>C</code>. Although <code>D</code> is internal by default, this is allowed as <code>D</code> is less
                        accessible that <code>C</code>. Then when public class <code>E</code> inherits <code>D</code>, again there is an error as <code>E</code> is more
                        accessible than <code>D</code>.</p>
                    <p>This illustrates that relying on the default accessibility for a class or interface can easily lead to unexpected errors so it is advisable to
                        always use the <code>internal</code> keyword if that is your intention. This is important as the default template provided by Visual Studio does
                        not provide an accessibility keyword so if you see an 'Inconsistent accessibility' error, check that the base class has been declared public.</p>
<pre><code>using System;

namespace InheritanceAccessibility
{
    // Base class A default accessibility is internal
    class A { }

    // Syntax error, derived public class B can't be
    // more accessible than its internal base class A
    //public class B : A { }

    public class C { }

    // This is OK as internal class D is less
    // accessible than public class C
    class D : C { }

    // Syntax error, derived public class E can't be
    // more accessible than its internal base class D
    // even though D inherits from public class C
    //public class E : D { }
}
</code></pre>
                    <p>The following example creates a base class called <code>Animal</code> with a public property <code>Legs</code> that provides access to a private
                        field <code>_Legs;</code>. Both classes <code>Bird</code> and <code>Cat</code> inherit and extend the <code>Animal</code> class with
                        <code>Bird</code> adding the property <code>Wings</code> and <code>Cat</code> the property <code>Meowing</code>. In the <code>Program</code>
                        class an instance of <code>Bird</code> is created setting values for both <code>Legs</code> and <code>Wings</code> and an instance of
                        <code>Cat</code> setting values for both <code>Legs</code> and <code>Meowing</code>. A message describing each is then written to the console with
                        their corresponding properties.</p>

<pre><code>using System;

namespace InheritanceExample
{
    // Declare a base class called 'Animal'
    public class Animal
    {
        public int Legs { get; set; }
    }

    // The derived class 'Bird' inherits 'Animal'
    // and adds the property 'Flying'
    public class Bird : Animal
    {
        public string Flying { get; set; }
    }

    // The derived class 'Cat' inherits 'Animal'
    // and adds the property 'Meowing'
    public class Cat : Animal
    {
        public string Meowing { get; set; }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // An instance of 'Bird' class is created
            Bird bird = new()
            {
                Legs = 2,
                Flying = "Slowly"
            };

            // An instance of 'Cat' class is created
            Cat cat = new()
            {
                Legs = 4,
                Meowing = "Loudly"
            };

            Console.WriteLine($"The bird has {bird.Legs} legs and is flying {bird.Flying}");
            Console.WriteLine($"The cat has {cat.Legs} legs and is meowing {cat.Meowing}");
        }
    }
}

// The example writes the following to the console
// The bird has 2 legs and is flying Slowly
// The cat has 4 legs and is meowing Loudly
</code></pre>
                    <!-- !SECTION Inheriting types -->
                    <!-- TODO change to refer to types and that only applicable to classes and records -->
                    <!-- SECTION Raising base class events in a derived class -->
                    <h3 id="Raising_base_class_events_in_a_derived_class">Raising base class events in a derived class</h3>
                    <p>An event can only be invoked within the class it is declared. A common pattern to invoke a base class event in a derived class is to declare a
                        virtual method in the base class to invoke the event. This can then be overridden in the derived class where it can be used to indirectly call the
                        base class event. This also allows for additional code to be added and executed within the method before or after the event is raised.</p>
                    <p>CodeExample</p>
<pre><code>using System;

namespace CallingBaseClassEvents
{
    public class BaseClass
    {
        // An event to raise when the program is closing.
        public event EventHandler ProgramClosing;

        // A method to call to invoke the ProgramClosing event.
        protected virtual void OnProgramClosing(EventArgs e)
        {
            // Raise the ProgramClosing event.
            ProgramClosing.Invoke(this, e);
        }
    }

    public class ProgramManager : BaseClass
    {
        protected override void OnProgramClosing(EventArgs e)
        {
            // Do any program closing processing here.

            // Call the OnProgramClosing method in the base class.
            base.OnProgramClosing(e);

            // Do any program closed processing here.
        }

        // The method to call to close the program.
        public void CloseProgram()
        {
            OnProgramClosing(EventArgs.Empty);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            ProgramManager programManager = new();

            // Subscribe to the ProgramManager.ProgramClosing event and
            // declare an event handler using a lambda expression.
            programManager.ProgramClosing += (s, e) =&gt;
            {
                Console.WriteLine("The program is exiting");
            };

            Console.WriteLine("Press return to exit the program");

            // Wait until the user presses the 'enter' key.
            while (Console.ReadKey(true).Key != ConsoleKey.Enter) { }

            programManager.CloseProgram();

            Console.WriteLine("The program has exited");
        }
    }
}

// The example writes the following to the console
// Press return to exit the program
// The program is exiting
// The program has exited
</code></pre>
                    <!-- !SECTION Raising base class events in a derived class -->
                    <!-- SECTION Polymorphism implementation -->
                    <h3 id="Polymorphism_implementation">Polymorphism implementation</h3>
                    <p>In the previous example each derived class was created and the methods called separately. Ideally it would have been better to do this all through
                        a loop. This can be done as <a href="#Polymorphism">polymorphism</a> allows you to substitute a parent for a child then when the parent's method
                        is called at runtime it will be substituted for the child's.</p>

                    <p>In this example example a base class <code>LogAnalyzer</code> is declared that has a virtual <code>DisplayMessage</code> method. Derived class
                        <code>LogAnalyzer1</code> inherits from <code>LogAnalyzer</code> and <code>LogAnalyzer2</code> inherits from <code>LogAnalyzer1</code> with each
                        overriding <code>DisplayMessage</code> with its own implementation. In the <code>Program</code> class a list of type <code>LogAnalyzer</code> is
                        created that adds an instance of the base and the two derived classes. A foreach loop then loops through the list using a
                        <code>LogAnalyzer</code> type iterator calling the <code>DisplayMessage</code> method which at runtime is replaced by the overridden version of
                        each item.</p>
<pre><code>using System;
    using System.Collections.Generic;

    namespace Polymorphism
    {
        public class LogAnalyzer
        {
            public virtual void DisplayMessage()
            {
                Console.WriteLine("Log message has occurred");
            }
        }

        public class LogAnalyzer1 : LogAnalyzer
        {
            public override void DisplayMessage()
            {
                Console.WriteLine("Log message type 1 has occurred");
            }
        }

        public class LogAnalyzer2 : LogAnalyzer1
        {
            public override void DisplayMessage()
            {
                Console.WriteLine("Log message type 2 has occurred");
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                List&lt;LogAnalyzer&gt; logAnalyzers = new()
                {
                    new LogAnalyzer(),
                    new LogAnalyzer1(),
                    new LogAnalyzer2(),
                };

                foreach (LogAnalyzer logAnalyzer in logAnalyzers)
                {
                    logAnalyzer.DisplayMessage();
                }
            }
        }
    }

    // The example writes the following to the console
    // Log message has occurred
    // Log message type 1 has occurred
    // Log message type 2 has occurred
</code></pre>
                    <!-- !SECTION Polymorphism implementation -->

<!-- TODO Rewrite the following -->
<!-- TODO using base in override -->
                    <!-- SECTION base keyword -->
                    <h3 id="base_keyword">base keyword</h3>
                    <p>Although constructors cannot be inherited those in the base class are still called after the derived constructor is called but before the enclosed
                        code of the derived class constructor is executed. Additionally the <code>base</code> keyword can be used in a derived class to call constructors
                        and overridden instance members within the base class. Only those in the immediate base class in the derived class declaration can be accessed.
                        Lastly if a base class is provided with one or more parameterized constructors then the compiler forgoes providing the default parameterless
                        constructor. As a result when inheriting such a class you will then need to provide the derived class with at least one constructor with the same
                        signature as one of the constructors in the base class. The constructor in the derived class must call the constructor in the base class by using
                        the <code>base</code> keyword and pass the arguments provided to it on to the base class constructor.</p>
                    <p>In this example <code>BaseClass</code> has a parameterless constructor that writes to the console when it is called, then sets a value in a
                        a field called <code>_Field</code>. It also has a parameterized constructor that takes a value which it uses to set <code>_Field</code>
                        and a virtual method <code>GetFieldValue</code> that returns the value of <code>_Field</code>. <code>DerivedClass</code> inherits from
                        <code>BaseClass</code>. It too has a parameterless constructor that writes to the console when it is called, then sets a value in its own
                        field called <code>_Field</code>. It also has a parameterized constructor which first calls its counterpart in the base class through use of the
                        <code>base</code> keyword which requires passing all arguments it receives to the base class. The derived class also overrides
                        <code>GetFieldValue</code> returning its own <code>_Field</code> value and has a method called <code>CallBaseMethod</code> which, using the
                        <code>base</code> keyword, calls <code>GetFieldValue</code> in the base class.</p>
                    <p>In the <code>Program</code> class an instance of <code>DerivedClass</code> is created using the parameterless constructor which results in first
                        the base class then the derived class constructor being called. Then the return value of <code>GetFieldValue</code> followed by
                        <code>CallBaseMethod</code> are written to the console. Next a second instance of <code>DerivedClass</code> is created using the parameterized
                        constructor with the string 'instance 2' passed in and again the return value of <code>GetFieldValue</code> followed by
                        <code>CallBaseMethod</code> are written to the console.</p>
                    <p>The example also declares a class <code>BaseClass2</code> which contains a parameterized constructor. Deriving the class
                        <code>DerivedClass2</code> from <code>BaseClass2</code> without providing a parameterized constructor with the same signature as that of the base
                        class results in a syntax error.</p>

<pre><code>using System;

namespace BaseKeyword
{
    public class BaseClass
    {
        private string _Field;

        public BaseClass()
        {
            Console.WriteLine("Base class constructor");
            _Field = "Base class";
        }

        public BaseClass(string value)
        {
            _Field = "Base Class " + value;
        }

        public virtual string GetFieldValue()
        {
            return _Field;
        }
    }

    public class DerivedClass : BaseClass
    {
        private string _Field;

        public DerivedClass()
        {
            Console.WriteLine("Derived class constructor");
            _Field = "Derived class";
        }

        public DerivedClass(string value) : base(value)
        {
            _Field = "Derived Class " + value;
        }

        public override string GetFieldValue()
        {
            return _Field;
        }

        public string CallBaseMethod()
        {
            return base.GetFieldValue();
        }
    }

    public class BaseClass2
    {
        public BaseClass2(int value) { }
    }

    // Uncommenting the following results in the error
    // There is no argument given that corresponds to the
    // required formal parameter 'value' of 'BaseClass2.BaseClass2(int)'
    //public class DerivedClass2 : BaseClass2 { }

    class Program
    {
        static void Main(string[] args)
        {
            DerivedClass instance1 = new();
            Console.WriteLine();
            Console.WriteLine(instance1.GetFieldValue());
            Console.WriteLine(instance1.CallBaseMethod());

            Console.WriteLine();
            DerivedClass instance2 = new("instance 2");
            Console.WriteLine(instance2.GetFieldValue());
            Console.WriteLine(instance2.CallBaseMethod());
        }
    }
}

// The example writes the following to the console
// Base class constructor
// Derived class constructor

// Derived class
// Base class

// Derived Class instance 2
// Base Class instance 2
</code></pre>
                    <!-- !SECTION base keyword -->

                    <!-- SECTION Overriding object members -->
                    <h3 id="Overriding_object_members">Overriding object members</h3>
                    <p>All classes in C#, even the ones you write, are ultimately derived from the <i>object</i> class. This means that even if you don't explicitly use
                        the syntax to inherit from <code>object</code> our class will still contain the following overridable members</p>
                    <ul>
                        <li>Equals(Object)</li>
                        <li>Finalize()</li>
                        <li>GetHashCode()</li>
                        <li>ToString()</li>
                    </ul>
                    <p>the following non-overridable members</p>
                    <ul>
                        <li>GetType()</li>
                        <li>MemberwiseClone()</li>
                    </ul>
                    <p>and the following static members</p>
                    <ul>
                        <li>Equals(Object, Object)</li>
                        <li>ReferenceEquals(Object, Object)</li>
                    </ul>
                    <p>The default implementation of <code>ToString()</code> is to return the result of <code>GetType()</code> which is the fully qualified type name. As
                        a result it is not uncommon to override <code>ToString()</code> with something more meaningful. In the following example the class
                        <code>Person</code> takes in first and last name arguments in its constructor and <code>ToString()</code> is overridden to combine the first and
                        last names then return the full name which is written to the console.</p>
<pre><code>using System;

namespace OverridingObjectMembers
{
    public class Person
    {
        public string FirstName { get; set; }

        public string LastName { get; set; }

        public override string ToString()
        {
            return FirstName + " " + LastName;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Person person = new()
            {
                FirstName = "Denise",
                LastName = "Jones"
            };

            Console.WriteLine($"This person is {person.ToString()}");
        }
    }
}

// The example writes the following to the console
// This person is Denise Jones
</code></pre>
                    <!-- !SECTION Overriding object members -->
                    <!-- SECTION interface -->
                    <h3 id="interface">interface</h3>
                    <p>"An interface is a contract" has to be one of the worst explanations as to what an interface is, yet it still persists throughout much of the
                        literature you may find on line, including that of Microsoft's own C# reference. So what is an interface.</p>
                    <p>Take a computer manufacturer. They can't anticipate every printer, keyboard, mouse, etc, that will be plugged into their devices. To allow for
                        this, the industry as a whole has created a set of specifications of which various devices must adhere to, so that they are compatible. For a
                        keyboard this may be the signals it must produce when a key is pressed, but it is not the computer manufacturer's job to tell the keyboard
                        manufacturer how to make their keyboards. Providing that the specifications are met the keyboard manufacturer is free to design it as they like.
                        An interface works on a similar basis by declaring which members a class or struct will have without saying how they are to be implemented.</p>
                    <p>An interface is created using the <code>interface</code> keyword. The following signature only members can be declared within an interface.</p>
                    <ul>
                        <li><a href="#Methods">Methods</a></li>
                        <li><a href="#Properties">Properties</a></li>
                        <li><a href="#Indexers">Indexers</a></li>
                        <li><a href="#Events">Events</a></li>
                    </ul>
                    <p>Members that are not implemented are public by default and access modifiers cannot be applied to them. Additionally interfaces can contain members
                        that are implemented which is called default implementation. These are</p>
                    <ul>
                        <li><a href="#Constant_fields">Constant fields</a></li>
                        <li>Operators</li>
                        <li><a href="#Constructors">Static constructors</a></li>
                        <li>Nested types</li>
                        <li><a href="#Fields">Static fields</a></li>
                        <li><a href="#Methods">Static methods</a></li>
                        <li><a href="#Properties">Static properties</a></li>
                        <li><a href="#Indexers">Static indexers</a></li>
                        <li><a href="#Events">Static events</a></li>
                        <li>Member declarations using explicit interface implementation syntax</li>
                        <li>Explicit access modifiers</li>
                    </ul>
                    <p>An interface cannot contain an instance field or instance auto-property as an interface cannot have an instance state.</p>
                    <p><em>Note:</em> <i>whilst the declaration of a property in an interface is written with the same syntax as an instance
                        <span class="nowrap">auto-property,</span> it differs in that the compiler does not create an instance backing field.</i></p>
                    <p>Whereas a class can only inherit a single base class it can implement multiple interfaces. This is done in the same manner, i.e. the class name is
                        followed by a colon then the name of all interfaces in a comma separated list. If a class also inherits a base class its name must come first in
                        the list. A class can also explicitly implement a member of an interface. An interface can be derived from or be the base for by another
                        interface. Implemented members in an interface can be overridden. When this is done explicit interface implementation syntax must be used.
                        Explicitly implemented members and default implemented members in an interface can only be accessed through an instance of the interface.</p>
                    <p>Whilst on the surface an interface may seem to provide much of the same function as an abstract class, the important distinction is that a class
                        can contain a state and so can represent a thing where as an interface cannot and is used to represent a behavior.</p>
                    <p>In the following example the <code>Car</code> class inherits the base class <code>Vehicle</code> and overrides the <code>ApplyBrakes</code>
                        method. The <code>Dog</code> class has a method <code>Speak</code>. Whilst both are quite different objects both are able to move and make a sound
                        and so implement the <code>IMotion</code> and <code>ISound</code> interfaces which respectively include the <code>Move</code> method and
                        <code>Sound</code> property. As can be seen whilst the base class <code>Vehicle</code> must come first in the declaration list, the order of the
                        interface declaration is does not matter.</p>
<pre><code>using System;

namespace Interface
{
    // Declare interface IMotion
    public interface IMotion
    {
        void Move();
    }

    // Declare interface ISound
    public interface ISound
    {
        string Sound { get; set; }
    }

    // Declare abstract class Vehicle
    public abstract class Vehicle
    {
        public abstract void ApplyBrakes();
    }

    // Declare Car class that inherits Vehicle
    // and implements ISound and IMotion
    public class Car : Vehicle, ISound, IMotion
    {
        public string Sound { get; set; }

        public void Move()
        {
            Console.WriteLine("Car accelerates");
        }

        public override void ApplyBrakes()
        {
            Console.WriteLine(Sound);
            Console.WriteLine("Car slows");
        }
    }

    // Declare Dog class that implements ISound and IMotion
    public class Dog : IMotion, ISound
    {
        public string Sound { get; set; }

        public void Move()
        {
            Console.WriteLine("Dog chases car");
        }

        public void Speak()
        {
            Console.WriteLine(Sound);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            // Create an instance of Car
            Car car = new();
            car.Sound = "Brakes squeal";

            // Create an instance of Dog
            Dog dog = new();
            dog.Sound = "Dog barks";

            car.Move();
            dog.Move();
            car.ApplyBrakes();
            dog.Speak();
        }
    }
}

// The example writes the following to the console
// Car accelerates
// Dog chases car
// Brakes squeal
// Car slows
// Dog barks
</code></pre>
                    <!-- !SECTION interface -->
                </article>
            </section>
            <!-- !SECTION Classes and Other User Defined Types -->
            <!-- SECTION Anonymous functions -->
            <section class="main-section" id="Anonymous_functions">
                <header><h2>Anonymous functions</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>An anonymous function allows you to create a <a href="#delegate">delegate</a> an assign it a method in one line of code(<i>in-line</i>), without
                        the need for a separate named method. They can be declared with one of two basic syntaxes, <a href="#Anonymous_methods">anonymous methods</a> and
                        <a href="Lambda_Expression">lambda expressions</a> with the latter replacing the former. C# also provides two types of built-in delegates,
                        <a href="#Action_and_Func">Action</a> and  <a href="#Action_and_Func">Func</a>, that allow the in-line declaration of an anonymous function
                        without the need for the separate declaration of a delegate or a named method. </p>
                    <!-- SECTION Anonymous methods -->
                    <h3 id="Anonymous_methods">Anonymous methods</h3>
                    <p>Whilst anonymous methods have largely been replace by lambda expressions, they remain in the C# language for backwards compatibility so are
                        presented here for reference. As with a <a href="#delegate">named method</a> a delegate is first declared with the required return type and
                        <a href="Signatures,_parameters_and_overloading">signature</a>. The delegate instance is then declared and assigned an anonymous method by using
                        the <code>delegate</code> keyword, followed by the same signature as the delegate, followed by a code block.</p>
                    <p>The following example demonstrates anonymous method declaration and use.</p>
<pre><code>using System;

namespace AnonymousMethods
{
    // Delegate 'Calculate' takes in two int's and returns an int
    public delegate int Calculate(int value1, int value2);

    class Program
    {
        static void Main(string[] args)
        {
            // The delegate keyword is used as an operator to assign
            // a method signature matching the delegate declaration
            // The return type is inferred from the return statement
            Calculate add = delegate (int x, int y) { return x + y; };

            // Using the add delegate
            Console.WriteLine($"2 + 3 = {add(2, 3)}");
        }
    }
}

// The example writes the following to the console
// 2 + 3 = 5
</code></pre>
                    <!-- !SECTION Anonymous methods -->
                    <!-- SECTION Lambda expressions -->
                    <h3 id="Lambda_Expression">Lambda expressions</h3>
                    <p>Lambda expressions allow for a more concise in-line syntax than anonymous methods. As with a <a href="#delegate">named method</a> a delegate is
                        first declared with the required <a href="Signatures,_parameters_and_overloading">signature</a>. The delegate instance is then
                        declared and assigned an anonymous method by using a pair of round brackets containing the same signature as the delegate, followed by the lambda
                        operator <code>=&gt;</code>, followed by the lambda body. In most cases both the parameter types and the return type are inferred by the compiler.
                        This means that declaration of parameter types is usually not required but can be included if needed. In any case,
                        inclusion can assist with human readability of the code. Where only one parameter without a type declaration exists, the round brackets become
                        optional. The body can be in two forms, an <i>expression lambda</i> which can consist of an expression or a method call and a
                        <i>statement lambda</i> which consists of a statement block which can contain multiple statements.</p>
                    <p>The following example demonstrates various lambda expression declarations and use.</p>
<pre><code>using System;

namespace LambdaExpressions
{
    // 'CalculateTwoValues' takes in two int's and returns an int
    public delegate int CalculateTwoValues(int value1, int value2);

    // Delegate declares the method return type and signature
    // 'CalculateOneValue' takes an int and returns a string
    public delegate string CalculateOneValue(int value);

    // 'MethodCall' takes in a string and returns void
    public delegate void MethodCall(string value);

    class Program
    {
        static void Main(string[] args)
        {
            // Lambda expression. Return type is inferred based on the
            // parameter types and the expression in the body.
            // This form is an expression lambda.
            CalculateTwoValues add = (x, y) =&gt; x + y;

            // When needed, parameter types can also be explicitly declared
            CalculateTwoValues multiply = (int x, int y) =&gt; x * y;

            // With only one parameter brackets are not required.
            CalculateOneValue square = a =&gt; (a * a).ToString();

            // This is form is a statement lambda
            CalculateOneValue safeInvert = n =&gt;
            {
                if (n == 0)
                    return "Can't divide by zero";
                return $"1 / {n} = {1 / n}";
            };

            // A method call used as the lambda expression body
            MethodCall methodCall = a =&gt; Console.WriteLine(a);

            // Using the add delegate
            Console.WriteLine($"2 + 3 = {add(2, 3)}");

            //Using the multiply delegate
            Console.WriteLine($"5 x 3 = {multiply(5, 3)}");

            //Using the square delegate
            Console.WriteLine($"6 squared = {square(6)}");

            // Using the safeInvert delegate
            Console.WriteLine($"1 / 0 = {safeInvert(0)}");

            // Using the method call delegate
            methodCall("A method call was used as the expression body");
        }
    }
}

// The example writes the following to the console
// 2 + 3 = 5
// 5 x 3 = 15
// 6 squared = 36
// 1 / 0 = Can't divide by zero
// A method call was used as the expression body
</code></pre>
                    <!-- !SECTION Lambda expressions -->
                    <!-- SECTION Action and Func -->
                    <h3 id="Action_and_Func">Action and Func</h3>
                    <p>C# also has two built in <a href="#delegate">delegates</a>, <code>Action</code> that returns <code>void</code> and <code>Func</code> that returns
                        a declared type. Both provide the in-line declaration of an anonymous function without the need for a separate declaration of a delegate or a
                        <a href="#delegate">named method</a>. An <code>Action</code> or <code>Func</code> can also be passed as a parameter to a method or another
                        <code>Action</code> or <code>Func</code>. The <code>Action </code> syntax is <code>Action&lt;in T1, ... in T16t&gt;</code> and the
                        <code>Func</code> syntax is <code>Func&lt;in T1, ... in T16, out TResult&gt;</code>. Both provide
                        <a href="#Signatures,_parameters_and_overloading">overloads</a> for up to 16 input parameters of any type with <code>Func</code> allowing for one
                        return value of any type and both can be assigned a body in the form of either an <a href="#Anonymous_methods">anonymous method</a> or a
                        <a href="#Lambda_Expression">lambda expression</a>.</p>
                    <p>The following example demonstrates both <code>Func</code> and <code>Action</code> declaration and use.</p>

<pre><code>using System;

namespace ActionsAndFuncs
{
    class Program
    {
        static void Main(string[] args)
        {
            // Func delegate 'calculateVolume' that takes in three int's
            // and returns an int from an expression lambda body.
            Func&lt;int, int&gt; getCubeVolume = x =&gt; x * x * x;

            // Action delegate 'printCircleArea' that takes
            // in one int and that has a statement lambda body
            Action&lt;int&gt; printCircleArea = r =&gt;
            {
                const double pi = 3.1415;
                var area = pi * r * r;
                Console.WriteLine($"Circle area with radius {r} = {area}");
            };

            // Using the calculateVolume delegate
            Console.WriteLine($"Cube volume with sides 4 = {getCubeVolume(4)}");

            // Using the printCircleArea delegate
            printCircleArea(4);
        }
    }
}

// The example prints the following to the console
// Cube volume with sides 4 = 64
// Circle area with radius 4 = 50.264
</code></pre>
                    <!-- !SECTION Action and Func -->
                </article>
            </section>
            <!-- !SECTION Anonymous functions -->
            <!-- SECTION Dependencies and Namespaces -->
            <section class="main-section" id="Dependencies_and_Namespaces">
                <header><h2>Dependencies and Namespaces</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION Dependencies -->
                    <h3 id="Dependencies">Dependencies</h3>
                    <p>A C# project may consist of multiple sources of code along with other other resources such as media and text files which are then compiled to
                        create an <i>assembly</i>. This can be in the form of either an executable (.exe) or library (.dll) file and an application may consist of one or
                        more of these. When multiple assemblies are used, in order for one to be able to access the components of another it must have a reference to it.
                        The reference is a hierarchal such that if assembly A references assembly B then A can access B's components but not vise versa. If B was then to
                        attempt to reference A as well this would cause a circular reference error and would prevent either assembly from compiling. Accessibility of a
                        <a href="#Classes_and_Other_User_Defined_Types">type</a> or type's <a href="#Members">members</a> also depends on the application of
                        <a href="#Access_modifiers">access modifiers</a>.</p>
                    <p>In Visual Studio when a C# project is created it creates a <i>Solution</i> that includes the project and other files required by the compiler to to
                        build the assembly. These can be viewed in the <i>Solution Explorer</i> window which can be accessed via the <i>Solution Explorer</i> tab on the
                        right side of Visual Studio. If the tab is not visible, click on <b>View</b> then <b>Solution Explorer</b> in the menu. The Solution Explorer
                        appears similar to that of tree view of the File Explorer. Under the Solution root node is listed each project and under these each of the files
                        they contain.</p>
                    <p>For most project types such as a Console, Windows Forms, WPF applications, etc, these will also include the <i>.NETCore framework</i> which is
                        an extensive library of code that our project will have access to through a reference automatically added by Visual Studio. Under each project
                        in the Solution Explorer is a <i>Dependencies</i> node which when expanded reveals a <i>Frameworks</i> node and under this
                        <i>Microsoft.NETCore.App.Ref</i> which is the <i>.NETCore framework</i>. Expanding this reveals many nodes, most of which represent a library
                        (.dll) file prefixed with System. These include types such as the runtime, file access, memory management, collections, etc available to you so
                        that you don't have to create these yourself. In addition to the .NETCore framework a project can have a reference to other projects within the
                        solution and applications external to it.</p>
                    <p>The following example demonstrates how to create a new project, add a second project to the solution of the first and then create a reference of
                        the second project to the first.</p>
                    <ol>
                        <li>Start the IDE then click <b>Create a new project</b>.</li>
                        <li> On the <span class="nowrap"><b>Create a new project</b></span> page in the search box at the top type
                            <span class="nowrap"><b>'console core'</b></span>.</li>
                        <li>A project template titled <span class="nowrap"><b>Console Application</b></span> should appear at the top of the list. It
                            has an icon that looks like a document with C# in the top right corner. Select <span class="nowrap"><b>Console Application</b></span> then
                            choose <b>Next</b>. (Hint: if <span class="nowrap"><b>Console Application</b></span> is not at the top, click <b>Clear all</b> and search
                            again)</li>
                        <li>On the <span class="nowrap"><b>Configure your new project</b></span> page type <b>'ProjectA'</b>
                            in the <span class="nowrap"><b>Project name</b></span> box. Leave the <b>Location</b> and <span class="nowrap"><b>Solution name</b></span> as
                            filled in by the IDE and choose <b>Next</b>.</li>
                        <li>In the <span class="nowrap"><b>Additional information</b></span> page make sure <b>.NET5.0(Current)</b> is selected in the dropdown selector
                            then choose <b>Create</b></li>
                        <li>When the code editor has loaded right click the <b>Solution</b> node in the Solution Explorer then in the context menu hover the mouse
                            over <b>add</b> then in the new context menu that opens, click new project.</li>
                        <li>A project template called <b>ClassLibrary</b> : <i>A project for creating a class library that targets .NET Standard or .NET Core</i> should be
                            at the top of the list. If not, scroll down till you find the template then click on it to highlight it then click <b>Next</b></li>
                        <li>Repeat steps 4 and 5 using the project name <b>'ProjectB'</b>.</li>
                        <li>In <i>Solution Explorer</i> right click the <b>Dependencies</b> node under <b>ProjectA</b> and click <b>Add Project Reference</b> in the
                            context menu.</li>
                        <li>In the <b>Reference Manager - ProjectA</b> dialog box select the <b>Projects</b> node on the left pane.</li>
                        <li>In the middle section select <b>ProjectB</b> and mark its check box then click <b>OK</b> to add the reference</li>
                        <li>Under the <b>ProjectA</b> node in <b>Solution Explorer</b> expand the <b>Dependencies</b> node then the <b>Projects</b> node</li>
                        <li><b>ProjectB</b> should now be listed under this node confirming that <b>ProjectA</b> now has a reference to <b>ProjectB</b></li>
                    </ol>
                    <!-- !SECTION Dependencies -->
                    <!-- SECTION Namespaces -->
                    <h3 id="Namespaces">Namespaces</h3>
                    <p>C# requires that each type has a unique identifier. As the number of types increases naming conflicts become ever more probable, particularly when
                        external assemblies are referenced. Namespaces assist with this by compartmentally organizing types in a way that is similar to file system. For
                        example, in order to have two files on a drive called <i>MyFile.txt</i> you may put one in a folder called <i>MyFolder1</i> and the other in
                        <i>MyFolder2</i>. In a command window the two files are then referred to by <i>MyFolder1\MyFile.txt</i> and <i>MyFolder2\MyFile.txt</i>.
                        Namespaces are the same except that the backslashes (or forward slashes) are replaced with a dot. Like a file system namespaces are hierarchical
                        and a sublevel namespace is known as a nested namespace.</p>
                    <p>A type is defined by its identifier and the namespace it is declared in. Two classes with identical identifiers and members
                        declared in different namespaces are treated as two different types, each identified by their <i>fully qualified</i> name in the form
                        <code>MyNamespace.MyType</code>. Accessing a type in another namespace requires use of its fully qualified name whereas accessing a type in the
                        same namespace only requires its identifier in the form <code>MyType</code>. Nested namespaces are accessed by chaining the namespaces together in
                        the form <code>Namespace1.Namespace2.MyType</code>. Accessible <a href="#static">static</a> <a href="#Members">members</a>,
                        <a href="#Constant_fields">constant fields</a> and nested types within a type are accessed in a similar way in the form
                        <code>MyNamespace.MyType.Member</code>. <i>IntelliSense</i> uses namespaces to assist you by providing suggestions as you type. After typing the
                        root namespace then pressing <kbd>.</kbd>, all the types and nested namespaces within it will appear in the suggestion box. If one of the nested
                        namespaces is selected, the <kbd>.</kbd> can again be pressed to find all types and nested namespaces within it and the process can be repeated
                        until no nested namespaces remain. If a type is selected, pressing the <kbd>.</kbd> will display type's accessible members.</p>
                    <p>The <code>using</code> keyword allows types from another namespace to be <a href="#Importing_types"><i>imported</i></a> into a local namespace so
                        that they can be accessed directly by their identifiers and can also be used to create namespace <a href="#Aliases"><i>aliases</i></a> to avoid
                        naming conflicts. The <code>static</code> modifier keyword can be applied to the <code>using</code> directive to
                        <a href="#Importing_static_members">import static members</a> and nested types. A type declared outside of any namespace is in the
                        <a href="#Global_namespace"><i>global</i></a> namespace. Types that are in the .NetCore library can be imported using the
                        <a href="#Importing_system_types">System namespace</a></p>
                    <!-- !SECTION Namespaces -->

                    <!-- SECTION namespace -->
                    <h3 id="namespace">namespace</h3>
                    <p>The <code>namespace</code> keyword followed by a code block is used to declare that all <a href="#Classes_and_Other_User_Defined_Types">types</a>
                        enclosed within it belong to that <i>namespace</i> and can access each other through each type's identifier. Multiple declarations using the same
                        namespace can be made throughout the assembly and don't even have to be in the same file. Two types with the same identifier cannot be declared
                        within the same namespace even if they are declared in different files.</p>
                    <p>The following example demonstrates namespace declaration and usage.</p>
<pre><code>using System;

// All types declared in this namespace
// code block belong to NameSpace1
namespace NameSpace1
{
    enum Months { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Nov, Dec }

    // This Class1 is declared to belong to NameSpace1
    class Class1
    {
        public MyEnum Property { get; set; }

        public enum MyEnum { a, b, c }
    }

    interface ISomeInterFace
    {
        Months Month { get; set; }
    }
}

// All types declared in this namespace
// code block belong to NameSpace2
namespace NameSpace2
{
    // Despite having the same identifier and members by
    // being declared in NameSpace2 this is a different
    // type to the Months enum declared in NameSpace1
    enum Months { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Nov, Dec }

    // This Class1 is declared to belong to NameSpace2
    class Class1
    {
        public MyEnum Property { get; set; }

        public enum MyEnum { x, y, z }
    }
}

// All types declared in this namespace
// code block also belong to NameSpace1
namespace NameSpace1
{
    // ISomeInterFace and Class2 are both
    // in NameSpace1 so ISomeInterFace can be accessed
    // here directly by its identifier
    class Class2 : ISomeInterFace
    {
        public enum Days { Sun, Mon, Tue, Wed, Thu, Fri, Sat }

        public const double PI = 3.1415;

        public static double Area(double radius) =&gt; PI * radius * radius;

        // Implementation of ISomeInterFace member Property
        public Months Month { get; set; }

        private void Method()
        {
            // Months is in NameSpace1 so can be
            // accessed directly by its identifier
            Months month = Months.Jul;
        }

        public class Employer
        {
            // Months is in NameSpace1 so can be
            // accessed directly by its identifier
            // even within a nested type
            Months month = Months.Nov;
        }
    }

    // Syntax error, Class1 was already declared
    // in the previous NameSpace1 code block
    //class Class1 { }
}

// Declare an object in a sublevel namespace
namespace NameSpace1.DataModels
{
    class Person { }
}

// An alternate way to declare in a
// sublevel using a nested namespace
namespace NameSpace1
{
    namespace Animals
    {
        class Cat { }
    }
}

namespace NamespaceExample
{
    class Program
    {
        static void Main(string[] args)
        {
            // The following access types using
            // their fully qualified names

            // NameSpace1 and NameSpace2 each have a
            // class called Class1 within which each
            // have their own unique members
            NameSpace1.Class1 class1 = new();
            NameSpace2.Class1 class2 = new();
            class1.Property = NameSpace1.Class1.MyEnum.a;
            class2.Property = NameSpace2.Class1.MyEnum.x;
            Console.WriteLine(class1.Property);
            Console.WriteLine(class2.Property);

            // Access the enum Months in NameSpace1
            NameSpace1.Months month = NameSpace1.Months.Apr;
            Console.WriteLine($"The month is {month}");

            // enums, constants, static members and nested
            // types can be accessed without an instance
            NameSpace1.Class2.Days day = NameSpace1.Class2.Days.Sun;
            var pi = NameSpace1.Class2.PI;
            var circleArea = NameSpace1.Class2.Area(5.1);
            NameSpace1.Class2.Employer employer = new();
            Console.WriteLine($"The day is {day}");
            Console.WriteLine($"PI = {pi}");
            Console.WriteLine($"The area of a circle with a radius of 5.1 is {circleArea}");

            // The 'Month' property of Class2 and Month
            // both belong to NameSpace2 even though
            // they are declared in separate code blocks
            NameSpace1.Class2 instance = new();
            instance.Month = NameSpace1.Months.May;
            Console.WriteLine(instance.Month);

            // Syntax error, being in different namespaces
            // NameSpace1.Month and NameSpace2.Month are different types
            // so this is attempting an implicit conversion which fails
            //instance.Month = NameSpace2.Months.May;

            // to access nested namespaces the identifiers
            // are chained using the '.'
            NameSpace1.DataModels.Person person = new();
            NameSpace1.Animals.Cat cat = new();
        }
    }
}

// The example writes the following to the console
// a
// x
// The month is Apr
// The day is Sun
// PI = 3.1415
// The area of a circle with a radius of 5.1 is 81.710415
// May
</code></pre>
                    <p>When adding a new class using the default class template, Visual Studio automatically puts it within a namespace based on the folder in the project
                        in which the class is added. If you want to use the root namespace instead and want to avoid editing the namespace, add the new class to the root
                        project then move the file to your desired folder. The following shows the code generated by adding a class called <i>MainViewModel</i> to a
                        folder called <i>ViewModels</i> in a project called <i>MyCompany</i>.</p>
<pre><code>using System;

namespace MyCompany.ViewModels
{
    class MainViewModel
    {
    }
}
</code></pre>
                    <!-- !SECTION namespace -->
                    <!-- SECTION Global namespace -->
                    <h3 id="Global_namespace">Global namespace</h3>
                    <p>The area outside any namespace declaration in a file is the <i>global namespace</i> and any type declared within it is accessible throughout the
                        assembly. Where two types have the same identifier, a type declared in a local namespace or type will hide a type declared in the global
                        namespace. In this case the global type can still be accessed by prefixing its identifier with the <code>global</code> keyword followed by the
                        <a href="#Namespace_alias_qualifier_operator"><i>namespace alias qualifier</i></a> <code>::</code> in the form <code>global::MyType</code>.</p>
                    <p>The following example demonstrates how to access a type in the global namespace.</p>
<pre><code>using System;

    // MyClass declared in the global namespace
    public class MyClass
    {
        public void WriteMessage()
        {
            Console.WriteLine("MyClass in global namespace");
        }
    }

    namespace NameSpace1
    {
        public class AnotherClass
        {
            public AnotherClass()
            {
                NestedClass = new();
            }

            // This refers to the global MyClass
            public MyClass NestedClass { get; private set; }
        }
    }

    namespace NameSpace2
    {
        // MyClass declared locally in NameSpace2
        public class MyClass
        {
            public void WriteMessage()
            {
                Console.WriteLine("MyClass in NameSpace2");
            }
        }

        class Program
        {
            static void Main(string[] args)
            {
                // The refers to NameSpace2.MyClass
                MyClass localMyClass = new();
                localMyClass.WriteMessage();

                // NameSpace2.MyClass hides the global
                // MyClass so to access it the identifier
                // is prefixed with the global keyword
                // followed by two colons
                global::MyClass globalMyClass = new();
                globalMyClass.WriteMessage();

                // AnotherClass.NestedClass refers to the
                // global MyClass
                NameSpace1.AnotherClass anotherClass = new();
                anotherClass.NestedClass.WriteMessage();
            }
        }
    }

    // The example writes the following to the console

    // MyClass in NameSpace2
    // MyClass in global namespace
    // MyClass in global namespace
</code></pre>
                    <!-- !SECTION Global namespace -->
                    <!-- SECTION Importing types -->
                    <h3 id="Importing_types">Importing types</h3>
                    <p>The <code>using</code> directive imports all types from a another namespace which can be in any file in the containing assembly or others that the
                        assembly references. Imported types can then be accessed directly by their identifiers as if they were in the same namespace which makes
                        the code easier to read. A <code>using</code> directive must precede all other code within a namespace. A <code>using</code> directive that is
                        placed in the <a href="#Global_namespace">global namespace</a> makes the types in that namespace available in all other namespaces declared within
                        the same file.  A type in a nested namespace is not
                        imported and if a <code>using</code> directive to specifically target its namespace not included, it will need to be accessed using its fully
                        qualified name.</p>
                    <p>If you know a type's identifier but don't know its namespace, Visual Studio provides a shortcut for adding this. After entering the type's
                        identifier, with the mouse hovering over it, press <kbd>Ctrl</kbd> + <kbd>.</kbd> and IntelliSense will suggest the correct using directive, most
                        likely at the top of the list. Click on the suggestion and it will added to the code. Please note that the full name name must be entered with
                        the correct case and the project must have a <a href="#Dependencies">reference</a> to the project containing the type.</p>
                    <p>To remove unused <i>using</i> directives, right click anywhere in the code editor and click <b>Remove and Sort Usings</b>.</p>
                    <p>The following example demonstrate importing types with the <code>using</code> directive.</p>
<pre><code>// This code is in a file called Class5
namespace NameSpace5
{
    public class Class5 { }
}

// -------------------------------------------------

// This code is in a file called Program

// This imports all types from the System namespace
// See Importing system types for details
using System;

// This imports all types within NameSpace1
// into all namespaces declared in this file
using NameSpace1;

// This imports all types within
// NameSpace5 in the Class5 file, into
// all namespaces declared in this file
using NameSpace5;

// GlobalClass is declared in the global namespace
class GlobalClass { }

// Syntax error, a using clause must precede all other
// elements defined in the namespace except alias declarations
//using NameSpace4;

// Class1 is declared in NameSpace1
namespace NameSpace1
{
    public class Class1 { }
}

// Class2 is declared in NameSpace2
namespace NameSpace2
{
    using NameSpace1;

    public class Class2 { }

    // Class3 is declared in NameSpace3
    // which is nested in NameSpace2
    namespace NameSpace3
    {
        public class Class3 { }
    }
}

// Class4 is declared in NameSpace4
namespace NameSpace4
{
    public class Class4
    {
        // Class1 can be accessed
        // directly using its identifier
        Class1 class1 = new();

        // Class2 must be accessed using
        // its fully qualified name
        NameSpace2.Class2 class2 = new();
    }
}

namespace ImportingTypes
{
    // This allows types within NameSpace2
    // to be imported into this namespaces only
    using NameSpace2;

    class Program
    {
        static void Main(string[] args)
        {
            // Class1 and Class2 can each be
            // accessed directly using their identifiers
            Class1 class1 = new();
            Class2 class2 = new();

            // Syntax error, types in nested namespaces are not imported
            //Class3 myClass3 = new();

            // Class3 must be accessed using
            // its fully qualified name
            NameSpace2.NameSpace3.Class3 class3 = new();

            // Class4 must be accessed using
            // its fully qualified name
            NameSpace4.Class4 class4 = new();

            // Class5 which is declared within
            // NameSpace5 in the Class5 file can be
            // accessed directly using its identifier
            Class5 class5 = new();

            // GlobalClass can be accessed
            // directly using its identifier
            GlobalClass globalClass = new();

            Console.WriteLine($"class1 type is {class1.GetType()}");
            Console.WriteLine($"class2 type is {class2.GetType()}");
            Console.WriteLine($"class3 type is {class3.GetType()}");
            Console.WriteLine($"class4 type is {class4.GetType()}");
            Console.WriteLine($"class5 type is {class5.GetType()}");
            Console.WriteLine($"globalClass type is {globalClass.GetType()}");
        }
    }
}

// The example writes the following to the console
// class1 type is NameSpace1.Class1
// class2 type is NameSpace2.Class2
// class3 type is NameSpace2.NameSpace3.Class3
// class4 type is NameSpace4.Class4
// class5 type is NameSpace5.Class5
// globalClass type is GlobalClass
</code></pre>
                    <!-- !SECTION Importing types -->
                    <!-- SECTION Importing static members -->
                    <h3 id="Importing_static_members">Importing static members</h3>
                    <p>Accessible static members and nested types can be imported by applying the <code>static</code> modifier to the <code>using</code> directive. This
                        allows the static members to be accessed directly without the need for the type's identifier. Instance members that are also in the type will
                        still require an instance to be created to access them and inherited members are not imported.</p>
                    <p>The following example demonstrates importing and using static members.</p>
<pre><code>using System;

namespace NameSpace1
{
    public class MathClass
    {
        public const double PI = 3.1415;

        public static double CircleArea(double r) =&gt; PI * r * r;

        public double CubeVolume(double x) =&gt; x * x * x;
    }
}

namespace ImportingStaticMembers
{
    // Import the types in NameSpace1
    using NameSpace1;

    // Import the constant fields and static members
    // in NameSpace1.MathClass
    using static NameSpace1.MathClass;

    class Program
    {
        static void Main(string[] args)
        {
            // This uses the static members in NameSpace1.MathClass
            // without needing the namespace or the class name
            Console.WriteLine($"PI = {PI}");
            double area = CircleArea(5.1);
            Console.WriteLine($"Area of a circle with radius 5.1 = {area}");

            // To use the instance members in  NameSpace1.MathClass
            // an instance of the class is still required
            MathClass mathClass = new();
            double volume = mathClass.CubeVolume(3.3);
            Console.WriteLine($"Volume of a cube sides 3.3 = {volume}");
        }
    }
}

// The example writes the following the console
// PI = 3.1415
// Area of a circle with radius 5.1 = 81.710415
// Volume of a cube sides 3.3 = 35.937
</code></pre>
                    <!-- !SECTION Importing static members -->
                    <!-- SECTION Aliases -->
                    <h3 id="Aliases">Aliases</h3>
                    <p>Aliases provide a way of resolve naming conflicts which can be of particularly use when importing types from referenced assemblies. They can also
                        result in a much shorter name to use. This is of particular use where access to the type is through many namespace levels. The
                        <code>using</code> keyword is used to create the alias for a namespace or a type.</p>
                    <p>The following example demonstrates creating and using aliases.</p>
<pre><code>using System;

namespace NameSpace1
{
    // This MyClass is declared to belong to NameSpace1
    public class MyClass { }
}

namespace NameSpace2
{
    // This MyClass is declared to belong to NameSpace2
    public class MyClass { }
}

// A namespace with many levels
namespace Level1
{
    namespace Level2
    {
        namespace Level3
        {
            namespace Level4
            {
                namespace Level5
                {
                    public class NestedClass { }
                }
            }
        }
    }
}

namespace Aliases
{
    // Import MyClass from both
    // NameSpace1 and NameSpace2
    using NameSpace1;
    using NameSpace2;

    // An alias is created for each MyClass
    // in both NameSpace1 and NameSpace2
    using MyClass1 = NameSpace1.MyClass;
    using MyClass2 = NameSpace2.MyClass;

    // An alias can also be given to a namespace
    using ShortName = Level1.Level2.Level3.Level4.Level5;

    class Program
    {
        static void Main(string[] args)
        {
            // Syntax error, importing MyClass from both NameSpace1 and
            // NameSpace2 creates a naming conflict the compiler can't resolve.
            //MyClass myClass1 = new();

            // The aliases resolve the naming conflict
            // and results in a shorter name to use
            MyClass1 myClass1 = new();
            MyClass2 myClass2 = new();

            // The alias MyNameSpace is used to access SomeClass
            // Using the fully qualified name with many
            // nested namespaces gets quite cumbersome
            ShortName.NestedClass nestedClass = new();

            Console.WriteLine($"'myClass1' fully qualified name is '{myClass1.GetType()}'");
            Console.WriteLine($"'myClass2' fully qualified name is '{myClass2.GetType()}'");
            Console.WriteLine($"'nestedClass' fully qualified name is '{nestedClass.GetType()}'");
        }
    }
}

// The example writes the following to the console
// 'myClass1' fully qualified name is 'NameSpace1.MyClass'
// 'myClass2' fully qualified name is 'NameSpace2.MyClass'
// 'nestedClass' fully qualified name is 'Level1.Level2.Level3.Level4.Level5.NestedClass'
</code></pre>
                    <!-- !SECTION Aliases -->
                    <!-- SECTION Importing system types -->
                    <h3 id="Importing_system_types">Importing system types</h3>
                    <p>The <code>System</code> namespace and the namespaces nested within it, contain most of the C# built-in types that are part of the
                        .NetCore library. These include primitive value types such as <code>System.Int32</code> and reference types such as <code>System.String</code> and
                        access to these without a fully qualified name requires a <code>using System;</code> directive. Many of the C#
                        <a href="Keywords">keywords</a> are special built-in <a href="#Aliases">aliases</a> for these types but unlike other aliases, don't require an
                        explicit <code>using</code> directive. For example the <code>int</code> keyword can be used anywhere in code and is the alias for
                        <code>System.Int32</code>, both of which can be used interchangeably. Other system types such as <code>DateTime</code> which provides many tools
                        to access and manipulate dates and times and <code>Console</code> which has been used extensively throughout this guide, do require an explicit
                        <code>using System;</code> directive.</p>
                    <p>Nested within <code>System</code> are many other namespaces such as <code>System.Collections.Generic</code> that contains the
                        <a href="#List_T">List&lt;T&gt;</a> and <a href="#Dictionary_TKey_TValue">Dictionary&lt;TKey, TValue&gt;</a> types, <code>System.IO</code> that
                        contains types that allow you to access and manipulate files and <code>System.Threading</code> that provides tools for creating multi-threaded
                        applications. All the namespaces available in the .NetCore library can be viewed under the <a href="#Dependencies">dependencies</a> node in the
                        solution explorer and information about them and the types they contain can be found on the <a href="References">Microsoft C# reference
                        documentation</a> website.</p>
                    <p>The following example demonstrates importing and using various System types.</p>
<pre><code>namespace NameSpace1
{
    class MyClass
    {
        // int is a c# keyword which is a built-in alias
        // for the System.Int32 struct. C# keywords can be
        // accessed without the 'using System' directive
        int x = 1;

        // Without the 'using System' directive
        // the fully qualified name must be used
        // even though this is the same type as int
        System.Int32 y = 2;
    }
}

namespace ImportingSystemTypes
{
    using System;
    using System.Threading;


    class Program
    {
        static void Main(string[] args)
        {
            // DateTime is a struct in the System namespace.
            // DateTime.Now gets the current date and time
            DateTime startTime = DateTime.Now;

            // Thread is a class in the System.Threading namespace. Thread.Sleep
            // suspends the thread for the specified number of milliseconds
            Thread.Sleep(1000);

            // TimeSpan is a struct in the System namespace.
            // A TimeSpan is the difference between two DateTime's
            TimeSpan elapsedTime = DateTime.Now - startTime;

            // double is a c# keyword which is a built-in alias
            // for the System.Double struct
            double totalSeconds = elapsedTime.TotalSeconds;

            // Math is a class in the System namespace.
            // Math.Round is a static method that rounds
            // a value to the nearest integer.
            // string is a c# keyword which is a built-in
            // alias for the System.String class.
            string roundedSeconds = Math.Round(totalSeconds).ToString();

            // Console is a class in the System namespace.
            Console.WriteLine($"The program has been asleep for {roundedSeconds} second");
        }
    }
}

// The example writes the following to the console
// The program has been asleep for 1 second
</code></pre>
                    <!-- !SECTION Importing system types -->
                </article>
            </section>
            <!-- !SECTION Dependencies and Namespaces -->
            <!-- SECTION Scope and Modifiers -->
            <section class="main-section" id="Scope_and_Modifiers">
                <header><h2>Scope and Modifiers</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
<!-- TODO Fix method parameter passing ing argument -->
                    <!-- SECTION Scope -->
                    <h3 id="Scope">Scope</h3>
                    <p>Scope is the accessibility of a variable from one part of the code to another. In C# scope is arranged like the layers of an onion. Variables in an
                        outer scope can be accessed from those within but not vise versa. In computer science this is known as encapsulation and inner scopes that are
                        contained within outer scopes are said to be nested.</p>
                    <p>A local <a href="#Variables,_Constants,_Types_and_Literals">variable</a> is a variable declared in a <a href="#Methods">method</a>,
                        <a href="#Properties">property accessor</a>, <a href="#Indexers">indexer accessor</a>, <a href="#Constructors">constructor</a>,
                        <a href="#Anonymous_functions">anonymous function</a> or operator or one of its nested code blocks. A nested code block include those of
                        <a href="#if_else_statements">if</a>, <a href="#if_else_statements">else</a>, <a href="#switch_statement">switch</a>,
                        <a href="#while_statement">while</a>, <a href="#do_statement">do</a>, <a href="#for_statement">for</a>, <a href="#foreach_statement">foreach</a>,
                        <a href="#try-catch">try</a> and using statements. An argument that is passed into a method or indexer is accessible outside the member and
                        becomes a local variable within the member. The variable is only accessible after it has been declared and only within the same code block or a
                        nested code block. A local variable within the same block or a nested code block cannot be declared with the same name.</p>
                    <p>A local variable can have the same name as a member within a container (enclosing type). When this is done the member is hidden by the local
                        variable. To access a hidden member, the <code>this</code> name qualifier keyword must be used. For example if a class contains both a property
                        called <code>someName</code> and a method containing a local variable called <code>someName</code>, to access the property from within the method
                        you would use <code>this.someName</code>. To avoid possible confusion or naming conflicts you should avoid declaring local variables with the same
                        name as a member in the same enclosing type. A common convention is to name local variables with <i>camelCase</i>, <code>int someName;</code>
                        private fields with <i>camelCase</i> prefixed with an underscore, <code>int _someName;</code>, private static fields with <i>camelCase</i>
                        prefixed with an 's' followed by an underscore, <code>private static int s_someName</code> and all other members with with <i>PascalCase</i>,
                        <code>public int SomeName { get; set; }</code>. Which ever convention you or the team you work for chose, it is important that it be consistent
                        throughout all the code you write.</p>
                    <p>Following are examples of scope.</p>
<pre><code>using System;

namespace Scope
{
    public class MyClass
    {
        private string _nl = Environment.NewLine;

        // Declare _field1 and field2 at the top of the class
        // Fields do not have to be initialized so _field1
        // has the default integer value 0
        private int _field1;
        // Note: field2 does not have an underscore
        // prefix for demonstrative purposes only
        private string field2 = "field2";

        public void Method1(int value)
        {
            // variable1 is declared and initialized within the
            // scope of Method1. All code following this within
            // Method1 will have access to it
            int variable1 = 1;

            // Syntax error, because 'value' was declared in the signature
            // of Method1 it is a local variable in the scope of Method1
            // so another variable called value can't be declared in it
            //int value = 0;

            Console.WriteLine($"Initial class level _field1 value = {_field1}");

            // Syntax error, can't use local variable before
            // it is declared, local variable field2 is declared
            // after this statement and hides class level field2
            //Console.WriteLine($"Initial field2 value = {field2}");

            // Declaring a local field2 variable hides the class level field2
            // Local field2 is an int whereas class level field2 is a string
            int field2 = 0;
            Console.WriteLine($"Initial local variable field2 value = {field2}");

            // To access the hidden class level field2 use the 'this' qualifier
            Console.WriteLine($"Class level field2 value = {this.field2}");

            Console.WriteLine($"{_nl}Display iterator 'i' from Loop 1");

            // Loop 1 declares a nested scope within the scope of Method1
            // A variable named 'i' has been declared as the iterator for Loop 1
            for (int i = 0; i &lt;= 5; i++)
            {
                Console.Write($"{i}, ");
                variable1 += i;
                int variable2 = i * 2;
                _field1 += variable2;
            }

            Console.WriteLine($"{_nl}Result of variable1 in Loop 1 = {variable1}");
            Console.WriteLine($"Result of _field1 in Loop 1 = {_field1}");

            variable1 = 0;
            _field1 = 0;

            Console.WriteLine($"{_nl}Display iterator 'i' from Loop 2");

            // Loop 2 also declares a nested scope within Method1 but is outside the scope of
            // loop 2 so a variable named 'i' can also be declared as an iterator for Loop 2
            for (int i = 0; i &lt;= 15; i += 3)
            {
                Console.Write($"{i}, ");
                variable1 += i;
                int variable2 = i * 4;

                // Although _field3 was declared within MyClass after Method1
                // as it is a Field the location of its declaration within
                // the class does not matter so it can be accessed here
                _field3 += variable2;

                // Syntax error, this nested loop is within the scope of loop 2 so it
                // can't declare the same iterator 'i' that was declared by loop 2.
                //for (int i = 0; i &lt; 10; i++) { }

                // Syntax error, variable3 is declared after loop 2 so can't be accessed in it
                //variable3 = 1;

                // Syntax error, loop 2's scope is nested in Method1's scope
                // so another local variable3 can't be declared here also
                //int variable3 = i;

                // Loop 3 creates a nested scope within Loop 2
                for (int j = 0; j &lt; 5; j++)
                {
                    // Loop 2 iterator i and variable2 can
                    // be accessed within the scope of Loop 2
                    int variable4 = j + i + variable2;
                    _field1 += variable4;
                }
            }

            Console.WriteLine($"{_nl}Result of variable1 in Loop 2 = {variable1}");
            Console.WriteLine($"Result of _field1 in Loop 2 = {_field1}");
            Console.WriteLine($"Result of _field3 in Loop 2 = {_field3}");
            Console.WriteLine($"local field2 = {field2}");
            Console.WriteLine($"class level field2 = {this.field2}");

            // Syntax error, 'variable2' and 'i' from Loop 1 and
            // Loop 2 and 'j' from Loop 3 are all out of scope
            //Console.WriteLine($"variable2 = {variable2}");
            //Console.WriteLine($"i = {i}");
            //Console.WriteLine($"j = {j}");

            int variable3 = 0;
        }

        // Although by convention fields are declared at
        // the top of a class they can be placed anywhere
        int _field3 = 20;

        // Syntax error, local variables within the scope of Method1
        // can't be accessed outside of it at the class level
        //variable1 = 0;
        //variable2 = 0;
        //variable3 = 0;
        //variable4 = 0;
        //i = 0;
        //j = 0;
        //value = 0;

        // Method2 declares the same local variables as Method1
        // There is no conflict as the variables within each
        // method are within their own local scope
        public void Method2(string value)
        {
            int variable1 = 0;
            int variable2 = 0;
            int variable3 = 0;
            int variable4 = 0;
            int i = 0;
            int j = 0;
            field2 = value;
            Console.WriteLine($"Method2 field2 = {field2}");
        }

        // Syntax error, _field1 was already declared
        // within the same scope at the top of MyClass
        //int _field1;
    }

    class Program
    {
        static void Main(string[] args)
        {
            MyClass myClass = new();
            myClass.Method1(10);
            myClass.Method2("New value");
        }
    }
}

// The example prints the following to the console
// Initial class level _field1 value = 0
// Initial local variable field2 value = 0
// Class level field2 value = field2

// Display iterator 'i' from Loop 1
// 0, 1, 2, 3, 4, 5,
// Result of variable1 in Loop 1 = 16
// Result of _field1 in Loop 1 = 30

// Display iterator 'i' from Loop 2
// 0, 3, 6, 9, 12, 15,
// Result of variable1 in Loop 2 = 45
// Result of _field1 in Loop 2 = 1185
// Result of _field3 in Loop 2 = 200
// local field2 = 0
// class level field2 = field2
// Method2 field2 = New value
</code></pre>
                    <!-- !SECTION Scope -->
                    <!-- SECTION Modifiers -->
                    <h3 id="Modifiers">Modifiers</h3>
                    <p>Modifiers are used to change the behavior of a types and members. Access modifiers are grouped into their own category.</p>
                    <p>Following is a list of the modifiers and which types and members they apply to</p>
                    <ul>
                        <li><a href="#abstract">abstract</a> - classes, records, methods, properties</li>
                        <li><a href="#async">async</a> - method, lambda expression, anonymous method</li>
                        <li><a href="#const">const</a> - fields, local variables</li>
                        <li><a href="#extern">extern</a> - methods, constructors, properties, events, indexers, finalizers </li>
                        <li><a href="#in">in</a> - parameters, generics</li>
                        <li><a href="#new">new</a> - methods, fields, properties, events, indexers, nested types</li>
                        <li><a href="#out">out</a> - parameters, generics </li>
                        <li><a href="#override">override</a> - methods, properties, events, indexers</li>
                        <li><a href="#partial">partial</a> - classes, structures, interfaces, methods</li>
                        <li><a href="#readonly">readonly</a> - fields</li>
                        <li><a href="#sealed">sealed</a> classes, records, methods, properties, events, indexers</li>
                        <li><a href="#static">static</a> - classes, methods, constructors, fields, properties, events</li>
                        <li><a href="#unsafe">unsafe</a> - class, struct, record, delegate, interface, method, constructor, field, property, indexer, event, operator,
                            finalizer</li>
                        <li><a href="#virtual">virtual</a> -  methods, properties, events, indexers</li>
                        <li><a href="#volatile">volatile</a> - fields</li>
                    </ul>
                    <p>In addition, accessibility to members from outside of a type or an assembly can be changed with the use of
                        <a href="#Access_modifiers">access modifiers</a>.</p>
                    <p><i><em>Note:</em> the behavior of modifiers may change when combined and some modifiers are mutually exclusive as detailed in the relevant
                        sections </i></p>
                    <!-- !SECTION Modifiers -->
                    <!-- SECTION abstract -->
                    <h3 id="abstract">abstract</h3>
                    <p> An <i>abstract</i> class is used when it makes sense to declare a common base class but where the implementation is specific to each derived class.
                        A base class and its members can be declared abstract by marking them with the <code>abstract</code> keyword. It cannot be instantiated so to be
                        used, a derived class must be created that inherits it and overrides all abstract members it contains. Abstract classes can be inherited by
                        sealed, abstract and non abstract classes and can inherit from an abstract or non abstract base class that is not a sealed class. Abstract members
                        cannot declare an implementation and within a derived class are treated the same as a virtual member. Any class that contains an abstract member
                        must be marked with the <code>abstract</code>keyword. An abstract class can contain both abstract and non abstract members.</p>
                    <p>In the following example an abstract class <code>PriceCalculator</code> is declared with an abstract method called <code>CalculateAmount</code>.
                        Two derived classes that inherit from <code>PriceCalculator</code> are declared. The first <code>ItemsPriceCalculator</code> has two properties,
                        <code>ItemPrice</code> and <code>Quantity</code> and overrides <code>CalculateAmount</code> to return an amount by multiplying these two
                        properties. The second class <code>HoursPriceCalculator</code> has three properties, <code>StartTime</code>, <code>FinishTime</code> and
                        <code>HourlyRate</code>. In this case the overridden <code>CalculateAmount</code> first subtracts <code>StartTime</code> from
                        <code>FinishTime</code> then multiplies thy result by <code>HourlyRate</code> and then returns the amount. Lastly as can be seen, attempting to
                        instantiate <code>PriceCalculator</code> results in a syntax error.</p>
<pre><code>using System;
using System.Globalization;

namespace Abstract
{
public abstract class PriceCalculator
{
public abstract double CalculateAmount();
}

public class ItemsPriceCalculator : PriceCalculator
{
public double ItemPrice { get; set; }

public int Quantity { get; set; }

public override double CalculateAmount()
{
return ItemPrice * Quantity;
}
}

public class HoursPriceCalculator : PriceCalculator
{
public  DateTime StartTime { get; set; }

public  DateTime FinishTime { get; set; }

public double HourlyRate { get; set; }

public override double CalculateAmount()
{
var timeTaken = FinishTime - StartTime;
return timeTaken.TotalHours * HourlyRate;
}
}

class Program
{
static void Main(string[] args)
{
ItemsPriceCalculator itemsPriceCalculator = new();
itemsPriceCalculator.Quantity = 6;
itemsPriceCalculator.ItemPrice = 3.10;
Console.WriteLine($"The price of the items is {itemsPriceCalculator.CalculateAmount().ToString("C", CultureInfo.CurrentCulture)}");

HoursPriceCalculator hoursPriceCalculator = new();
hoursPriceCalculator.StartTime = new DateTime(2021, 11, 4, 9, 0, 0);
hoursPriceCalculator.FinishTime = new DateTime(2021, 11, 4, 17, 0, 0);
hoursPriceCalculator.HourlyRate = 30;
Console.WriteLine($"The price of the hours is {hoursPriceCalculator.CalculateAmount().ToString("C", CultureInfo.CurrentCulture)}");

// Syntax error, can't create an instance of an abstract class
//PriceCalculator priceCalculator = new();
}
}
}

// The example writes the following to the console
// The price of the items is $18.60
// The price of the hours is $240.00
</code></pre>
                    <!-- !SECTION abstract -->
                    <!-- SECTION async -->
                    <h3 id="async">async</h3>
                    <p>The <code>async</code> modifier is outside the scope of this guide. For more information, please see the
                        <a href="#References">Microsoft C# reference documentation</a></p>
                    <!-- !SECTION async -->
                    <!-- SECTION const -->
                    <h3 id="const">const</h3>
                    <p>A field or local <a href="Variables,_Constants,_Types_and_Literals">variable</a> marked with the <code>const</code> keyword causes it to become a
                        constant which can only be initialized when declared and then can't changed. A field marked this way is called a
                        <a href="#Constant_fields">constant field</a>.</p>
                    <!-- !SECTION const -->
                    <!-- SECTION extern -->
                    <h3 id="extern">extern</h3>
                    <p>The <code>extern</code> modifier allows a C# program to run code that is implemented in an external library. This could be one of the native code
                        libraries that contain many of the common functions used by the operating system and which may be in another programming language such as C or
                        C++. Similar to the <a href="abstract">abstract</a> modifier, <code>extern</code> allows you to create the declaration only, which points to the
                        implementation in the external library. The <code>extern</code> modifier is often used with the <code>DllImport</code> attribute which in turn is
                        used to import the external library.</p>
                    <p>In the following example <code>extern</code> is used to declare a method called <code>MessageBox</code> which is implemented by a method of the
                        same name in a Windows library called <i>user32.dll</i>. The example also makes use of the <i>local function</i> syntax which wraps the
                        <code>MessageBox</code> method within another called <code>DisplayMessageBox</code>. When the user presses the <kbd>x</kbd> key, a message box is
                        displayed asking the user if they want to end the program which loops until the user clicks the <i>Yes</i> button.</p>
                    <p><i><em>Note:</em> due to the use of user32.dll this example will only work with the Windows operating system.</i></p>
<pre><code>using System;
using System.Runtime.InteropServices;

namespace Extern
{
    class Program
    {
        static void Main(string[] args)
        {
            bool exit = false;
            // Loop until the user presses the 'y' in the message box
            while (!exit)
            {
                Console.Clear();
                Console.WriteLine("Press x to exit the program");
                // Wait until the user presses the 'x' key
                while (Console.ReadKey(true).Key != ConsoleKey.X) { }
                exit = DisplayMessageBox("Are you sure you want to exit the program?", "Exit program?");
            }
            Console.WriteLine("You have exited the program");
        }

        public static bool DisplayMessageBox(string message, string caption)
        {
            // Declare a nested 'MsgBox' method that is implemented
            // by the 'MessageBox' method in 'User32.dll'
            [DllImport("User32.dll", EntryPoint = "MessageBox", CharSet = CharSet.Unicode)]
            static extern int MessageBox(IntPtr h, string message, string caption, int type);

            // Call the 'MsgBox' method with type set to 4 which displays
            // yes and no buttons. If the user presses yes the method returns 6.
            return MessageBox((IntPtr)0, message, caption, 4) == 6;
        }
    }
}
    </code></pre>
                    <!-- !SECTION extern -->
                    <!-- SECTION in -->
                    <h3 id="in">in</h3>
                    <p>When used with a parameter the <code>in</code> modifier keyword allows an argument to be passed by reference to a method but prevents it from being
                        modified, please see <a href="#Signatures,_parameters_and_overloading">Signatures parameters and overloading</a>. Use of the <code>in</code>
                        modifier with generics is outside the scope of this guide. For more information, please see the <a href="#References">Microsoft C# reference
                        documentation</a></p>
                    <!-- !SECTION in -->
                    <!-- SECTION new -->
                    <h3 id="new">new</h3>
                    <p>Where members in both a base and derived type have the same identifier under certain conditions the derived member may hide the base member
                        resulting in a waring from the compiler. Marking the member in the derived type with the <code>new</code> modifier keyword suppresses the warning,
                        please see <a href="#Inheriting_types">Inheriting types</a></p>
                    <!-- !SECTION new -->
                    <!-- SECTION out -->
                    <h3 id="out">out</h3>
                    <p>When used with a parameter the <code>out</code> modifier keyword allows an argument to be passed by reference back to the calling statement,
                        please see <a href="#Signatures,_parameters_and_overloading">Signatures parameters and overloading</a>. Use of the <code>out</code> modifier with
                        generics is outside the scope of this guide. For more information, please see the <a href="#References">Microsoft C# reference documentation</a>
                    </p>
                    <!-- !SECTION out -->
                    <!-- SECTION override -->
                    <h3 id="override">override</h3>
                    <p>The implementation of a <a href="#Methods">method</a>, <a href="#Properties">property</a>, <a href="#Indexers">indexer</a> or
                        <a href="#Events">event</a> that is marked as marked with with either the <a href="#virtual">virtual</a> or <code>override</code> keyword in a
                        base <a href="#class">class</a> or <a href="#record">record</a> can be overridden in a derived class or record respectively. To do so the
                        member in the derived type must be marked with the <code>override</code> keyword. Base members are not virtual by default and
                        attempting to override a member not marked as virtual results in an error.</p>
                    <p><em>Note:</em> <i>Microsoft has advised not to declare an event as <code>virtual</code> as the compiler does not handle these correctly. Instead a
                        method should be created in the base type that <a href="#Events">invokes the event</a>. This method can then be called from the derived type to
                        raise the event.</i>
                    </p>
                    <p>In the following example a base class <code>LogAnalyzer</code> is created that has a method <code>AnalyzeLogMessage()</code> and a virtual method
                        <code>DisplayMessage()</code>. Derived class <code>LogAnalyzer1</code> inherits <code>LogAnalyzer</code> and overrides the virtual method
                        providing its own implementation. <code>LogAnalyzer2</code> inherits <code>LogAnalyzer1</code> and overrides the virtual method that it had
                        overridden. <code>LogAnalyzer3</code> also inherits <code>LogAnalyzer</code>. It does not override the virtual method but it shows that attempting
                        to override the non virtual method results in a syntax error. When <code>DisplayMessage()</code> is called from each of the derived class
                        instances <code>LogAnalyzer1</code> and <code>LogAnalyzer2</code> each display the message in their own overridden methods whereas
                        <code>LogAnalyzer3</code> displays the message from the base class.</p>
<pre><code>using System;

namespace OverridingVirtualMembers
{
    public class LogAnalyzer
    {
        public void AnalyzeLogMessage()
        {
            Console.WriteLine("Analyzing log message");
        }

        public virtual void DisplayMessage()
        {
            Console.WriteLine("Log message has occurred");
        }
    }

    public class LogAnalyzer1 : LogAnalyzer
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 1 has occurred");
        }
    }

    public class LogAnalyzer2 : LogAnalyzer1
    {
        public override void DisplayMessage()
        {
            Console.WriteLine("Log message type 2 has occurred");
        }
    }

    public class LogAnalyzer3 : LogAnalyzer
    {
        // Syntax error, can't override a member that
        // is not marked virtual, abstract or override
        //public override void AnalyzeLogMessage() { }
    }

    class Program
    {
        static void Main(string[] args)
        {
            LogAnalyzer1 logAnalyzer1 = new();
            LogAnalyzer2 logAnalyzer2 = new();
            LogAnalyzer3 logAnalyzer3 = new();

            Console.WriteLine("Using logAnalyzer1");
            logAnalyzer1.AnalyzeLogMessage();
            logAnalyzer1.DisplayMessage();

            Console.WriteLine();
            Console.WriteLine("Using logAnalyzer2");
            logAnalyzer2.AnalyzeLogMessage();
            logAnalyzer2.DisplayMessage();

            Console.WriteLine();
            Console.WriteLine("Using logAnalyzer3");
            logAnalyzer3.AnalyzeLogMessage();
            logAnalyzer3.DisplayMessage();
        }
    }
}

// The example writes the following to the console
// Using logAnalyzer1
// Analyzing log message
// Log message type 1 has occurred

// Using logAnalyzer2
// Analyzing log message
// Log message type 2 has occurred

// Using logAnalyzer3
// Analyzing log message
// Log message has occurred
</code></pre>
                    <!-- !SECTION override -->
                    <!-- SECTION partial -->
                    <h3 id="partial">partial</h3>
                    <p>The <code>partial</code> keyword allows a class, struct or interface definition to be split across multiple code files. Often this is used to place
                        the boilerplate code of a class into one file and the rest in another.</p>
                    <p>Additionally, within a partial type, a method can also be marked as
                        <code>partial</code> in which case the declaration of the method is placed in one file and the implementation in another, provided that both the
                        declaration and the implementation both start with the <code>partial</code> keyword and both have the same
                        <a href="#Signatures,_parameters_and_overloading">signature</a>. A common use for a partial method is a class designer that automatically declares
                        methods that the developer can then decide whether or not to implement. A partial method's implementation is optional provided it does not have an
                        <a href="#Access_modifiers">access modifier</a>, it returns <code>void</code>, it does not have any <a href="#out">out</a> parameters and it does
                        not have the <a href="#extern">extern</a>, <a href="#new">new</a>, <a href="#override">override</a>, <a href="#sealed">sealed</a> or
                        <a href="#virtual">virtual</a> modifier.</p>
                    <p>The following example demonstrates a class called <code>MyClass</code> that is split across two files called <i>MyClass_Part_1.cs</i> which holds
                        the boilerplate code and <i>MyClass_Part_2.cs</i> which holds the business logic. The <code>Program</code> class is able to access the members
                        that are located in the separate files of the instance of <code>MyClass</code> called <code>myClass</code> as normal using
                        <code>myClass.Member</code>. It also has a method called <code>PartialMethod</code> which is declared in <i>MyClass_Part_1.cs</i>, implemented
                        in <i>MyClass_Part_2.cs</i> and which can be accessed in the <code>Program</code> class.</p>
<pre><code>// MyClass_Part_1.cs
// A file to hold the boiler plate code of MyClass

using System;

namespace PartialModifier
{
    public partial class MyClass
    {
        public string FirstName { get; set; }

        public string LastName { get; set; }

        public DateTime Modified { get; private set; }

        private void InitializeMyClass()
        {
            Modified = DateTime.Now;
        }

        public partial void PartialMethod(string value);
    }
}

// -----------------------------------------------------------------------

// MyClass_Part_2.cs
// A file to hold the business logic code for MyClass

using System;

namespace PartialModifier
{
    public partial class MyClass
    {
        public MyClass(string firstName, string lastName)
        {
            FirstName = firstName;
            LastName = lastName;
            InitializeMyClass();
        }

        public string GetFullName() =&gt; $"{FirstName} {LastName}";

        public partial void PartialMethod(string value)
        {
            Console.WriteLine(value);
        }
    }
}

// -----------------------------------------------------------------------

// Program.cs
// The main file of the program

using System;

namespace PartialModifier
{
    class Program
    {
        static void Main(string[] args)
        {
            MyClass myClass = new("John", "Smith");
            Console.WriteLine($"Name: {myClass.GetFullName()}");
            Console.WriteLine($"Last updated: {myClass.Modified:dd MMMM yyyy}");
            myClass.PartialMethod("The partial method was called");
        }
    }
}

// This example writes the following to the console
// Name: John Smith
// Last updated: 23 December 2021
// The partial method was called
</code></pre>
                    <!-- !SECTION partial -->
                    <!-- SECTION readonly -->
                    <h3 id="readonly">readonly</h3>
                    <p>A <a href="#Fields">field</a> that is marked <a href="">readonly</a> can only be set when declared or through a
                        <a href="#Constructors">constructor</a>.</p>
                    <!-- !SECTION readonly -->
                    <!-- SECTION sealed -->
                    <h3 id="sealed">sealed</h3>
                    <p>To prevent a class from being inherited it can be marked with the <code>sealed</code> keyword. A member that is being overridden in a class can
                        also be marked as <code>sealed</code> which prevents it from being overridden in any further derived classes.</p>
<pre><code>using System;

namespace Sealed
{
    public sealed class A
    {
        public void Method1() { }

        // Syntax error, a virtual member is invalid in a sealed class
        //public virtual void Method2() { }
    }

    // Syntax error, a derived class cannot inherit a sealed class
    //public class B : A { }

    public class C
    {
        public virtual void Method1() { }
    }

    public class D : C
    {
        public sealed override void Method1() { }
    }

    public class E : D
    {
        // Syntax error, 'E.Method1()' cannot override
        // inherited member 'D.Method1()' because it is sealed
        //public override void Method1() { }
    }
}
</code></pre>
                    <!-- !SECTION sealed -->
                    <!-- SECTION static -->
                    <h3 id="static">static</h3>
                    <p>So far the majority of the examples involve creating an instance of a class by using the <code>new</code> keyword. This
                        allows for multiple instances of a class to be created each with its own initialized state which can be set either by arguments passed in
                        through a constructor or with an object-initializer. Creating an instance of a class in this way is known as instantiation.</p>
                    <p>In addition you can make a class static by applying the <code>static</code> keyword to the class declaration. Here the class cannot be
                        instantiated but is instead created automatically during runtime and only one instance of it exists. As a static class is not assigned an instance
                        variable identifier it is accessed by its class name instead.</p>
                    <p>The following members can also be made static using the static the <code>static</code> keyword.</p>
                    <ul>
                        <li><a href="#Constructors">constructors</a></li>
                        <li><a href="#Methods">methods</a></li>
                        <li><a href="#Fields">fields</a></li>
                        <li><a href="#Properties">properties</a></li>
                        <li><a href="#Events">events</a></li>
                    </ul>
                    <p>Static members belong to the type and can't be accessed though an instance. Instead they are accessed through the type by using the type's
                        identifier in the form <code>TypeName.Member</code>. Within
                        a type, instance members can access static members but static members can only access other static members. As with a static class, static members
                        are created automatically at runtime and only one instance of the member exists. This means that if the value of a static member is changed
                        through its type or an instance of that type, then the value will be changed in all instances that contain it. Static fields that do not have
                        initializers and that are not assigned a value in a constructor will be assigned their default values. All members in a static class must always
                        be be static.</p>
                    <p> A static constructor can't have access modifiers or parameters and can't be inherited or overloaded, so a type can only have one. It is called
                        automatically at runtime after any static field initializers are executed and before any instances are created or any static members are accessed.
                        A static constructor can't be directly called and a developer can't control when it will be executed.</p>
                    <p>A static method can be useful when it is to perform simple functions that don't have to store or retrieve data from within the class. As it is
                        automatically created at runtime, it can be shared from multiple locations throughout the program without the necessity to create a new instance
                        every time. The .NET <code>System.Math</code> class which contains numerous small math functions is an example of a static class.
                    </p>
                    <p>In the following example, <code>InstanceClass</code> contains both instance and static, fields and methods. Whilst <code>InstanceMethod</code> can
                        access both <code>instanceField</code> and <code>staticField</code>, <code>StaticMethod</code> can only access <code>staticField</code>.</p>
                    <p> Next <code>MyClass</code> contains an instance property <code>InstanceProperty</code> and a static property <code>StaticProperty</code>.
                        <code>MyClass</code> also contains methods that can separately set and get the property values. The static property is first set without
                        an instance of <code>MyClass</code> through the use of <code>MyClass.StaticProperty</code>. Next 2 instances of <code>MyClass</code>,
                        <code>myClass1</code> and <code>myClass2</code> are created and when the values of the properties are displayed it can be seen that
                        <code>InstanceProperty</code> has the value 0 and the <code>StaticProperty</code> the value 1. Next <code>myClass1</code> is used to change only
                        the instance property in <code>myClass1</code> has changed whereas the the static property in both now has the value 3. This shows you that each
                        instance has its own copy of <code>InstanceProperty</code> whereas both share <code>StaticProperty</code>.</p>
                    <p>Lastly the static class <code>MyMathFunctions</code> has the static method <code>SquareNumber</code> which is called directly using
                        <code>MyMathFunction.SquareNumber</code> to display the square of 3.</p>
<pre><code>using System;

namespace StaticExample
{
    public class InstanceClass
    {
        private int _instanceField;
        private static int _staticField;

        public void InstanceMethod(int value)
        {
            // An instance method can access both
            // static and instance fields
            _staticField = value;
            _instanceField = value;
        }

        public static void StaticMethod(int value)
        {
            _staticField = value;

            // Syntax error, a static method cannot access an instance field
            //_instanceField = value;
        }
    }

    // MyClass requires an instance to be created
    // before any instance members within it can be used
    // Static members can be used without an instance
    public class MyClass
    {
        public int InstanceProperty { get; set; }

        public static int StaticProperty { get; set; }

        public int GetInstanceProperty()
        {
            return InstanceProperty;
        }

        public void SetInstanceProperty(int value)
        {
            InstanceProperty = value;
        }

        public int GetStaticProperty()
        {
            return StaticProperty;
        }

        public void SetStaticProperty(int value)
        {
            StaticProperty = value;
        }
    }

    // A static class cannot be instantiated and can only contain static members
    public static class MyMathFunctions
    {
        private static readonly double _PI;

        static MyMathFunctions()
        {
            _PI = 3.1415;
        }

        public static double PI =&gt; _PI;

        public static int SquareNumber(int value)
        {
            return value * value;
        }

        // Syntax error, a static class can't declare instance members
        //public void InstanceMethod() { }
    }

    class Program
    {
        static void Main(string[] args)
        {
            var nl = Environment.NewLine;

            // Set MyClass.StaticProperty
            MyClass.StaticProperty = 1;

            // Syntax error, an instance of a class must be created to
            // use an instance member even if it contains static members
            //MyClass.InstanceProperty = 1;

            MyClass myClass1 = new();
            MyClass myClass2 = new();

            // Display the initial values of the instance and
            // static properties in instanceClass1 and instanceClass2
            // Both instance values will be 0 as they were set when the
            // instance was created. The static property is shared by all
            // instances and was set to 1 by MyClass.StaticProperty = 1; above
            Console.WriteLine("Display initial static and instance property");
            Console.WriteLine($"values of the two instances of MyClass{nl}");
            Console.WriteLine($"myClass1 InstanceProperty: {myClass1.GetInstanceProperty()}");
            Console.WriteLine($"myClass2 InstanceProperty: {myClass2.GetInstanceProperty()}");
            Console.WriteLine($"myClass1 StaticProperty: {myClass1.GetStaticProperty()}");
            Console.WriteLine($"myClass2 StaticProperty: {myClass2.GetStaticProperty()}");

            // Change the instance and static properties in myClassInstance2
            Console.WriteLine($"{nl}The instance and static properties are changed in myClassInstance2");


            // Each instance of MyClass has its own instance of
            // InstanceProperty so only myClassInstance1's is changed
            myClass1.SetInstanceProperty(2);

            // Both instances of MyClass share StaticProperty so changing
            // the value in myClassInstance1 changes it for both
            myClass1.SetStaticProperty(3);
            Console.WriteLine($"values of the two instances of MyClass are now{nl}");
            Console.WriteLine($"myClass1 InstanceProperty: {myClass1.GetInstanceProperty()}");
            Console.WriteLine($"myClass2 InstanceProperty: {myClass2.GetInstanceProperty()}");
            Console.WriteLine($"myClass1 StaticProperty: {myClass1.GetStaticProperty()}");
            Console.WriteLine($"myClass2 StaticProperty: {myClass2.GetStaticProperty()}");

            // The MyMathFunctions Square method and PI property and can
            // be accessed without creating an instance of MyMathFunctions
            Console.WriteLine($"{nl}The square of 3 is {MyMathFunctions.SquareNumber(3)}");
            var area = MyMathFunctions.PI * 4 * 4;
            Console.WriteLine($"Area of a circle with radius 4 = {area}");

            // Syntax error, a static class cannot be instantiated
            //MyMathFunctions staticClass;
        }
    }
}

// The example writes the following to the console
// Display initial static and instance property
// values of the two instances of MyClass

// myClass1 InstanceProperty: 0
// myClass2 InstanceProperty: 0
// myClass1 StaticProperty: 1
// myClass2 StaticProperty: 1

// The instance and static properties are changed in myClassInstance2
// values of the two instances of MyClass are now

// myClass1 InstanceProperty: 2
// myClass2 InstanceProperty: 0
// myClass1 StaticProperty: 3
// myClass2 StaticProperty: 3

// The square of 3 is 9
// Area of a circle with radius 4 = 50.264
</code></pre>
                    <!-- !SECTION static -->
                    <!-- SECTION unsafe -->
                    <h3 id="unsafe">unsafe</h3>
                    <p>The <code>unsafe</code> modifier is outside the scope of this guide. For more information, please see the
                        <a href="#References">Microsoft C# reference documentation</a></p>
                    <!-- !SECTION unsafe -->
                    <!-- SECTION virtual -->
                    <h3 id="virtual">virtual</h3>
                    <p>A <a href="#Methods">method</a>, <a href="#Properties">property</a>, <a href="#Indexers">indexer</a> or <a href="#Events">event</a> that is marked
                        <code>virtual</code> can be <i>overridden</i> in a <a href="#Inheriting_types">derived</a> <a href="#class">class</a> or
                        <a href="#record">record</a>. See <a href="#override">override</a>.</p>
                    <p><em>Note:</em> <i>Microsoft has advised not to declare an event as <code>virtual</code> as the compiler does not handle these correctly.</i></p>
                    <!-- !SECTION virtual -->
                    <!-- SECTION volatile -->
                    <h3 id="volatile">volatile</h3>
                    <p>The <code>volatile</code> modifier is outside the scope of this guide. For more information, please see the
                        <a href="#References">Microsoft C# reference documentation</a></p>
                    <!-- !SECTION volatile -->
                    <!-- SECTION Access modifiers -->
                    <h3 id="Access_modifiers">Access modifiers</h3>
                    <p> Accessibility level declares where a type or type's members can be used by other code within an assembly or other assemblies that reference it.
                        Each type or
                        member has a default access level which, depending on the context, can be changed either by the access level of the container or by the use of an
                        access modifier keyword. A local variable's accessibility is always restricted to the <a href="#Scope">scope</a> in which it is contained and
                        cannot be modified.
                        Except for <code>protected internal</code> and <code>private protected</code> only one access modifier keyword can be applied to a type or a
                        member. For information about accessibility of the accessors for properties see <a href="#Properties">Properties</a> and for indexers see
                        <a href="#Indexers">Indexers</a>. Following is the list of access modifier keywords and the access level provided by them.</p>
                    <ul>
                        <li><i>public</i> - the same assembly or another assembly that references it</li>
                        <li><i>protected internal</i> - the same assembly or in a derived class in another assembly</li>
                        <li><i>protected</i> - the same class or a derived class in the same or another assembly</li>
                        <li><i>internal</i> - the same assembly only</li>
                        <li><i>private protected</i> - the same class or a derived class in the same assembly only</li>
                        <li><i>private</i> - the same class or a derived class nested within a base class only</li>
                    </ul>
                    <p>Types declared directly within a namespace (i.e. not nested), can only be declared public or internal where internal is the default level. The
                        following types can be be declared in a namespace <code>class</code>, <code>struct</code>, <code>interface</code>, <code>delegate</code>,
                        <code>record</code> and <code>enum</code>.</p>
                    <p>The following list shows containing types, which access modifiers can be applied to members and nested types, and the default access levels.</p>
                    <ul>
                        <li><i>class or record</i> - <code>public</code>, <code>protected internal</code>, <code>protected</code>,
                            <code>internal</code>, <code>private protected</code>, <code>private(default)</code></li>
                        <li><i>interface</i> - <code>public (default)</code>, <code>protected internal</code>, <code>protected</code>,
                            <code>internal</code>, <code>private protected</code>, <code>private</code>*</li>
                        <li><i>struct</i> - <code>public</code>, <code>internal</code>, <code>private(default)</code></li>
                    </ul>
                    <p>* A member in an interface that is marked <code>private</code> must have a default implementation.</p>
                    <p>Enum members do not have any declared accessibility and access modifiers cannot be applied to them. An enum member's accessibility  is determined
                        by the accessibility of the enum container type.</p>
                    <p>Even though not required, for code readability and to avoid errors, it is advisable to apply default level access modifiers to types and members.
                    </p>
                    <p>The following example demonstrates various accessibility scenarios. It contains two projects. The first is a class library called
                        <i>ClassLibrary</i> that has one file called <i>PublicBase.cs</i> with several classes within the namespace <code>ClassLibrary</code>. The second
                        is an executable called <i>AccessModifiers</i> that has a reference to ClassLibrary and one file called <i>Program.cs</i> with several classes
                        within the namespace <code>AccessModifiers</code>.</p>
<pre><code>// PublicBase.cs
// A class library referenced by Program.cs

namespace ClassLibrary
{
    public class PublicBase
    {
        public string PublicProperty { get; set; } = "library PublicProperty";
        protected internal string ProtectedInternalProperty { get; set; } = "library ProtectedInternalProperty";
        protected string ProtectedProperty { get; set; } = "library ProtectedProperty";
        internal string InternalProperty { get; set; } = "library InternalProperty";
        private protected string PrivateProtectedProperty { get; set; } = "library PrivateProtectedProperty";
        private string PrivateProperty { get; set; } = "library PrivateProperty";
    }

    internal class InternalBase { }

    class DefaultAccessBase { }
}

// ---------------------------------------------------------------------------------------------------

// Program.cs
// The main file of the program

using System;

namespace AccessModifiers
{
    // Default access for class without
    // an access modifier is internal
    class BaseClass
    {
        public string PublicProperty { get; set; } = "base PublicProperty";
        protected internal string ProtectedInternalProperty { get; set; } = "base ProtectedInternalProperty";
        protected string ProtectedProperty { get; set; } = "base ProtectedProperty";
        internal string InternalProperty { get; set; } = "base InternalProperty";
        private protected string PrivateProtectedProperty { get; set; } = "base PrivateProtectedProperty";
        private string PrivateProperty { get; set; } = "base PrivateProperty";

        // Default access for a class member
        // without an access modifier is private
        string DefaultProperty { get; set; } = "base DefaultProperty";

        // A method marked protected can only be
        // accessed within the base or a derived class
        protected void ProtectedMethod()
        {
            var nl = Environment.NewLine;
            Console.WriteLine($"base ProtectedMethod{nl}");
            PrivateMethod();
        }

        // A method marked private can only be
        // accessed from within the base class
        private void PrivateMethod()
        {
            var nl = Environment.NewLine;
            Console.WriteLine($"base PrivateMethod{nl}");
            // Within the same class any member can be accessed
            // within another no matter what its access level is
            Console.WriteLine($"base PrivateMethod PublicProperty = {PublicProperty}");
            Console.WriteLine($"base PrivateMethod ProtectedInternalProperty = {ProtectedInternalProperty}");
            Console.WriteLine($"base PrivateMethod ProtectedProperty = {ProtectedProperty}");
            Console.WriteLine($"base PrivateMethod InternalProperty = {InternalProperty}");
            Console.WriteLine($"base PrivateMethod PrivateProtectedProperty = {PrivateProtectedProperty}");
            Console.WriteLine($"base PrivateMethod PrivateProperty = {PrivateProperty}");
            Console.WriteLine($"base PrivateMethod DefaultProperty = {DefaultProperty}");
        }

        // As this class is nested it can be marked private
        private class Nested1 { }

        public class Nested2
        {
            public string PublicProperty { get; set; } = "nested PublicProperty";
            protected internal string ProtectedInternalProperty { get; set; } = "nested ProtectedInternalProperty";
            protected string ProtectedProperty { get; set; } = "nested ProtectedProperty";
            internal string InternalProperty { get; set; } = "nested InternalProperty";
            private protected string PrivateProtectedProperty { get; set; } = "nested PrivateProtectedProperty";
            private string PrivateProperty { get; set; } = "nested PrivateProperty";
        }
    }

    // Syntax error, a class that is not nested i.e. declared within
    // a namespace can only be marked as internal or public
    //private class Base2 { }

    // Inherits from Base within same assembly
    class DerivedClass : BaseClass
    {
        public void PublicMethod()
        {
            var nl = Environment.NewLine;
            Console.WriteLine($"derived PublicMethod{nl}");
            PublicProperty = "derived publicProperty";
            ProtectedInternalProperty = "derived protectedInternalProperty";
            ProtectedProperty = "derived protectedProperty";
            InternalProperty = "derived internalProperty";
            PrivateProtectedProperty = "derived privateProtectedProperty";

            // Syntax error, as 'PrivateProperty' and 'DefaultProperty' are private
            // in the base class they are inaccessible in the derived class
            //PrivateProperty = 0;
            //DefaultProperty = 0;

            ProtectedMethod();
        }
    }

    // Inherits PublicBase from ClassLibrary
    public class Class1 : ClassLibrary.PublicBase
    {
        public void PublicMethod()
        {
            PublicProperty = "Class1 publicProperty";
            ProtectedInternalProperty = "Class1 protectedInternalProperty";
            ProtectedProperty = "Class1 protectedProperty";

            // Syntax error, internal, private protected and private marked
            // members can only be accessed within the same assembly
            //InternalPublicProperty = "Class1 InternalPublic";
            //PrivateProtectedPublicProperty = "Class1 PrivateProtectedPublic";
            //PrivatePublicProperty = "Class1 PrivateProperty";
        }
    }

    // Cannot inherit from 'ClassLibrary.InternalBase' as it has
    // been marked Internal and cannot be accessed in another assembly
    //public class Class2 : ClassLibrary.InternalBase { }

    // Cannot inherit from 'ClassLibrary.DefaultAccessBase'
    // as it has no access modifier, is internal by default
    // and cannot be accessed in another assembly
    //public class Class3 : ClassLibrary.DefaultAccessBase { }

    class Program
    {
        static void Main(string[] args)
        {
            var nl = Environment.NewLine;

            // Only the internal, protected internal and public properties
            // from BaseClass, BaseClass.Nested2 and DerivedClass
            // are accessible within the Program class
            BaseClass baseClass = new();
            Console.WriteLine(baseClass.InternalProperty);
            Console.WriteLine(baseClass.ProtectedInternalProperty);
            Console.WriteLine(baseClass.PublicProperty + nl);

            BaseClass.Nested2 nested2 = new();
            Console.WriteLine(nested2.InternalProperty);
            Console.WriteLine(nested2.ProtectedInternalProperty);
            Console.WriteLine(nested2.PublicProperty + nl);

            DerivedClass derivedClass = new();
            Console.WriteLine(derivedClass.InternalProperty);
            Console.WriteLine(derivedClass.ProtectedInternalProperty);
            Console.WriteLine(derivedClass.PublicProperty + nl);
            derivedClass.PublicMethod();

            Class1 class1 = new();
            // Only the Public property from ClassLibrary.PublicBase that
            // Class1 inherited is accessible within the Program class
            Console.WriteLine(nl + class1.PublicProperty + nl);
            class1.PublicMethod();
            Console.WriteLine(class1.PublicProperty + nl);
        }
    }
}

// The example prints the following to the console
// base InternalProperty
// base ProtectedInternalProperty
// base PublicProperty

// nested InternalProperty
// nested ProtectedInternalProperty
// nested PublicProperty

// base InternalProperty
// base ProtectedInternalProperty
// base PublicProperty

// derived PublicMethod

// base ProtectedMethod

// base PrivateMethod

// base PrivateMethod PublicProperty = derived publicProperty
// base PrivateMethod ProtectedInternalProperty = derived protectedInternalProperty
// base PrivateMethod ProtectedProperty = derived protectedProperty
// base PrivateMethod InternalProperty = derived internalProperty
// base PrivateMethod PrivateProtectedProperty = derived privateProtectedProperty
// base PrivateMethod PrivateProperty = base PrivateProperty
// base PrivateMethod DefaultProperty = base DefaultProperty

// library PublicProperty

// Class1 publicProperty
</code></pre>
                    <!-- !SECTION Access modifiers -->
                </article>
            </section>
            <!-- !SECTION Scope and Modifiers -->
            <!-- SECTION Object-oriented Programming -->
            <section class="main-section" id="Object-oriented_Programming">
                <header><h2>Object-oriented Programming</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>Object-oriented programming (OOP) is a programming paradigm used extensively throughout C#. It encompasses a number of concepts that provide the
                        developer a structured process for writing a program. This is particularly important for large applications that may be maintained by multiple
                        teams of developers. Instead of having one massive length of code that does everything, it is instead broken down into objects that each have a
                        narrowly defined responsibility. C# uses a sort of template called a type to define an object that is created when a program is run and multiple
                        objects, also called instances, can be created based on the type, each with their own state. These types are then combined to create an assembly
                        and one or more assemblies are combine to create an application.</p>
                    <p> Major principles of OOP include:</p>
                    <ul>
                        <li>Object</li>
                        <li>Encapsulation</li>
                        <li>Inheritance</li>
                        <li>Abstraction</li>
                        <li>Polymorphism</li>
                    </ul>
                    <!-- SECTION Object -->
                    <h3 id="Object">Object</h3>
                    <p>An object combines data and behavior to represent everyday things such as a number, a spreadsheet, a person or even something less tangible such as
                        the relationship between a part's name and its quantity in a database. During runtime multiple objects are created from a type definition each
                        with their own own internal state. This allows different versions (instances) of an object to exist. For example two number type objects could be
                        created, one with a value of 5 and another with 7. Three techniques employed by C# to define an object are:</p>
                    <ul>
                        <li>Properties - a particular state of an object such as color, the number of columns, what a thing is made of.</li>
                        <li>Methods - the behavior of an object such as add numbers, manipulate text, etc. Methods can take in and return modified data.</li>
                        <li>Events - a way of communicating to other objects that its state has changed.</li>
                    </ul>
                    <p>Take for example a light. It could have a 'Light Is On' property, a 'Turn Light On' method and a 'Light Has Turned' On event. A person object
                        could then check the 'Light Is On' property and if it's off (false), use the 'Turn Light On' method to turn the light on. The method would then
                        set 'Light Is On' to true and then trigger the 'Light Has Turned On' event. A second person object could be watching out for the event and when it
                        happens it would know to run its own 'Read Book' method.</p>
                    <!-- !SECTION Object -->
                    <!-- SECTION Encapsulation -->
                    <h3 id="Encapsulation">Encapsulation</h3>
                    <p>Encapsulation protects the data and methods used to define the internal state of an object from direct manipulation. Data that is passed in and out
                        of the object can be validated so as to ensure that the state of the object becomes invalid. This way code external to an object need not be
                        concerned with the data it contains or how a method works, only that by using it, it will provide the expected result. Take for example the
                        posting of a letter. Provided that you give it the correct address and a stamp, once you place it in the mail box you expect it to arrive at the
                        recipient. You need not be concerned with the details of the method (how it will be delivered) or the internal data (the name of the person doing
                        the delivery). With this the creator of the object is free to change the internal workings of an object without affecting those using it, as long
                        as it continues to do what it says on the box. In order to decide which object members are made available externally to an object, C# provides
                        access modifier keywords such as <code>public</code> and <code>private</code>.</p>
                    <!-- !SECTION Encapsulation -->
                    <!-- SECTION Inheritance -->
                    <h3 id="Inheritance">Inheritance</h3>
                    <p>Many things in life have similarities. For example a car and a motorbike both have an engine, wheels and brakes but where as a motorbike has
                        handle bars a car has a steering wheel. This makes it difficult to use one object to represent both but rather than create two objects duplicating
                        much of the same functionality we can use the concept of inheritance. Here, first an parent object containing all the common traits is created
                        then separate child objects based on the parent are created, each adding just their own differences. Using the previous example we could create a
                        vehicle object that has the engine, brakes and wheels properties then from that create a motorbike object that adds handle bars and a car object
                        that adds a steering wheel. By having a common inherited wheels property the number of wheels can be set at runtime to 2 for a motorbike and 4 for
                        car or even 3 if it is a three-wheeler.</p>
                    <p>Other names for parent are ancestor or superclass and for child, descendant or subclass. Just to be different, C# calls a parent a base type and
                        a child a derived type which is specifically mentioned here as C# provides the <code>base</code> keyword to access a base type from a derived
                        type. Also note that structs can neither inherit or be inherited by another class or struct.</p>
                    <!-- !SECTION Inheritance -->
                    <!-- SECTION Abstraction -->
                    <h3 id="Abstraction">Abstraction</h3>
                    <p>Abstraction is the process of determining and extracting from a complex problem just the information we require to define a solution. For example
                        what does it take to eat food. Here we need to ask an expert in this case lets consider what a child would say. They'd probably say something
                        like, you  put food in your mouth chew it then swallow. That's it. Now of course the human body is an extremely complex organism, to actually
                        eat food the brain has to send signals to the jaw muscles to chew the food, then to the tongue to swallow it. From there it goes into the stomach
                        where it is mixed with acid, then into the small intestine ... But for the purposes of survival all the user has to be concerned with is food,
                        mouth, chew, swallow. Of course had we omitted the chew step then the choke method may have kicked in resulting in a premature end to our program.
                        It is important then to extract exactly what is required, no less, no more and this is an essential design step before the first line of code is
                        even written.</p>
                    <p>Another term you may come across is abstraction layers which is the dividing of a problem into the various layers of complexity. Take for instance
                        what is involved in writing and running an application. As mentioned in the C Sharp Language section all a computer knows is ones and zeroes but
                        even that is not the lowest level. If we go further we get down to the quantum level where the state of electrons are controlled by transistors.
                        This is the hardware abstraction layer limited mainly to the manufacturer. Above the ones and zeroes, or binary abstraction layer, is the assembly
                        language which is a set of instructions in a pseudo human language provided by hardware manufacturers as to what the hardware does. This is the
                        language used by by those creating the compiler that translates the C# language we write into the binary language amd ultimately into the quantum
                        state of the hardware. This does not mean that someone writing in C# is completely separated from the other layers. For example as you use the
                        code editor the the compiler is constantly interpreting what you write and if it can't, it will warn you that there is a syntax error.</p>
                    <!-- !SECTION Abstraction -->
                    <!-- SECTION Polymorphism -->
                    <h3 id="Polymorphism">Polymorphism</h3>
                    <p>Polymorphism is the ability to substitute any child object for its parent and the members they contain. Using the inheritance example, we want to
                        make sure that we can steer our vehicle so we provide a steer method. This presents a problem as we can't be sure whether the consumer is going
                        to buy a car or a motorbike. The car has a steering wheel property that has to be set whereas the motor bike has handle bars. Polymorphism allows
                        you to substitute what the steer method does in the child object. If you then have a purchasing object, that has a buy method that can take in a
                        vehicle object and when it is called, you can substitute the vehicle parent object for either car or motorbike child object. This way whichever is
                        provided will have the correct steer method. </p>
                    <!-- !SECTION Polymorphism -->
                </article>
            </section>
            <!-- !SECTION Object-oriented Programming -->
            <!-- SECTION Keywords and Specifications -->
            <section class="main-section" id="Keywords_and_Specifications">
                <header><h2>Keywords and Specifications</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <!-- SECTION Keywords -->
                    <h3 id="Keywords">Keywords</h3>
                    <p>Keywords are words reserved for use by the compiler and cannot be used as identifiers unless prefixed with<code>@</code>. It is advisable not to do
                        so as there is the possibility of introducing errors. For detailed information on the keywords and specifications listed below links to the
                        Microsoft reference documentation can be found in <a href="#References">References</a>.</p>
                    <!-- SECTION C# Reserved keywords -->
                    <h4 id="C_sharp_Reserved_keywords">C# Reserved keywords</h4>
                    <p>These are keywords that are reserved throughout any part of a C# program</p>
                    <div class="four-column">
                        <!-- Column 1 -->
                        <div>
                            <p>abstract</p>
                            <p>as</p>
                            <p>base</p>
                            <p>bool</p>
                            <p>break</p>
                            <p>byte</p>
                            <p>case</p>
                            <p>catch</p>
                            <p>char</p>
                            <p>checked</p>
                            <p>class</p>
                            <p>const</p>
                            <p>continue</p>
                            <p>decimal</p>
                            <p>default</p>
                            <p>delegate</p>
                            <p>do</p>
                            <p>double</p>
                            <p>else</p>
                            <p>enum</p>
                        </div>
                        <!-- Column 2 -->
                        <div>
                            <p>event</p>
                            <p>explicit</p>
                            <p>extern</p>
                            <p>false</p>
                            <p>finally</p>
                            <p>fixed</p>
                            <p>float</p>
                            <p>for</p>
                            <p>foreach</p>
                            <p>goto</p>
                            <p>if</p>
                            <p>implicit</p>
                            <p>in</p>
                            <p>int</p>
                            <p>interface</p>
                            <p>internal</p>
                            <p>is</p>
                            <p>lock</p>
                            <p>long</p>
                        </div>
                        <!-- Column 3 -->
                        <div>
                            <p>namespace</p>
                            <p>new</p>
                            <p>null</p>
                            <p>object</p>
                            <p>operator</p>
                            <p>out</p>
                            <p>override</p>
                            <p>params</p>
                            <p>private</p>
                            <p>protected</p>
                            <p>public</p>
                            <p>readonly</p>
                            <p>ref</p>
                            <p>return</p>
                            <p>sbyte</p>
                            <p>sealed</p>
                            <p>short</p>
                            <p>sizeof</p>
                            <p>stackalloc</p>
                        </div>
                        <!-- Column 4 -->
                        <div>
                            <p>static</p>
                            <p>string</p>
                            <p>struct</p>
                            <p>switch</p>
                            <p>this</p>
                            <p>throw</p>
                            <p>true</p>
                            <p>try</p>
                            <p>typeof</p>
                            <p>uint</p>
                            <p>ulong</p>
                            <p>unchecked</p>
                            <p>unsafe</p>
                            <p>ushort</p>
                            <p>using</p>
                            <p>virtual</p>
                            <p>void</p>
                            <p>volatile</p>
                            <p>while</p>
                        </div>
                    </div>
                    <!-- !SECTION C# Reserved keywords -->
                    <!-- SECTION C# Contextual keywords -->
                    <h4 id="Contextual_keywords">Contextual keywords</h4>
                    <p>These are keywords that are reserved in only limited context within the program.</p>
                    <div class="four-column">
                        <!-- Column 1 -->
                        <div>
                            <p>add</p>
                            <p>and</p>
                            <p>alias</p>
                            <p>ascending</p>
                            <p>async</p>
                            <p>await</p>
                            <p>by</p>
                            <p>descending</p>
                            <p>dynamic</p>
                            <p>equals</p>
                            <p>from</p>
                        </div>
                        <!-- Column 2 -->
                        <div>
                            <p>get</p>
                            <p>global</p>
                            <p>group</p>
                            <p>init</p>
                            <p>into</p>
                            <p>join</p>
                            <p>let</p>
                            <p>managed (function pointer calling convention)</p>
                            <p>nameof</p>
                            <p>nint</p>
                            <p>not</p>
                        </div>
                        <!-- Column 3 -->
                        <div>
                            <p>notnull</p>
                            <p>nuint</p>
                            <p>on</p>
                            <p>or</p>
                            <p>orderby</p>
                            <p>partial (type)</p>
                            <p>partial (method)</p>
                            <p>record</p>
                            <p>remove</p>
                            <p>select</p>
                        </div>
                        <!-- Column 4 -->
                        <div>
                            <p>set</p>
                            <p>unmanaged (function pointer calling convention)</p>
                            <p>unmanaged (generic type constraint)</p>
                            <p>value</p>
                            <p>var</p>
                            <p>when (filter condition)</p>
                            <p>where (generic type constraint)</p>
                            <p>where (query clause)</p>
                            <p>with</p>
                            <p>yield</p>
                        </div>
                    </div>
                    <!-- !SECTION C# Contextual keywords -->
                    <!-- !SECTION Keywords -->
                    <!-- SECTION C# Specifications -->
                    <h3 id="C_Sharp_Specifications">C# Specifications</h3>
                    <p>Following is a list of specifications for the various C# types and escape characters</p>
                    <!-- SECTION C# Value type keywords -->
                    <h4 id="Value_type_keywords">Value type keywords</h4>
                    <ul>
                        <li>Boolean: <b>bool</b></li>
                        <li>Signed integer: <b>sbyte</b>, <b>short</b>, <b>int</b>, <b>long</b></li>
                        <li>Unsigned integer: <b>byte</b>, <b>ushort</b>, <b>uint</b>, <b>ulong</b></li>
                        <li>IEEE binary floating-point: <b>float</b>, <b>double</b></li>
                        <li>Decimal floating-point: <b>decimal</b></li>
                        <li>Unicode characters: <b>char</b></li>
                        <li>User-defined type of form <b>enum E {...}</b></li>
                        <li>User defined type of form <b>struct S {...}</b></li>
                        <li>Nullable value type: Extension of all other value types with a null value of the form <b>T?</b></li>
                    </ul>
                    <!-- !SECTION C# Value type keywords -->
                    <!-- SECTION C# Value type range and size -->
                    <h4 id="Value_type_range_and_size">Value type range and size</h4>
                    <ul>
                        <li><span><b>bool</b> :</span> false, true (1 byte, 8 bits)</li>
                        <li><b>sbyte</b> : -128 to 127 (1 byte, 8 bits)</li>
                        <li><b>short</b> : -32,768 to 32,767 (2 bytes, 16 bits)</li>
                        <li><b>int</b> : -2,147,438,648 to 2,147,483,647 (4 bytes, 32 bits)</li>
                        <li><b>long</b> : -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 (8 byte, 64 bits)</li>
                        <li><b>byte</b> : 0 to 255 (1 byte, 8 bits)</li>
                        <li><b>ushort</b> : -128 to 127 (2 byte, 16 bits)</li>
                        <li><b>uint</b> : 0 to 65,535 (4 byte, 32 bits)</li>
                        <li><b>ulong</b> : 0 to 18,446,744,073,709,551,615 (8 byte, 64 bits)</li>
                        <li><b>float</b> : 1.5 x 10-45 to 3.4 x 1038, 7-digit precision (4 byte, 32 bits)</li>
                        <li><b>double</b> : 5.0 x 10-324 to 1.7 x 10308, 15-digit precision (8 byte, 64 bits)</li>
                        <li><b>decimal</b> : 1.0 x 10-28 to  7.9 x 1028, 28-bit precision (16 byte, 128 bits)</li>
                    </ul>
                    <!-- !SECTION C# Value type range and size -->
                    <!-- SECTION C# Built-in reference types -->
                    <h4 id="Built-in_reference_types">Built-in reference types</h4>
                    <ul>
                        <li>Ultimate base class of all other types: <b>object</b></li>
                        <li>Unicode strings: <b>string</b></li>
                        <li>Array types: Single dimensional <b>int[]</b>, multi-dimensional <b>int[,]</b></li>
                        <li>dynamic of the form <b>dynamic T</b></li>
                    </ul>
                    <!-- !SECTION C# Built-in reference types -->
                    <!-- SECTION C# User defined reference types -->
                    <h4 id="User_defined_reference_types">User defined reference types</h4>
                    <ul>
                        <li>User defined type of form <b>class C {...}</b></li>
                        <li>User defined type of form <b>interface I {...}</b></li>
                        <li>User-defined type of form <b>delegate T D(...)</b></li>
                        <li>User-defined type of form <b>record T R(...)</b></li>
                    </ul>
                    <p>The default value for all integer and floating-point types is 0.</p>
                    <p>A literal is interpreted by the compiler both by the way it is written and the context in which it is used. A compile error will result if a
                        literal is outside the range for the type it is being assigned to.</p>
                    <p>In the following</p>
<!-- Line space at bottom of code block is to prevent vertical scroll bar due to underline -->
<pre><code>byte b = 25; // This is OK
<u class="error">byte b = 311;</u> // Compile error: Value '311' cannot be converted to a 'byte'.

</code></pre>
                    <p>Literals are interpreted as follows.</p>
                    <p class="no-bottom-margin">Boolean literal, one of:</p>
                    <p><i>true &emsp; false</i></p>
<pre><code>bool test = true;
bool test = false;
</code></pre>
                    <p>Integer literals consist of combinations of the following.</p>
                    <p class="no-bottom-margin">decimal digits:</p>
                    <p><i>0 1 2 3 4 5 6 7 8 9</i></p>
                    <p class="no-bottom-margin">hex digits:</p>
                    <p><i>0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f</i></p>
                    <p class="no-bottom-margin">unsigned, long and unsigned long identification suffix, one of:</p>
                    <p><i>U  u  L  l  UL  Ul  uL  ul  LU  Lu  lU  lu</i></p>
                    <p class="no-bottom-margin">sign prefix, one of:</p>
                    <p><i>+ -</i></p>
                    <p class="no-bottom-margin">hexadecimal identification prefix, one of:</p>
                    <p><i>0x hex-digits&emsp;0X hex-digits</i></p>
                    <p>Integer literals type are interpreted in the following order</p>
                    <ul>
                        <li>No suffix : <i>int, uint, long, ulong</i></li>
                        <li>Suffixed with <i>U</i> or <i>u</i> : <i>uint, ulong</i></li>
                        <li>Suffixed with <i>L</i> or <i>l</i> : <i>long, ulong</i></li>
                        <li>Suffixed by <i>UL, Ul, uL, ul, LU, Lu, lU, lu</i> : <i>ulong</i></li>
                    </ul>
                    <p>Some examples of usage</p>
<pre><code>var a = 1; // int
var b = -2147483648; // int
var c = 2147483648; // uint
var d = -9223372036854775808; // long
var e = 9223372036854775808; // ulong
var f = 4294967295u; // uint
var g = 4294967296u; // ulong
var h = -1L; // long
var j = 9223372036854775807L; // long
var k = 9223372036854775808L; // ulong
var l = 1UL; // ulong
var hex = 0xF81A; // int
</code></pre>
                    <p>A value outside of the range of the ulong type results in a compile error</p>
<pre><code>var tooBig = 18446744073709551616; // compile error: Integral constant too large
</code></pre>
                    <p>Real literals consist of combinations of the following:</p>
                    <p class="no-bottom-margin">decimal digits:</p>
                    <p><i>0 1 2 3 4 5 6 7 8 9</i></p>
                    <p class="no-bottom-margin">exponent part, one of:</p>
                    <p><i>e sign decimal digits &emsp; E sign decimal digits</i></p>
                    <p class="no-bottom-margin">sign prefix, one of:</p>
                    <p><i>+ -</i></p>
                    <p class="no-bottom-margin">real type suffix, one of:</p>
                    <p><i>F  f  D  d  M  m</i></p>
                    <p>Real literals are interpreted as follows</p>
                    <ul>
                        <li>No suffix : <i>double</i></li>
                        <li>Suffixed with <i>F</i> or <i>f</i> : <i>float</i></li>
                        <li>Suffixed with <i>D</i> or <i>d</i> : <i>double</i></li>
                        <li>Suffixed with <i>M</i> or <i>m</i> : <i>decimal</i></li>
                    </ul>
                    <p><em>Note:</em> <i>As per integer literals above a literal digit that is a whole number will be interpreted as an integer.</i></p>
<pre><code>var i = 1; // int
</code></pre>
                <p>Literals interpreted as real numbers</p>
<pre><code>var a = 1.0; //double
var b = 2.3; // double
var c = 3e9; // double
var d = -2.1e-3; // double
var e = 1f; // float
var f = 2.3f; // float
var g = 3e9f; // float
var h = -2.1e-3f; // float
var j = 1d; // double
var k = 2.3d; // double
var l = 3e9d; // double
var m = -2.1e-3d; // double
var n = 1m; // decimal
var o = 2.3m; // decimal
var p = 3e9m; // decimal
var q = -2.1e-3m; // decimal
</code></pre>
                    <!-- !SECTION C# User defined reference types -->
                    <!-- SECTION C# Character specifications -->
                    <h4 id="Character_specifications">Character specifications</h4>
                    <p>Single character, one of:</p>
                    <p>any character except <code>'</code> <i>(U+0027)</i>, <code>\</code> <i>(U+005C)</i> or line character</p>
                    <p>Simple escape character, one of:</p>
                    <ul>
                        <li><b>\'</b>&emsp; Single quote</li>
                        <li><b>\"</b>&emsp; Double quote</li>
                        <li><b>\\</b>&emsp; Backslash</li>
                        <li><b>\0</b>&emsp; Null</li>
                        <li><b>\a</b>&emsp; Alert</li>
                        <li><b>\b</b>&emsp; Backspace</li>
                        <li><b>\f</b>&emsp; Form feed</li>
                        <li><b>\n</b>&emsp; New line</li>
                        <li><b>\r</b>&emsp; Carriage return</li>
                        <li><b>\t</b>&emsp; Horizontal tab</li>
                        <li><b>\v</b>&emsp; Vertical tab</li>
                    </ul>
                    <p class="no-bottom-margin">Unicode character escape sequence (UTF-16), one of:</p>
                    <p><b>\u0000</b> to <b>\uFFFF</b></p>
                    <p class="no-bottom-margin">Unicode character escape sequence (UTF-32), one of:</p>
                    <p><b>\U000000</b> to <b>\U10FFFF</b></p>
                    <p class="no-bottom-margin">Unicode escape sequence similar to "\u" except with variable length:</p>
                    <p><b>\x hhhh</b>&emsp; <em>Note:</em> <i>Due to possible confusion with \u and \U Unicode escape sequences it is not recommended to use
                        <b>\x hhhh</b></i></p>
                    <p>The default character value is the NUL character \u0000</p>
                    <p>Character literal examples</p>
<pre><code>var a = 'a' \\ the <i>a</i> character
var b = '\\' \\ the <i>\</i> character
var c = '\u0123' \\ the <i>g</i> character
</code></pre>
                    <!-- !SECTION C# Character specifications -->
                    <!-- !SECTION C# Specifications -->
                </article>
            </section>
            <!-- !SECTION Keywords -->
            <!-- Completed -->
            <!-- SECTION References -->
            <section class="main-section" id="References">
                <header><h2>References</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>
                        <a href="https://docs.microsoft.com/en-us/dotnet/csharp/"
                         rel="external nofollow noopener noreferrer" target="_blank">Microsoft C# reference documentation</a>
                    </p>
                    <p>
                        <a href="https://www.ecma-international.org/wp-content/uploads/ECMA-334_5th_edition_december_2017.pdf"
                         rel="external nofollow noopener noreferrer" target="_blank">ECMA-334 C# Language Specification</a>
                    </p>
                </article>
            </section>
            <!-- !SECTION References -->
<!-- TODO add copyright -->
            <!-- SECTION Terms and Conditions -->
            <section class="main-section" id="Terms_and_Conditions">
                <header><h2>Terms and Conditions</h2></header>
                <a class="back-to-top" href="#">Back to top</a>
                <article>
                    <p>You accept all risk of using the website and content on the website. As far as the law allows, Stephen Ward provides the website as is, without any
                        warranty whatsoever.</p>
                    <p>The website may hyperlink to and integrate websites and services run by others. Stephen Ward does not make any warranty about services run by
                        others, or content they may provide. Use of services run by others may be governed by other terms between you and the one running the service.</p>
                    <h3 id="Notice_of_Non-Affiliation_and_Disclaimer">Notice of Non-Affiliation and Disclaimer</h3>
                    <p>Stephen Ward is not affiliated, associated, authorized, endorsed by, or in any way officially connected with Microsoft or any of its subsidiaries
                        or its affiliates.</p>
                    <p>Microsoft, Visual C#, Visual Studio, IntelliSense and Windows are trademarks of the Microsoft group of companies.</p>
                </article>
            </section>
            <!-- !SECTION Terms and Conditions -->

        </main>
<!-- TODO Uncomment FreeCodeCamp script-->
        <!-- <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script> -->
    </body>
</html>